<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rhine Draft Calculator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.21.2/babel.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            color: white;
            background-color: #121212;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100%;
        }

        header {
            background-color: #1e1e1e;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .dashboard-controls {
            display: flex;
            padding: 1rem;
            background-color: #1e1e1e;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        select, input, button {
            background-color: #2a2a2a;
            color: white;
            border: none;
            padding: 0.5rem;
            border-radius: 4px;
        }

        button {
            cursor: pointer;
        }

        .main-content {
            flex-grow: 1;
            padding: 1rem;
            overflow: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid #333;
        }

        th {
            background-color: #1e1e1e;
            position: sticky;
            top: 0;
        }

        tr:hover {
            background-color: #2a2a2a;
        }

        .critical-row {
            background-color: rgba(255, 0, 0, 0.3);
        }

        .draft-highlight {
            font-weight: bold;
            color: #00cc66;
        }

        .critical-draft {
            font-weight: bold;
            color: #ff6666;
        }

        footer {
            background-color: #1e1e1e;
            padding: 1rem;
            font-size: 0.875rem;
            display: flex;
            justify-content: space-between;
        }

        .highlight-box {
            background-color: #cc9900;
            border-radius: 4px;
            padding: 0.5rem;
            color: black;
            font-weight: bold;
        }

        .data-status {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background-color: #333;
            border-radius: 4px;
            font-size: 0.875rem;
        }
        .data-status.pending { background-color: #444; }
        .data-status.success { background-color: #006400; }
        .data-status.error { background-color: #8B0000; }


        .refresh-btn {
            background-color: #0066cc;
            padding: 0.5rem 1rem;
            cursor: pointer;
        }

        .refresh-btn:hover {
            background-color: #0055aa;
        }
    </style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
    const {useState, useEffect, useCallback, useRef} = React;

    // Cookie utility functions
    function setCookie(name, value, days = 3650) {
        const date = new Date();
        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
        const expires = `expires=${date.toUTCString()}`;
        document.cookie = `${name}=${JSON.stringify(value)};${expires};path=/`;
    }

    function getCookie(name) {
        const nameEQ = `${name}=`;
        const ca = document.cookie.split(';');
        for (let i = 0; i < ca.length; i++) {
            let c = ca[i];
            while (c.charAt(0) === ' ') c = c.substring(1, c.length);
            if (c.indexOf(nameEQ) === 0) {
                try {
                    return JSON.parse(c.substring(nameEQ.length, c.length));
                } catch (e) {
                    console.error("Error parsing cookie:", e);
                    return null;
                }
            }
        }
        return null;
    }

    // Format time display (simplified as API provides HH:MM directly now)
    function formatTimeDisplay(timeString) {
        // Assumes timeString is already in HH:MM format or similar simple format
        // If it's a full date string, attempt to format
        try {
            if (timeString && timeString.includes(':') && timeString.length <= 5) {
                return timeString; // Already formatted
            }
            const date = new Date(timeString);
            if (isNaN(date.getTime())) {
                // Handle the specific "YYYY-MM-DD HH:MM" format from the API's currentTime
                 if (typeof timeString === 'string' && timeString.includes(' ')) {
                     const parts = timeString.split(' ');
                     if (parts.length === 2 && parts[1].includes(':')) {
                         return parts[1]; // Return the HH:MM part
                     }
                 }
                return timeString || "N/A"; // Return original or N/A if invalid
            }
            return date.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
        } catch (error) {
            console.error("Error formatting time:", error, "Input:", timeString);
            return "N/A";
        }
    }

    // Fetch data from the custom API
    async function fetchDataFromCustomAPI() {
        const apiUrl = 'https://rdd-backend.vercel.app/api/data';
        console.log(`Fetching data from custom API: ${apiUrl}`);
        try {
            const response = await fetch(apiUrl);
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`API request failed with status ${response.status}: ${errorText}`);
            }
            const apiData = await response.json();
            console.log("Received data from custom API:", apiData);

            const processedData = {
                waterLevels: {},
                waterTrends: {},
                currentTimes: {},
                forecasts: {},
                lastUpdated: new Date(), // Default to fetch time
                apiForecastDates: new Set() // Store dates available in API response
            };
            let latestSourceUpdateTime = 0; // Track the latest update time from the source

            const todayStr = new Date().toISOString().split('T')[0]; // Get today's date string

            for (const gaugeName in apiData) {
                if (apiData.hasOwnProperty(gaugeName)) {
                    const gaugeInfo = apiData[gaugeName];

                    // Basic data
                    processedData.waterLevels[gaugeName] = gaugeInfo.currentLevel ?? null;
                    processedData.waterTrends[gaugeName] = gaugeInfo.currentTrend ?? null;
                    processedData.currentTimes[gaugeName] = formatTimeDisplay(gaugeInfo.currentTime); // Use formatter

                    // Process forecasts, filtering out today's date
                    // Process forecasts, filtering out today's date
if (gaugeInfo.forecasts) {
    for (const dateStr in gaugeInfo.forecasts) {
        // --- IMPORTANT: Filter out today's forecasts ---
        if (dateStr > todayStr) {
            processedData.apiForecastDates.add(dateStr); // Add valid future date

            if (!processedData.forecasts[dateStr]) {
                processedData.forecasts[dateStr] = {};
            }
            if (!processedData.forecasts[dateStr][gaugeName]) {
                processedData.forecasts[dateStr][gaugeName] = {};
            }

            // Extract only the 'value' for each time slot
            for (const timeStr in gaugeInfo.forecasts[dateStr]) {
                // Ensure timeStr is HH:MM format and value exists
                if (timeStr.match(/^\d{2}:\d{2}$/) && gaugeInfo.forecasts[dateStr][timeStr]?.value !== undefined && gaugeInfo.forecasts[dateStr][timeStr]?.value !== null) {
                    processedData.forecasts[dateStr][gaugeName][timeStr] = gaugeInfo.forecasts[dateStr][timeStr].value;
                }
            }
            // Clean up gauge entry if no valid times were added
            if (Object.keys(processedData.forecasts[dateStr][gaugeName]).length === 0) {
                delete processedData.forecasts[dateStr][gaugeName];
            }

            // Clean up date entry if no valid gauges were added
            if (Object.keys(processedData.forecasts[dateStr]).length === 0) {
                delete processedData.forecasts[dateStr];
            }
        }
    }
}

                    // Track the latest 'lastUpdated' time from the API response sources
                    if (gaugeInfo.lastUpdated) {
                        try {
                            const updateTime = new Date(gaugeInfo.lastUpdated).getTime();
                            if (!isNaN(updateTime) && updateTime > latestSourceUpdateTime) {
                                latestSourceUpdateTime = updateTime;
                            }
                        } catch (e) {
                            console.warn(`Could not parse lastUpdated timestamp "${gaugeInfo.lastUpdated}" for ${gaugeName}`);
                        }
                    }
                }
            }

            // Set the overall lastUpdated time based on the latest source update time if available
            if (latestSourceUpdateTime > 0) {
                processedData.lastUpdated = new Date(latestSourceUpdateTime);
            }

            console.log("Processed data:", processedData);
            return processedData;

        } catch (error) {
            console.error('Error fetching or processing data from custom API:', error);
            throw error; // Re-throw to be caught by the caller
        }
    }


    // Rhine Draft Calculator Component
    function RhineDraftCalculator() {
        const [gaugeData, setGaugeData] = useState([]);
        const [waterLevels, setWaterLevels] = useState({});
        const [waterTrends, setWaterTrends] = useState({});
        const [forecasts, setForecasts] = useState({});
        const [customCorrections, setCustomCorrections] = useState({upstream: {}, downstream: {}})
        const [forecastDates, setForecastDates] = useState([]); // Dates to display in columns
        const [dataLoaded, setDataLoaded] = useState(false);
        const [dataStatus, setDataStatus] = useState({status: 'pending', message: 'Initializing...'});
        const [lastUpdated, setLastUpdated] = useState(new Date());
        const [travelDirection, setTravelDirection] = useState('downstream');
        const [currentTimes, setCurrentTimes] = useState({});
        const [autoRefresh, setAutoRefresh] = useState(true);
        const [nextRefreshTime, setNextRefreshTime] = useState(null);
        const refreshButtonRef = useRef(null);
        const [journey, setJourney] = useState(() => {
            const savedJourney = getCookie('rhineDraftJourney');
            return savedJourney || {start: 914, end: 0}; // Default Tiel -> Maxau
        });

        // Auto-refresh effect
        useEffect(() => {
            if (!autoRefresh) {
                setNextRefreshTime(null);
                return () => {};
            }
            const setupRefresh = () => {
                const nextTime = new Date();
                nextTime.setMinutes(nextTime.getMinutes() + 10);
                setNextRefreshTime(nextTime);

                const intervalId = setInterval(() => {
                    console.log("Auto-refresh triggered at", new Date().toLocaleTimeString());
                    if (refreshButtonRef.current) {
                        refreshButtonRef.current.click();
                    }
                    // Note: nextRefreshTime will be updated inside handleRefresh -> loadWaterLevelData
                }, 10 * 60 * 1000); // 10 minutes

                return () => clearInterval(intervalId);
            };
            const clearRefresh = setupRefresh();
            return clearRefresh; // Cleanup on unmount or when autoRefresh changes
        }, [autoRefresh]); // Rerun only when autoRefresh changes


        // Initialize gauge data and load initial water levels
        useEffect(() => {
            const gauges = [
                 // --- Keep your existing gauge definitions here ---
                {
                    name: 'Konstanz',
                    km: 0,
                    streckenAbschnitt: '0-1',
                    giw: 0,
                    depthAtGiw: 0,
                    officialSafetyMargin: 0,
                    correctionOp: 0,
                    correctionAf: 0,
                    customVuistregel: 0
                },
                {
                    name: 'Iffezheim',
                    km: 334,
                    streckenAbschnitt: '334-384',
                    giw: 0,
                    depthAtGiw: 0,
                    officialSafetyMargin: 0,
                    correctionOp: 10,
                    correctionAf: 20,
                    customVuistregel: 80
                },
                {
                    name: 'Maxau',
                    km: 362,
                    streckenAbschnitt: '335-384',
                    giw: 372,
                    depthAtGiw: 210,
                    officialSafetyMargin: 30,
                    correctionOp: 22,
                    correctionAf: 22
                },
                {
                    name: 'Speyer',
                    km: 400,
                    streckenAbschnitt: '384-410.5',
                    giw: 237,
                    depthAtGiw: 210,
                    officialSafetyMargin: 30,
                    correctionOp: 27,
                    correctionAf: 27
                },
                {
                    name: 'Mannheim',
                    km: 424,
                    streckenAbschnitt: '410.5-431.5',
                    giw: 155,
                    depthAtGiw: 210,
                    officialSafetyMargin: 30,
                    correctionOp: 30,
                    correctionAf: 30
                },
                {
                    name: 'Worms',
                    km: 443,
                    streckenAbschnitt: '431.5-462',
                    giw: 68,
                    depthAtGiw: 210,
                    officialSafetyMargin: 30,
                    correctionOp: 33,
                    correctionAf: 33
                },
                { name: 'Mainz', km: 498, river: 'Rhine', streckenAbschnitt: '462-508', giw: 171, depthAtGiw: 210, officialSafetyMargin: 30, correctionOp: 11, correctionAf: 11 },
                { name: 'Oestrich', km: 518, river: 'Rhine', streckenAbschnitt: '508-528', giw: 92, depthAtGiw: 190, officialSafetyMargin: 30, correctionOp: 42, correctionAf: 32 },
                { name: 'Bingen', km: 528, river: 'Rhine', streckenAbschnitt: '528-540', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 0, customVuistregel: 100 },

                {
                    name: 'Kaub',
                    km: 546,
                    streckenAbschnitt: '541-566',
                    giw: 77,
                    depthAtGiw: 190,
                    officialSafetyMargin: 30,
                    correctionOp: 17,
                    correctionAf: 27
                },
                {
    name: 'Koblenz',
    km: 591,
    streckenAbschnitt: '566-592',
    giw: 77,
    depthAtGiw: 210,
    officialSafetyMargin: 30,
    correctionOp: 27,
    correctionAf: 27
},
{
    name: 'Koblenz (Mosel)',
    apiDataName: 'Koblenz', // Use this to map to the API data
    km: 592,
    streckenAbschnitt: '592-601',
    giw: 77,
    depthAtGiw: 210,
    officialSafetyMargin: 30,
    correctionOp: 57,
    correctionAf: 57
},

                {
                    name: 'Andernach',
                    km: 613,
                    streckenAbschnitt: '601-624',
                    giw: 91,
                    depthAtGiw: 250,
                    officialSafetyMargin: 30,
                    correctionOp: 0,
                    correctionAf: 0
                },
                {
                    name: 'Bonn',
                    km: 655,
                    streckenAbschnitt: '624-660',
                    giw: 142,
                    depthAtGiw: 250,
                    officialSafetyMargin: 30,
                    correctionOp: 0,
                    correctionAf: 0
                },
                {
                    name: 'Köln',
                    km: 688,
                    streckenAbschnitt: '660-710',
                    giw: 139,
                    depthAtGiw: 250,
                    officialSafetyMargin: 30,
                    correctionOp: 0,
                    correctionAf: 9
                },
                {
                    name: 'Düsseldorf',
                    km: 744,
                    streckenAbschnitt: '710-763',
                    giw: 91,
                    depthAtGiw: 250,
                    officialSafetyMargin: 30,
                    correctionOp: 0,
                    correctionAf: 0
                },
                {
                    name: 'Duisburg-Ruhrort',
                    km: 780,
                    streckenAbschnitt: '763-794',
                    giw: 227,
                    depthAtGiw: 280,
                    officialSafetyMargin: 30,
                    correctionOp: 0,
                    correctionAf: 0
                },
                {
                    name: 'Wesel',
                    km: 814,
                    streckenAbschnitt: '794-837',
                    giw: 174,
                    depthAtGiw: 280,
                    officialSafetyMargin: 30,
                    correctionOp: 0,
                    correctionAf: 0
                },
                {
                    name: 'Emmerich',
                    km: 852,
                    streckenAbschnitt: '837-857',
                    giw: 74,
                    depthAtGiw: 280,
                    officialSafetyMargin: 30,
                    correctionOp: 0,
                    correctionAf: 0
                },
                 { // Added Lobith based on API response
                    name: 'Lobith',
                    km: 862, // Approximate KM, adjust if needed
                    streckenAbschnitt: '857-893',
                    giw: 0,
                    depthAtGiw: 0,
                    officialSafetyMargin: 0,
                    correctionOp: 0,
                    correctionAf: 0,
                    customVuistregel: -465
                },

                { name: 'Nijmegen', km: 883, river: 'Waal', streckenAbschnitt: '867.5-893', correctionOp: 0, correctionAf: 0, customVuistregel: -275 },
                { name: 'Tiel', km: 914, river: 'Waal', streckenAbschnitt: '893-930', correctionOp: 0, correctionAf: 0, customVuistregel: 10 }

                // --- End of gauge definitions ---
            ].sort((a, b) => a.km - b.km); // Ensure gauges are sorted by KM

            const defaultCorrections = {upstream: {}, downstream: {}};
            gauges.forEach(gauge => {
                defaultCorrections.upstream[gauge.name] = gauge.correctionOp;
                defaultCorrections.downstream[gauge.name] = gauge.correctionAf;
            });

            const savedCorrections = getCookie('rhineDraftCorrections');
            setGaugeData(gauges);
            setCustomCorrections(savedCorrections || defaultCorrections);

            loadWaterLevelData(); // Load data on initial mount
        }, []); // Empty dependency array ensures this runs only once on mount

        const handleCorrectionChange = (direction, gaugeName, value) => {
            const newCorrections = {
                ...customCorrections,
                [direction]: {
                    ...customCorrections[direction],
                    [gaugeName]: parseInt(value, 10) || 0 // Ensure it's a number, default to 0
                }
            };
            setCustomCorrections(newCorrections);
            setCookie('rhineDraftCorrections', newCorrections);
        };

        // Load water level data from the custom API
        const loadWaterLevelData = useCallback(async () => {
            setDataStatus({ status: 'pending', message: 'Data ophalen van RDD API...' });
            setDataLoaded(false); // Set loading state
            try {
                const processedData = await fetchDataFromCustomAPI();

                // Update state with the processed data
                setWaterLevels(processedData.waterLevels);
                setWaterTrends(processedData.waterTrends);
                setCurrentTimes(processedData.currentTimes);
                setForecasts(processedData.forecasts);
                setLastUpdated(processedData.lastUpdated);

                // Determine forecast dates to display (e.g., next 4 days available in API)
                // Use the dates actually found in the API response, limited to 4
                const availableDates = Array.from(processedData.apiForecastDates).sort();
                setForecastDates(availableDates.slice(0, 4)); // Show max 4 future days with data

                setDataStatus({ status: 'success', message: `Data bijgewerkt: ${processedData.lastUpdated.toLocaleString()}` });
                setDataLoaded(true);

                 // Update next refresh time display if auto-refresh is on
                if (autoRefresh) {
                    const nextTime = new Date();
                    nextTime.setMinutes(nextTime.getMinutes() + 10);
                    setNextRefreshTime(nextTime);
                }


            } catch (error) {
                setDataStatus({ status: 'error', message: `Fout bij ophalen data: ${error.message}` });
                // Clear data on error? Or keep stale data? Keeping stale for now.
                // setWaterLevels({}); setWaterTrends({}); setCurrentTimes({}); setForecasts({}); setForecastDates([]);
                setDataLoaded(false); // Indicate data load failed or incomplete
            }
        }, [autoRefresh]); // Include autoRefresh dependency for updating nextRefreshTime


        // Function to get the best forecast time (closest to current time, preferring same hour)
        function getBestForecastTime(timesObject, referenceTime = null) {
             if (!timesObject || typeof timesObject !== 'object' || Object.keys(timesObject).length === 0) {
                return ''; // No times available
            }
            const times = Object.keys(timesObject); // Get the HH:MM keys

            // Sort times chronologically
            const sortedTimes = [...times].sort((a, b) => {
                const [aH, aM] = a.split(':').map(Number);
                const [bH, bM] = b.split(':').map(Number);
                return (aH * 60 + aM) - (bH * 60 + bM);
            });

            // If no reference time, return the earliest available forecast time for that day
            if (!referenceTime || !referenceTime.includes(':')) {
                return sortedTimes[0];
            }

            // Parse the reference time
            const [refHours, refMinutes] = referenceTime.split(':').map(part => parseInt(part, 10));

            // 1. Try to find an exact hour match
            const exactHourMatches = sortedTimes.filter(time => {
                const [timeHours] = time.split(':').map(part => parseInt(part, 10));
                return timeHours === refHours;
            });
            if (exactHourMatches.length > 0) {
                // If multiple matches for the hour, return the earliest one (e.g., 08:00 if ref is 08:30)
                return exactHourMatches[0];
            }

            // 2. If no exact hour match, find the closest time overall
            let closestTime = sortedTimes[0];
            let minDiff = Infinity;
            const refTotalMinutes = refHours * 60 + refMinutes;

            for (const time of sortedTimes) {
                const [timeHours, timeMinutes] = time.split(':').map(part => parseInt(part, 10));
                const timeTotalMinutes = timeHours * 60 + timeMinutes;
                const diff = Math.abs(timeTotalMinutes - refTotalMinutes);

                if (diff < minDiff) {
                    minDiff = diff;
                    closestTime = time;
                }
            }
            return closestTime;
        }


        const handleRefresh = useCallback(() => {
            console.log("Manual refresh triggered.");
            loadWaterLevelData();
        }, [loadWaterLevelData]); // Depend on the memoized load function

        // Calculate draft for a given gauge and water level
const calculateDraft = (gaugeName, waterLevel, direction = travelDirection) => {
    if (gaugeName === "Konstanz") return "N/A"; // Specific exclusion

    const gauge = gaugeData.find(g => g.name === gaugeName);
    // Ensure gauge exists, waterLevel is a valid number
    if (!gauge || waterLevel === null || waterLevel === undefined || isNaN(Number(waterLevel))) {
         return null; // Return null if data is missing or invalid
    }

    const numericWaterLevel = Number(waterLevel);
    // Use gauge name for custom corrections to be consistent
    const customCorrection = customCorrections[direction]?.[gauge.name] || 0;

    // Use customVuistregel if defined and not null/undefined
    if (gauge.customVuistregel !== undefined && gauge.customVuistregel !== null) {
        return (numericWaterLevel + gauge.customVuistregel + customCorrection).toFixed(0);
    }
    // Otherwise, use GIW calculation if GIW is valid
    else if (gauge.giw !== null && gauge.giw !== undefined && gauge.depthAtGiw !== null && gauge.depthAtGiw !== undefined) {
         // Ensure GIW related values are numbers before calculation
         const giw = Number(gauge.giw);
         const depth = Number(gauge.depthAtGiw);
         const safety = Number(gauge.officialSafetyMargin);
         if (!isNaN(giw) && !isNaN(depth) && !isNaN(safety)) {
            return (numericWaterLevel - giw + depth - safety + customCorrection).toFixed(0);
         } else {
             return null; // Cannot calculate if GIW data is invalid
         }
    }
    // Fallback if neither method applies
    return null;
};


        // Calculate official rule of thumb
        const calculateOfficialRuleOfThumb = (gauge) => {
             // Check if calculation is possible (requires valid GIW and depth)
            if (gauge.giw === null || gauge.giw === undefined || isNaN(Number(gauge.giw)) ||
                gauge.depthAtGiw === null || gauge.depthAtGiw === undefined || isNaN(Number(gauge.depthAtGiw)) ||
                gauge.officialSafetyMargin === null || gauge.officialSafetyMargin === undefined || isNaN(Number(gauge.officialSafetyMargin))) {
                return "N/A";
            }
            // Exclude specific gauges where GIW is not applicable
            if (["Nijmegen", "Tiel", "Bingen", "Iffezheim", "Konstanz", "Lobith", "Pannerdense kop"].includes(gauge.name)) {
                 return "N/A";
            }
            return (Number(gauge.depthAtGiw) - Number(gauge.officialSafetyMargin) - Number(gauge.giw)).toFixed(0);
        };

        // Calculate custom rule of thumb for a specific direction
        const calculateCustomRuleOfThumb = (gauge, direction) => {
            const customCorrection = customCorrections[direction]?.[gauge.name] || 0;

            // Use customVuistregel if defined
            if (gauge.customVuistregel !== undefined && gauge.customVuistregel !== null) {
                return (gauge.customVuistregel + customCorrection).toString();
            }
            // Use GIW calculation if possible and applicable
            else if (gauge.giw !== null && gauge.giw !== undefined && !isNaN(Number(gauge.giw)) &&
                     gauge.depthAtGiw !== null && gauge.depthAtGiw !== undefined && !isNaN(Number(gauge.depthAtGiw)) &&
                     gauge.officialSafetyMargin !== null && gauge.officialSafetyMargin !== undefined && !isNaN(Number(gauge.officialSafetyMargin)) &&
                     !["Nijmegen", "Tiel", "Bingen", "Iffezheim", "Konstanz", "Lobith", "Pannerdense kop"].includes(gauge.name))
            {
                return (Number(gauge.depthAtGiw) - Number(gauge.officialSafetyMargin) + customCorrection - Number(gauge.giw)).toFixed(0);
            }
            // Otherwise return N/A
            return "N/A";
        };


        // Check if a gauge is within the selected journey
        const isInJourney = useCallback((gaugeKm) => {
            if (journey.start === null || journey.end === null) return true; // Show all if journey not fully defined
            const startKm = Number(journey.start);
            const endKm = Number(journey.end);
            return gaugeKm >= Math.min(startKm, endKm) && gaugeKm <= Math.max(startKm, endKm);
        }, [journey]);

        // Determine travel direction based on journey start and end
        useEffect(() => {
            if (journey.start !== null && journey.end !== null) {
                setTravelDirection(Number(journey.start) < Number(journey.end) ? 'downstream' : 'upstream');
            }
        }, [journey]);

        // Calculate forecasted bottlenecks
        const [forecastBottlenecks, setForecastBottlenecks] = useState([]);

        useEffect(() => {
            if (!dataLoaded || Object.keys(forecasts).length === 0 || forecastDates.length === 0) {
                 setForecastBottlenecks([]); // Clear if no data
                 return;
            }

            const newForecastBottlenecks = forecastDates.map(date => {
                let criticalGauge = null;
                let minDraft = Infinity;
                let forecastTimeForMinDraft = '';

                gaugeData.forEach(gauge => {
                    // Check if gauge is in journey and has forecast data for this date
                    if (isInJourney(gauge.km) && forecasts[date]?.[gauge.name]) {
                        const timesObject = forecasts[date][gauge.name];
                        const referenceTime = currentTimes[gauge.name]; // Use current measurement time as reference
                        const selectedTime = getBestForecastTime(timesObject, referenceTime); // Find best matching forecast time

                        if (selectedTime && timesObject[selectedTime] !== undefined) {
                            const forecastValue = timesObject[selectedTime];
                            const draft = parseFloat(calculateDraft(gauge.name, forecastValue, travelDirection));

                            if (!isNaN(draft) && draft < minDraft) {
                                minDraft = draft;
                                criticalGauge = gauge.name;
                                forecastTimeForMinDraft = selectedTime; // Store the time of the bottleneck forecast
                            }
                        }
                    }
                });

                return {
                    date,
                    gauge: criticalGauge,
                    draft: criticalGauge && minDraft !== Infinity ? minDraft.toFixed(0) : 'N/A',
                    time: forecastTimeForMinDraft // Add the time to the bottleneck info
                };
            });

            setForecastBottlenecks(newForecastBottlenecks);
        // Recalculate when relevant data changes
        }, [dataLoaded, forecasts, forecastDates, gaugeData, journey, travelDirection, currentTimes, isInJourney, calculateDraft, customCorrections]);


        // Find the critical gauge (minimum draft) for the current journey
const findCriticalGauge = useCallback(() => {
    if (!dataLoaded || Object.keys(waterLevels).length === 0) return null;

    let criticalGaugeName = null;
    let minDraft = Infinity;

    gaugeData.forEach(gauge => {
        const dataSourceName = gauge.apiDataName || gauge.name;

        if (isInJourney(gauge.km) &&
            waterLevels[dataSourceName] !== null && waterLevels[dataSourceName] !== undefined &&
            currentTimes[dataSourceName] && currentTimes[dataSourceName] !== 'N/A' &&
            currentTimes[dataSourceName] !== 'Invalid Time' && currentTimes[dataSourceName] !== 'Parse Error')
        {
            // Pass the gauge object itself rather than just the name
            // This ensures we use the correct gauge configuration
            const draft = parseFloat(calculateDraft(dataSourceName, waterLevels[dataSourceName], travelDirection));
            if (!isNaN(draft) && draft < minDraft) {
                minDraft = draft;
                criticalGaugeName = dataSourceName;
            }
        }
    });

    return criticalGaugeName;
}, [dataLoaded, waterLevels, currentTimes, gaugeData, isInJourney, travelDirection, calculateDraft, customCorrections]);
        const handleJourneyChange = (type, value) => {
            const newJourney = {
                ...journey,
                [type]: value ? parseInt(value, 10) : null
            };
            setJourney(newJourney);
            setCookie('rhineDraftJourney', newJourney);
        };

        const criticalGaugeName = findCriticalGauge();
        const criticalDraft = criticalGaugeName ? calculateDraft(criticalGaugeName, waterLevels[criticalGaugeName], travelDirection) : 'N/A';

        // --- JSX Rendering ---
        return (
            <div className="container">
                {/* --- Header and Controls Section --- */}
                 <div style={{
                    display: 'flex',
                    flexWrap: 'wrap',
                    justifyContent: 'space-between',
                    alignItems: 'flex-start',
                    padding: '1rem',
                    backgroundColor: '#1e1e1e',
                    gap: '1rem'
                }}>
                    {/* Left side - Header and Controls */}
                    <div style={{flex: '2', minWidth: '400px'}}>
                        <h1 style={{margin: '0 0 1rem 0'}}>Rijn diepgang calculator</h1>

                        <div className="control-group" style={{marginBottom: '1rem'}}>
                            <label>
                                <input
                                    type="checkbox"
                                    checked={autoRefresh}
                                    onChange={(e) => setAutoRefresh(e.target.checked)}
                                />
                                Auto-verversing (10 min)
                            </label>
                            {autoRefresh && nextRefreshTime && (
                                <span style={{marginLeft: '8px', fontSize: '0.9em', color: '#aaa'}}>
                                    Volgende: {nextRefreshTime.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})}
                                </span>
                            )}
                        </div>

                        <div style={{display: 'flex', gap: '1rem', flexWrap: 'wrap', marginBottom: '1rem'}}>
                            <div className="control-group">
                                <label>Begin (km):</label>
                                <select
                                    value={journey.start ?? ''} // Use nullish coalescing for controlled component
                                    onChange={(e) => handleJourneyChange('start', e.target.value)}
                                >
                                    <option value="">Selecteer begin</option>
                                    {/* Sort gauges by KM for dropdown consistency */}
                                    {gaugeData.slice().sort((a, b) => a.km - b.km).map(gauge => (
                                        <option key={`start-${gauge.km}-${gauge.name}`}
                                                value={gauge.km}>{gauge.km} ({gauge.name})</option>
                                    ))}
                                </select>
                            </div>

                            <div className="control-group">
                                <label>Eind (km):</label>
                                <select
                                     value={journey.end ?? ''} // Use nullish coalescing
                                    onChange={(e) => handleJourneyChange('end', e.target.value)}
                                >
                                    <option value="">Selecteer einde</option>
                                     {/* Sort gauges by KM */}
                                    {gaugeData.slice().sort((a, b) => a.km - b.km).map(gauge => (
                                        <option key={`end-${gauge.km}-${gauge.name}`}
                                                value={gauge.km}>{gauge.km} ({gauge.name})</option>
                                    ))}
                                </select>
                            </div>
                        </div>

                        <div className="control-group">
                            <button className="refresh-btn" onClick={handleRefresh} ref={refreshButtonRef} disabled={!dataLoaded && dataStatus.status === 'pending'}>
                                {dataStatus.status === 'pending' ? 'Laden...' : 'Data opnieuw laden'}
                            </button>
                            <div className={`data-status ${dataStatus.status}`}>
                                {dataStatus.message}
                            </div>
                        </div>
                    </div>

                    {/* Right side - Highlight box */}
                    <div className="highlight-box" style={{
                        flex: '1',
                        minWidth: '300px',
                        maxWidth: '500px',
                        alignSelf: 'flex-start',
                        marginTop: '0'
                    }}>
                        <div style={{marginBottom: '8px', fontWeight: 'bold'}}>Kritieke diepgang ({travelDirection === 'downstream' ? 'Af' : 'Op'}):</div>
                        <div style={{marginBottom: '4px'}}>
                            <span style={{display: 'inline-block', width: '70px', paddingRight: '5px'}}>Nu:</span>
                            <span style={{display: 'inline-block', width: '75px'}}>{criticalDraft !== null ? `${criticalDraft} cm` : 'N/A'}</span>
                            ({criticalGaugeName || 'N/A'})
                        </div>
                        {/* Display Forecast Bottlenecks */}
                        {forecastBottlenecks.map((forecast, index) => {
                             // Calculate approximate hours from now
                             const forecastDateTime = new Date(forecast.date);
                             if (forecast.time) {
                                const [hours, minutes] = forecast.time.split(':').map(Number);
                                forecastDateTime.setHours(hours, minutes, 0, 0);
                             } else {
                                 // Default to noon if time is missing, though unlikely with current logic
                                 forecastDateTime.setHours(12, 0, 0, 0);
                             }
                             const now = new Date();
                             const diffHours = Math.round((forecastDateTime - now) / (1000 * 60 * 60));
                             const hourLabel = `${diffHours}h:`;

                            return (
                                <div key={`forecast-bottleneck-${forecast.date}`} style={{marginBottom: '4px'}}>
                                    <span style={{display: 'inline-block', width: '70px', paddingRight: '5px'}}>
                                      {hourLabel}
                                    </span>
                                    <span style={{display: 'inline-block', width: '75px'}}>{forecast.draft !== 'N/A' ? `${forecast.draft} cm` : 'N/A'}</span>
                                     ({forecast.gauge || 'N/A'})
                                     <span style={{fontSize: '0.8em', color: '#555', marginLeft: '5px'}}>
                                         ({forecast.time || '?'})
                                     </span>
                                </div>
                            );
                        })}
                         {dataLoaded && forecastBottlenecks.length === 0 && <div style={{fontSize: '0.9em', color: '#333'}}>Geen prognose data beschikbaar</div>}
                         {!dataLoaded && <div style={{fontSize: '0.9em', color: '#333'}}>Prognoses laden...</div>}
                    </div>
                </div>


                {/* --- Main Content Table --- */}
                <div className="main-content">
                    <div style={{overflowX: 'auto'}}>
                        <table>
                            <thead>
                            <tr>
                                <th rowSpan="2">Strecke</th>
                                <th rowSpan="2">Naam</th>
                                <th rowSpan="2" style={{textAlign: 'right'}}>Waterstand (cm)</th>
                                <th rowSpan="2" style={{textAlign: 'right'}}>Tendens (-24h)</th>
                                <th rowSpan="2" style={{textAlign: 'right'}}>GIW (cm)</th>
                                <th rowSpan="2" style={{textAlign: 'right'}}>TuGIW (cm)</th>
                                <th rowSpan="2" style={{textAlign: 'right'}}>Off. Vuistregel</th>
                                <th colSpan="2">Correctie (cm)</th>
                                <th colSpan="2">Aangep. Vuistregel</th>
                                <th rowSpan="2" style={{textAlign: 'right'}}>
                                    Max. Diepgang (cm)
                                </th>

                                {/* Forecast headers */}
                                {forecastDates.map(date => (
                                    <th key={`forecast-head-${date}`} rowSpan="2" style={{textAlign: 'right'}}>
                                        {new Date(date + 'T12:00:00Z').toLocaleDateString('nl-NL', { weekday: 'short', day: 'numeric', month: 'short' })}
                                    </th>
                                ))}
                                {forecastDates.length === 0 && dataLoaded && <th rowSpan="2">Geen Prognoses</th>}
                            </tr>
                            <tr>
                                <th style={{textAlign: 'right'}}>Op</th>
                                <th style={{textAlign: 'right'}}>Af</th>
                                <th style={{textAlign: 'right'}}>Op</th>
                                <th style={{textAlign: 'right'}}>Af</th>
                            </tr>
                            </thead>
                            <tbody>
                            {/* Filter and map gauge data */}
                           {gaugeData.filter(gauge => isInJourney(gauge.km)).map(gauge => {
                                const dataSourceName = gauge.apiDataName || gauge.name;
                                const isCritical = gauge.name === criticalGaugeName;
                                const currentDraft = calculateDraft(dataSourceName, waterLevels[dataSourceName], travelDirection);

                                return (
                                    <tr key={gauge.name} className={isCritical ? 'critical-row' : ''}>
                                        <td>{gauge.streckenAbschnitt}</td>
                                        <td>
                                            {/* Link logic based on gauge type */}
                                            <a
                                                href={
                                                    ["Nijmegen", "Tiel", "Lobith", "Pannerdense kop"].includes(gauge.name)
                                                        ? `https://waterinfo.rws.nl/publiek/waterhoogte/${gauge.name.replace(/ /g, '%20')}/details` // Basic RWS link guess
                                                        : `https://www.elwis.de/DE/dynamisch/Wasserstaende/Pegelvorhersage:${gauge.name.toUpperCase().replace(/ /g, '_')}` // ELWIS link
                                                }
                                                target="_blank"
                                                rel="noopener noreferrer"
                                                style={{
                                                    color: '#4da6ff',
                                                    textDecoration: 'underline',
                                                    cursor: 'pointer',
                                                    display: 'inline-block',
                                                    whiteSpace: 'nowrap'
                                                }}
                                            >
                                                {gauge.name}
                                            </a>
                                        </td>
                                        {/* Current Water Level */}
                                        <td style={{textAlign: 'right'}}>
                                            {waterLevels[gauge.apiDataName || gauge.name] ?? '-'}
                                            <div style={{
                                                fontSize: '0.8em',
                                                color: '#aaa',
                                                fontWeight: 'normal',
                                                marginTop: '4px'
                                            }}>
                                                {currentTimes[gauge.apiDataName || gauge.name] || 'N/A'}
                                            </div>
                                        </td>
                                        {/* Current Trend */}
                                        <td style={{textAlign: 'right'}}>{waterTrends[gauge.apiDataName || gauge.name] ?? '-'}</td>
                                        {/* GIW */}
                                        <td style={{textAlign: 'right'}}>{calculateOfficialRuleOfThumb(gauge) !== "N/A" ? gauge.giw : 'N/A'}</td>
                                        {/* TuGIW */}
                                        <td style={{textAlign: 'right'}}>{calculateOfficialRuleOfThumb(gauge) !== "N/A" ? gauge.depthAtGiw : 'N/A'}</td>
                                        {/* Official Rule */}
                                        <td style={{textAlign: 'right'}}>{calculateOfficialRuleOfThumb(gauge)}</td>
                                        {/* Correction Inputs */}
                                        <td style={{textAlign: 'right'}}>
                                            <input
                                                type="number"
                                                value={customCorrections.upstream[gauge.name] || 0}
                                                onChange={(e) => handleCorrectionChange('upstream', gauge.name, e.target.value)}
                                                style={{width: '50px', textAlign: 'right'}}
                                            />
                                        </td>
                                        <td style={{textAlign: 'right'}}>
                                            <input
                                                type="number"
                                                value={customCorrections.downstream[gauge.name] || 0}
                                                onChange={(e) => handleCorrectionChange('downstream', gauge.name, e.target.value)}
                                                style={{width: '50px', textAlign: 'right'}}
                                            />
                                        </td>
                                        {/* Custom Rules */}
                                        <td style={{textAlign: 'right'}}>{calculateCustomRuleOfThumb(gauge, 'upstream')}</td>
                                        <td style={{textAlign: 'right'}}>{calculateCustomRuleOfThumb(gauge, 'downstream')}</td>
                                        {/* Current Max Draft */}
                                        <td
                                            style={{textAlign: 'right'}}
                                            className={isCritical ? 'critical-draft' : (currentDraft !== null ? 'draft-highlight' : '')}
                                        >
                                            {currentDraft ?? '-'}
                                        </td>

                                        {/* Forecast columns */}
                                        {forecastDates.map(date => {
                                           const timesObject = forecasts[date]?.[gauge.apiDataName || gauge.name];
const referenceTime = currentTimes[gauge.apiDataName || gauge.name];
                                            const selectedTime = timesObject ? getBestForecastTime(timesObject, referenceTime) : '';
                                            const forecastValue = timesObject && selectedTime ? timesObject[selectedTime] : undefined;
                                            const forecastDraft = forecastValue !== undefined ? calculateDraft(gauge.name, forecastValue, travelDirection) : null;

                                            return (
                                                <td key={`forecast-${gauge.name}-${date}`} style={{textAlign: 'right'}}>
                                                    {forecastDraft !== null ? (
                                                        <>
                                                            {forecastDraft}
                                                            <div style={{fontSize: '0.8em', color: '#aaa'}}>
                                                                {selectedTime || ''}
                                                            </div>
                                                        </>
                                                    ) : '-'}
                                                </td>
                                            );
                                        })}
                                    </tr>
                                );
                            })}
                            {/* Show message if no gauges are in the selected journey */}
                            {gaugeData.filter(gauge => isInJourney(gauge.km)).length === 0 && (
                                <tr>
                                    <td colSpan={11 + forecastDates.length + 2}
                                        style={{textAlign: 'center', fontStyle: 'italic', color: '#aaa'}}>
                                        Geen peilingen geselecteerd voor deze reis. Pas begin/eind aan.
                                    </td>
                                </tr>
                             )}
                            </tbody>
                        </table>
                    </div>
                </div>

                {/* --- Footer --- */}
                <footer>
                    <div>Waterstanden per: {dataLoaded ? lastUpdated.toLocaleString() : 'Laden...'}</div>
                    <div>Rhine Draft Data (RDD) Calculator</div>
                </footer>
            </div>
        );
    }

    ReactDOM.render(<RhineDraftCalculator/>, document.getElementById('root'));
</script>
</body>
</html>