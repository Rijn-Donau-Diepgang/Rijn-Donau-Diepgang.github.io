<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rijn diepgang calculator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.21.2/babel.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            color: white;
            background-color: #121212;
        }

        .container {
            display: flex;
            flex-direction: column;
            width: 100%;
            min-height: 100vh; /* Using min-height from index4 */
        }

        header {
            background-color: #1e1e1e;
            padding: 1rem;
            border-bottom: 1px solid #333;
            flex-shrink: 0;
        }

        .controls-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: flex-start;
            gap: 1rem;
        }

        .controls-left {
            flex: 2;
            min-width: 400px;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .controls-left > div { margin-bottom: 0.5rem; }
        .controls-left > div:last-child { margin-bottom: 0; }

        .controls-right {
            flex: 1;
            min-width: 300px;
            max-width: 500px;
            align-self: flex-start;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        .control-group label { display: flex; align-items: center; gap: 0.3rem; }

        select, input, button {
            background-color: #2a2a2a;
            color: white;
            border: 1px solid #444;
            padding: 0.5rem;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        input[type="number"] { width: 60px; text-align: right; }
        input[type="checkbox"], input[type="radio"] { width: auto; margin-right: 0.3rem; accent-color: #4da6ff; }
        button { cursor: pointer; }

        .tab-controls {
            margin-bottom: 1rem;
            border-bottom: 1px solid #333;
            padding: 1rem 1rem 0.5rem 1rem;
            background-color: #121212;
            flex-shrink: 0;
        }

        .tab-button { background-color: #2a2a2a; border: 1px solid #444; padding: 0.5rem 1rem; margin-right: 0.5rem; border-radius: 4px 4px 0 0; cursor: pointer; }
        .tab-button.active { background-color: #3a3a3a; border-bottom: 1px solid #3a3a3a; font-weight: bold; }
        .tab-button:disabled { background-color: #222; color: #666; cursor: not-allowed; border-color: #333; }

        /* --- Main Content Area --- */
        .main-content {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            padding: 0;
            position: relative; /* Kept from index4 for context */
            /* REMOVED overflow-y: auto from index5 */
        }

        /* --- Table Container (Padding/Layout Only) --- */
        .table-container {
            padding: 0 1rem 1rem 1rem; /* Apply padding here */
            width: 100%;
            box-sizing: border-box;
            /* REMOVED overflow-x from index5's .table-container */
            /* Let content dictate height */
            flex-grow: 1; /* Allow it to take space */
            display: flex; /* Use flex to make wrapper fill it */
        }

        /* --- NEW: Wrapper for Horizontal Scroll (from index4) --- */
        /* NOTE: This element is NOT present in the index5 HTML structure. */
        /* If the sticky header *still* breaks, you might need to re-add */
        /* a div with class="table-scroll-wrapper" around the table */
        /* inside .table-container in the React render function. */
        /* For now, just including the style definition. */
        .table-scroll-wrapper {
             overflow-x: auto; /* Handle horizontal scroll */
             width: 100%;     /* Take full width of the container */
             /* REMOVED overflow-y */
        }

        table {
            width: 100%;
            border-collapse: collapse;
            border-spacing: 0;
            /* Helps with horizontal scroll calculation */
             min-width: max-content; /* Or a specific large pixel value */
        }

       /* --- Sticky Table Header (Relative to VIEWPORT - from index4) --- */
        thead {
            position: sticky;
            top: 0; /* Stick to the viewport top */
            z-index: 10;
            /* REMOVED position: sticky from index5's thead th rule */
        }

        thead th {
            background-color: #1e1e1e; /* Essential for sticky */
            border-bottom: 1px solid #555;
            /* REMOVED position: sticky from index5's thead th */
        }

        /* First row headers */
        thead tr:first-child th {
            /* These stick relative to the thead's top: 0 position */
            top: 0;
            z-index: 11;
            border-top: 1px solid #555;
        }

        /* Second row headers - Adjust top based on first row's height */
        thead tr:nth-child(2) th {
            top: 49px; /* Sticky position below the first row */
            z-index: 11;
             /* Needs background too */
             background-color: #1e1e1e;
        }

        /* --- Table Cells --- */
        th, td {
            padding: 0.6rem 0.5rem;
            text-align: left;
            border-bottom: 1px solid #333;
            white-space: nowrap;
            border-left: 1px solid #333;
            vertical-align: middle;
        }
        th:first-child, td:first-child { border-left: none; }
        th.numeric, td.numeric { text-align: right; }
        th.center, td.center { text-align: center; }

        tr:hover td { background-color: #2a2a2a; }
        .critical-row td { background-color: rgba(255, 0, 0, 0.2) !important; }

        /* --- Highlights --- */
        .critical-draft { font-weight: bold; color: #ff6666; }
        .critical-level { font-weight: bold; color: #ffb3b3; }
        .actual-draft-column { font-weight: bold; }
        .actual-level-column { }
        .critical-actual-draft { font-weight: bold; color: #ff4d4d; }
        .critical-actual-level { font-weight: bold; color: #ff9999; }

        /* --- Forecast & Uncertainty --- */
        .forecast-cell div { line-height: 1.3; }
        .uncertainty-display { font-size: 0.8em; color: #aaa; margin-top: 2px; display: block; }
        .time-display.weekly { font-size: 0.8em; color: #ccc; font-style: italic; } /* Style for weekly indicator (from index5) */


        /* --- Footer & Misc --- */
        footer {
            background-color: #1e1e1e;
            padding: 1rem;
            font-size: 0.875rem;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid #333;
            flex-shrink: 0;
            margin-top: auto; /* Reinstated margin-top from index4 */
        }
        /* ... (Rest of the misc styles from index4, which were mostly the same as index5) ... */
        .highlight-box { background-color: #cc9900; border-radius: 4px; padding: 0.5rem 1rem; color: black; font-weight: bold; border: 1px solid #997300; }
        .highlight-box div { margin-bottom: 4px; }
        .highlight-box span.label { display: inline-block; min-width: 65px; padding-right: 5px; }
        .highlight-box span.value { display: inline-block; min-width: 60px; }
        .highlight-box span.gauge { font-size: 0.9em; color: #333; margin-left: 5px; }
        .highlight-box span.time { font-size: 0.8em; color: #555; margin-left: 5px; }
        .highlight-box .forecast-uncertainty { font-size: 0.85em; color: #333; font-weight: normal; display: block; margin-left: 70px; margin-top: -2px; margin-bottom: 4px; }
        .data-status { padding: 0.5rem; background-color: #333; border-radius: 4px; font-size: 0.875rem; border-left: 5px solid #555; display: inline-block; margin-left: 0.5rem; }
        .data-status.pending { background-color: #444; border-left-color: #aaa; }
        .data-status.success { background-color: #004d00; border-left-color: #00cc66; }
        .data-status.warning { background-color: #665200; border-left-color: #ffcc00; }
        .data-status.error { background-color: #660000; border-left-color: #ff6666; }
        .refresh-btn { background-color: #0066cc; padding: 0.5rem 1rem; cursor: pointer; }
        .refresh-btn:hover { background-color: #0055aa; }
        .refresh-btn:disabled { background-color: #444; cursor: not-allowed; }
        .time-display { font-size: 0.8em; color: #aaa; font-weight: normal; margin-top: 4px; display: block; } /* Keep default time display style */
        .view-toggle-group label { margin-right: 1rem; cursor: pointer; }
        .view-toggle-group input[type="radio"] { margin-right: 0.3rem; }
        .gauge-link { color: #4da6ff; text-decoration: none; }
        .gauge-link:hover { text-decoration: underline; }
    </style>
</head>
<body>
<div id="root"></div>


<script type="text/babel">
    const {useState, useEffect, useCallback, useRef, useMemo} = React;

    // --- Constants ---
    const API_URL = 'https://rdd-backend.vercel.app/api/data';
    const REFRESH_INTERVAL_MS = 10 * 60 * 1000;
    const DEFAULT_DEPTH_SAFETY_MARGIN = 0;
    const MAX_FORECAST_DAYS = 8;
    const MAIN_ROUTE_RIVERS = ['Rijn', 'Waal'];

    // --- Cookie Utilities ---
    function setCookie(name, value, days = 3650) { const date = new Date(); date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000)); const expires = `expires=${date.toUTCString()}`; document.cookie = `${name}=${JSON.stringify(value)};${expires};path=/;SameSite=Lax`; }
    function getCookie(name) { const nameEQ = `${name}=`; const ca = document.cookie.split(';'); for (let i = 0; i < ca.length; i++) { let c = ca[i]; while (c.charAt(0) === ' ') c = c.substring(1, c.length); if (c.indexOf(nameEQ) === 0) { try { return JSON.parse(c.substring(nameEQ.length, c.length)); } catch (e) { console.error("Error parsing cookie:", name, e); return null; } } } return null; }

    // --- API Fetch Function ---
    async function fetchConsolidatedData(force = false) {
    const url = `${API_URL}?t=${Date.now()}`;
    console.log(`Fetching data from: ${url}`);
    try {
        const response = await fetch(url); if (!response.ok) { let errorText = `API request failed: ${response.status}`; try { const errorBody = await response.json(); errorText += ` - ${errorBody.error || JSON.stringify(errorBody)}`; } catch (parseError) { try { const textBody = await response.text(); errorText += ` - ${textBody.substring(0, 200)}`; } catch (readError) {} } throw new Error(errorText); } const data = await response.json(); console.log("API Data Received:", Object.keys(data).length, "gauges"); return data; } catch (error) { console.error("Error fetching consolidated data:", error); throw error; } }

    // --- Helper Functions ---
    function formatTimeDisplay(timeString) {
        if (!timeString || typeof timeString !== 'string') return "N/A";
        if (timeString.length === 5 && timeString.includes(':')) return timeString; // HH:MM
        if (timeString.includes(' ') && timeString.includes(':')) { const timePart = timeString.split(' ')[1]; if (timePart && timePart.length >= 5) return timePart.substring(0,5); }
        try { const date = new Date(timeString); if (!isNaN(date.getTime())) return date.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' }); } catch(e) {}
        return timeString || "N/A";
    }

    function getBestForecastTime(timesObject, referenceTime = null) {
         if (!timesObject || typeof timesObject !== 'object' || Object.keys(timesObject).length === 0) return null;
         const times = Object.keys(timesObject).filter(t => t.match(/^\d{2}:\d{2}$/));
         if (times.length === 0) return null;
         const sortedTimes = [...times].sort();
         if (!referenceTime || !referenceTime.includes(':') || referenceTime === "N/A") return sortedTimes[0];
         const refTimeFormatted = formatTimeDisplay(referenceTime);
         if (refTimeFormatted === "N/A") return sortedTimes[0];
         const [refH] = refTimeFormatted.split(':').map(Number);
         let bestMatch = sortedTimes[0]; let minDiff = Infinity; let exactHourMatch = null;
         for (const time of sortedTimes) { const [h] = time.split(':').map(Number); if (h === refH) { exactHourMatch = time; break; } }
         if (exactHourMatch) return exactHourMatch;
         const refTotalMins = refH * 60 + Number(refTimeFormatted.split(':')[1]);
         for (const time of sortedTimes) { const [h, m] = time.split(':').map(Number); const totalMins = h * 60 + m; const diff = Math.abs(totalMins - refTotalMins); if (diff < minDiff) { minDiff = diff; bestMatch = time; } }
         return bestMatch;
    }

    function getGaugeUrl(gauge) {
        if (!gauge) return '#';
        const gaugeName = gauge.name; const gaugeRiver = gauge.river; const gaugeRegion = gauge.region || gauge.apiData?.region;
        if (gaugeRiver === 'Depth' || (gaugeRegion && gaugeRegion.includes('depths'))) return `https://www.vaarweginformatie.nl/frp/main/#/hydro/mgd`;
        const dutchGaugeUrlCodes = { 'Nijmegen': 'Nijmegen-haven(NIJM)', 'Tiel': 'Tiel-Waal(TIEW)', 'Pannerdense kop': 'Pannerdense-kop(PANN)', 'IJsselkop': 'IJsselkop(IJSS)', 'Doesburg': 'Doesburg-brug(DOES)', 'Deventer': 'Deventer(DEVE)', 'Katerveer': 'Katerveer(KATV)' };
        const germanGaugeIds = { 'Konstanz': '00007', 'Iffezheim': '09137', 'Maxau': '09016', 'Speyer': '09017', 'Mannheim': '09001', 'Worms': '09018' };
        const rlpGaugeUrls = { 'Mainz': 'https://www.hochwasser.rlp.de/flussgebiet/mittelrhein/mainz', 'Bingen': 'https://www.hochwasser.rlp.de/flussgebiet/mittelrhein/bingen', 'Andernach': 'https://www.hochwasser.rlp.de/flussgebiet/mittelrhein/andernach', 'Bonn': 'https://www.hochwasser.rlp.de/flussgebiet/mittelrhein/bonn', 'Wesel': 'https://www.hochwasser.rlp.de/flussgebiet/niederrhein/wesel' };
        if (rlpGaugeUrls[gaugeName]) return rlpGaugeUrls[gaugeName];
        if (gaugeName === 'Lobith') return 'https://www.rijkswaterstaat.nl/water/waterdata-en-waterberichtgeving/waterdata/lobith-waterstanden-en-afvoeren';
        if (germanGaugeIds[gaugeName]) return `https://www.hvz.baden-wuerttemberg.de/pegel.html?id=${germanGaugeIds[gaugeName]}`;
        if (dutchGaugeUrlCodes[gaugeName] || (gaugeRegion && gaugeRegion.includes('dutch'))) { const urlCode = dutchGaugeUrlCodes[gaugeName] || encodeURIComponent(gaugeName); return `https://waterinfo.rws.nl/publiek/waterhoogte/${urlCode}/details`; }
        const elwisNameBase = gauge.apiDataName || gauge.name || ''; const elwisName = elwisNameBase.toUpperCase().replace(/ /g, '_').replace(/Ü/g, 'UE').replace(/Ö/g, 'OE').replace(/Ä/g, 'AE');
        if (elwisName) return `https://www.elwis.de/DE/dynamisch/Wasserstaende/Pegelvorhersage:${elwisName}`;
        return '#';
    }

    function diffDays(dateStr1, dateStr2) {
        try {
            const date1 = new Date(Date.UTC(parseInt(dateStr1.substring(0, 4)), parseInt(dateStr1.substring(5, 7)) - 1, parseInt(dateStr1.substring(8, 10)), 12, 0, 0));
            const date2 = new Date(Date.UTC(parseInt(dateStr2.substring(0, 4)), parseInt(dateStr2.substring(5, 7)) - 1, parseInt(dateStr2.substring(8, 10)), 12, 0, 0));
            if (isNaN(date1.getTime()) || isNaN(date2.getTime())) return NaN;
            return Math.round((date2 - date1) / (1000 * 60 * 60 * 24));
        } catch (e) {
            console.error("Error calculating date difference:", dateStr1, dateStr2, e);
            return NaN;
        }
    }

    // --- React Component ---
    function RhineDraftCalculator() {
        // State
        const [allGaugeStaticData, setAllGaugeStaticData] = useState([]);
        const [gaugeApiData, setGaugeApiData] = useState({});
        const [customCorrections, setCustomCorrections] = useState({ upstream: {}, downstream: {} });
        const [forecastDates, setForecastDates] = useState([]);
        const [dataStatus, setDataStatus] = useState({ status: 'pending', message: 'Initializing...' });
        const [lastUpdated, setLastUpdated] = useState(null);
        const [travelDirection, setTravelDirection] = useState('downstream');
        const [autoRefresh, setAutoRefresh] = useState(true);
        const [nextRefreshTime, setNextRefreshTime] = useState(null);
        const refreshButtonRef = useRef(null);
        const [journey, setJourney] = useState(() => getCookie('rhineDraftJourney') || { start: 914, end: 362 });
        const [activeTab, setActiveTab] = useState('route');
        const [displayMode, setDisplayMode] = useState('draft');
        const [showUncertainty, setShowUncertainty] = useState(false);

        // --- Effects ---
        useEffect(() => { // Static data load effect...
            setDataStatus({ status: 'pending', message: 'Loading static gauge definitions...' });
             const combinedStaticList = [ /* ... Static List ... */
                { name: 'Konstanz', km: 0, river: 'Rijn', streckenAbschnitt: '0-1', giw: 0, depthAtGiw: 0, officialSafetyMargin: 0, correctionOp: 0, correctionAf: 0 },
                { name: 'Iffezheim', km: 334, river: 'Rijn', streckenAbschnitt: '334-384', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 10, correctionAf: 20, customVuistregel: 80 },
                { name: 'Maxau', km: 362, river: 'Rijn', streckenAbschnitt: '335-384', giw: 372, depthAtGiw: 210, officialSafetyMargin: 30, correctionOp: 12, correctionAf: 12 },
                { name: 'Speyer', km: 400, river: 'Rijn', streckenAbschnitt: '384-410.5', giw: 237, depthAtGiw: 210, officialSafetyMargin: 30, correctionOp: 27, correctionAf: 27 },
                { name: 'Mannheim', km: 424, river: 'Rijn', streckenAbschnitt: '410.5-431.5', giw: 155, depthAtGiw: 210, officialSafetyMargin: 30, correctionOp: 30, correctionAf: 30 },
                { name: 'Worms', km: 443, river: 'Rijn', streckenAbschnitt: '431.5-462', giw: 68, depthAtGiw: 210, officialSafetyMargin: 30, correctionOp: 33, correctionAf: 33 },
                { name: 'Mainz', km: 498, river: 'Rijn', streckenAbschnitt: '462-508', giw: 171, depthAtGiw: 210, officialSafetyMargin: 30, correctionOp: 11, correctionAf: 11 },
                { name: 'Oestrich', km: 518, river: 'Rijn', streckenAbschnitt: '508-528', giw: 92, depthAtGiw: 190, officialSafetyMargin: 30, correctionOp: 42, correctionAf: 42 },
                { name: 'Bingen', km: 528, river: 'Rijn', streckenAbschnitt: '528-540', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 0, customVuistregel: 100 },
                { name: 'Kaub', km: 546, river: 'Rijn', streckenAbschnitt: '541-566', giw: 77, depthAtGiw: 190, officialSafetyMargin: 30, correctionOp: 17, correctionAf: 27 },
                { name: 'Koblenz', km: 591, river: 'Rijn', streckenAbschnitt: '566-592', giw: 77, depthAtGiw: 210, officialSafetyMargin: 30, correctionOp: 27, correctionAf: 27 },
                { name: 'Koblenz (Mosel)', apiDataName: 'Koblenz', km: 592, river: 'Rijn', streckenAbschnitt: '592-601', giw: 77, depthAtGiw: 250, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Andernach', km: 613, river: 'Rijn', streckenAbschnitt: '601-624', giw: 91, depthAtGiw: 250, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Bonn', km: 655, river: 'Rijn', streckenAbschnitt: '624-660', giw: 142, depthAtGiw: 250, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Köln', km: 688, river: 'Rijn', streckenAbschnitt: '660-710', giw: 139, depthAtGiw: 250, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 9 },
                { name: 'Düsseldorf', km: 744, river: 'Rijn', streckenAbschnitt: '710-763', giw: 91, depthAtGiw: 250, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Duisburg-Ruhrort', km: 780, river: 'Rijn', streckenAbschnitt: '763-794', giw: 227, depthAtGiw: 280, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Wesel', km: 814, river: 'Rijn', streckenAbschnitt: '794-837', giw: 174, depthAtGiw: 280, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Emmerich', km: 852, river: 'Rijn', streckenAbschnitt: '837-857', giw: 74, depthAtGiw: 280, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Lobith', km: 862, river: 'Rijn', streckenAbschnitt: '857-867.5', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 0, customVuistregel: -478 },
                { name: 'Nijmegen', km: 883, river: 'Waal', streckenAbschnitt: '867.5-893', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 0, customVuistregel: -260 },
                { name: 'Tiel', km: 914, river: 'Waal', streckenAbschnitt: '893-930', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 0, customVuistregel: 10 },
                { name: 'Pannerdense kop', km: 867, river: 'Pannerdens Kanaal', streckenAbschnitt: 'PK 867.5-878.6', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 0, customVuistregel: -485 },
                { name: 'IJsselkop', km: 878, river: 'IJssel', streckenAbschnitt: 'IJ 867-903', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 10, correctionAf: 20, customVuistregel: -480 },
                { name: 'Doesburg', km: 903, river: 'IJssel', streckenAbschnitt: 'IJ 903-931', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 10, correctionAf: 20, customVuistregel: -200 },
                { name: 'Deventer', km: 931, river: 'IJssel', streckenAbschnitt: 'IJ 931-981', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 10, customVuistregel: 90 },
                { name: 'Katerveer', km: 981, river: 'IJssel', streckenAbschnitt: 'IJ 981-1005', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 10, customVuistregel: 270 },
                { name: 'Spijk - Woudrichem', km: 931, river: 'Depth', streckenAbschnitt: 'Waal km 930-951', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'Millingen tot Maas-Waalkanaal', km: 867, river: 'Depth', streckenAbschnitt: 'Waal (deeltraject)', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'Maas-Waalkanaal tot Amsterdam-Rijnkanaal', km: 895, river: 'Depth', streckenAbschnitt: 'Waal (deeltraject)', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'Amsterdam-Rijnkanaal tot Loevestein', km: 925, river: 'Depth', streckenAbschnitt: 'Waal (deeltraject)', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'Pannerdensche Kop - IJsselkop', km: 878, river: 'Depth', streckenAbschnitt: 'Pannerdensch Kanaal', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'IJsselkop - Driel', km: 884, river: 'Depth', streckenAbschnitt: 'Nederrijn km 878-884', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'Driel - Heteren', km: 888, river: 'Depth', streckenAbschnitt: 'Nederrijn km 884-888', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'Heteren - A\'dam-Rijnkanaal', km: 905, river: 'Depth', streckenAbschnitt: 'Nederrijn km 888-905', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'A\'dam-Rijnkanaal - Hagestein', km: 922, river: 'Depth', streckenAbschnitt: 'Lek km 905-922', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'IJsselkop - Twenthekanaal', km: 921, river: 'Depth', streckenAbschnitt: 'IJssel km 878-921', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'Uitvaartdiepte Oostsluis Weurt', km: 886, river: 'Depth', streckenAbschnitt: 'Oostsluis Weurt', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'Uitvaartdiepte Westsluis Weurt', km: 886.1, river: 'Depth', streckenAbschnitt: 'Westsluis Weurt', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 }
             ];
             const processedStaticData = combinedStaticList
                 .map(g => ({ ...g, giw: g.giw ?? 'N/A', depthAtGiw: g.depthAtGiw ?? 'N/A', officialSafetyMargin: g.officialSafetyMargin === undefined ? 'N/A' : g.officialSafetyMargin, isMainRoute: MAIN_ROUTE_RIVERS.includes(g.river) }))
                 .sort((a, b) => { const riverOrder = { 'Rijn': 1, 'Pannerdens Kanaal': 2, 'Waal': 3, 'Nederrijn': 4, 'Lek': 5, 'IJssel': 6, 'Depth': 7, 'Unknown': 99 }; const riverA = a.river || 'Unknown'; const riverB = b.river || 'Unknown'; const orderA = riverOrder[riverA] || 99; const orderB = riverOrder[riverB] || 99; if (orderA !== orderB) return orderA - orderB; const kmA = a.km === undefined || a.km === null ? Infinity : a.km; const kmB = b.km === undefined || b.km === null ? Infinity : b.km; return kmA - kmB; });
             setAllGaugeStaticData(processedStaticData);
             const defaultCorrections = { upstream: {}, downstream: {} };
             processedStaticData.forEach(gauge => { defaultCorrections.upstream[gauge.name] = gauge.correctionOp === undefined ? 0 : gauge.correctionOp; defaultCorrections.downstream[gauge.name] = gauge.correctionAf === undefined ? 0 : gauge.correctionAf; });
             const savedCorrections = getCookie('rhineDraftCorrections');
             const mergedCorrections = { upstream: { ...defaultCorrections.upstream, ...(savedCorrections?.upstream || {}) }, downstream: { ...defaultCorrections.downstream, ...(savedCorrections?.downstream || {}) } };
             setCustomCorrections(mergedCorrections);
             setDataStatus({ status: 'success', message: 'Static data loaded.' });
        }, []);

        const loadGaugeApiData = useCallback(async (force = false) => { // API load effect...
            setDataStatus({ status: 'pending', message: 'Data ophalen van API...' });
            if (refreshButtonRef.current) refreshButtonRef.current.disabled = true;
            try {
                const apiResponse = await fetchConsolidatedData(force);
                const newApiData = {}; const allDatesInForecast = new Set();
                let successfulUpdates = 0; let apiGaugeCount = 0; let warningMessages = []; let errorMessages = [];
                let overallStatus = 'success'; let latestApiTimestamp = 0;
                const todayDate = new Date();
                const nlYear = todayDate.toLocaleDateString('en-CA', { year: 'numeric', timeZone: 'Europe/Amsterdam' });
                const nlMonth = todayDate.toLocaleDateString('en-CA', { month: '2-digit', timeZone: 'Europe/Amsterdam' });
                const nlDay = todayDate.toLocaleDateString('en-CA', { day: '2-digit', timeZone: 'Europe/Amsterdam' });
                const todayStr = `${nlYear}-${nlMonth}-${nlDay}`;

                apiGaugeCount = Object.keys(apiResponse).length;
                Object.entries(apiResponse).forEach(([apiGaugeName, data]) => { // Status processing...
                    if (data.status === 'OK' || data.status === 'WARNING') successfulUpdates++;
                    else if (data.status?.startsWith('CACHED')) { successfulUpdates++; if (data.status !== 'CACHED' && data.status !== 'CACHED_UNCHANGED') { warningMessages.push(`${apiGaugeName}: ${data.status} (${data.error || 'stale/partial'})`); if (overallStatus !== 'error') overallStatus = 'warning'; } }
                    else { errorMessages.push(`${apiGaugeName}: ${data.error || data.status || 'Unknown error'}`); overallStatus = 'error'; }
                    if (data.error && data.status !== 'ERROR' && !data.status?.startsWith('CACHED')) { warningMessages.push(`${apiGaugeName}: ${data.error}`); if (overallStatus !== 'error') overallStatus = 'warning'; }
                    if (data.lastUpdated) { try { const t = new Date(data.lastUpdated).getTime(); if (!isNaN(t) && t > latestApiTimestamp) latestApiTimestamp = t; } catch (e) {} }
                });

                allGaugeStaticData.forEach(staticGauge => { // Data mapping...
                    const apiLookupKey = staticGauge.apiDataName || staticGauge.name;
                    const rawData = apiResponse[apiLookupKey];
                    const displayKey = staticGauge.name;
                    if (rawData) {
                        const processedForecasts = {};
                        if (rawData.forecasts) {
                             Object.entries(rawData.forecasts).forEach(([dateStr, timeEntries]) => {
                                if (dateStr >= todayStr) {
                                    const validTimeEntries = {};
                                    Object.entries(timeEntries).forEach(([timeStr, forecastData]) => {
                                        if (timeStr.match(/^\d{2}:\d{2}$/) && forecastData && forecastData.value !== undefined && forecastData.value !== null) {
                                             validTimeEntries[timeStr] = { value: forecastData.value, low_80: forecastData.low_80 ?? null, high_80: forecastData.high_80 ?? null };
                                        }
                                    });
                                    if (Object.keys(validTimeEntries).length > 0) {
                                        processedForecasts[dateStr] = validTimeEntries;
                                        allDatesInForecast.add(dateStr);
                                    }
                                }
                            });
                        }
                        newApiData[displayKey] = {
                            apiName: apiLookupKey, currentLevel: rawData.currentLevel ?? null, currentTime: formatTimeDisplay(rawData.currentTime || rawData.lastUpdated),
                            currentTrend: rawData.currentTrend ?? null,
                            forecasts: processedForecasts,
                            weeklyForecasts: rawData.weeklyForecasts ?? null,
                            status: rawData.status || 'ERROR', error: rawData.error || null,
                            river: staticGauge.river || rawData.river || 'Unknown', region: staticGauge.region || rawData.region || 'unknown', source: rawData.source || { measurement: null, forecast: null },
                            lastUpdated: rawData.lastUpdated || null, giw: staticGauge.giw, depthAtGiw: staticGauge.depthAtGiw,
                            officialSafetyMargin: staticGauge.officialSafetyMargin, customVuistregel: staticGauge.customVuistregel
                        };
                    }
                });

                setGaugeApiData(newApiData);
                const futureDates = [];
                let currentDate = new Date(todayStr + 'T12:00:00Z');
                for (let i = 0; i < MAX_FORECAST_DAYS; i++) {
                     const year = currentDate.getUTCFullYear();
                     const month = String(currentDate.getUTCMonth() + 1).padStart(2, '0');
                     const day = String(currentDate.getUTCDate()).padStart(2, '0');
                     futureDates.push(`${year}-${month}-${day}`);
                     currentDate.setUTCDate(currentDate.getUTCDate() + 1);
                }
                setForecastDates(futureDates);

                setLastUpdated(latestApiTimestamp > 0 ? new Date(latestApiTimestamp) : new Date());
                let finalMessage = `Data bijgewerkt (${successfulUpdates}/${apiGaugeCount} API bronnen)`;
                if (overallStatus === 'error') finalMessage = `Fout bij bijwerken (${errorMessages.length} mislukt). ${errorMessages.length > 0 ? `Eerste: ${errorMessages[0]}` : ''}`;
                else if (overallStatus === 'warning') finalMessage = `Deels bijgewerkt (${warningMessages.length} waarschuwingen). ${warningMessages.length > 0 ? `Eerste: ${warningMessages[0]}` : ''}`;
                setDataStatus({ status: overallStatus, message: finalMessage });

            } catch (error) { console.error("Failed to load or process API data:", error); setDataStatus({ status: 'error', message: `Fout bij laden: ${error.message}` }); setLastUpdated(new Date());
            } finally { if (refreshButtonRef.current) refreshButtonRef.current.disabled = false; if (autoRefresh) { const nextTime = new Date(Date.now() + REFRESH_INTERVAL_MS); setNextRefreshTime(nextTime); } else { setNextRefreshTime(null); } }
        }, [allGaugeStaticData, autoRefresh]);

       useEffect(() => { if (allGaugeStaticData.length > 0) loadGaugeApiData(false); }, [allGaugeStaticData, loadGaugeApiData]);

       useEffect(() => { // Auto-refresh timer
            if (!autoRefresh) {
                setNextRefreshTime(null);
                return () => {};
            }
            let timerId;
            const setTimer = () => {
                const nextTime = new Date(Date.now() + REFRESH_INTERVAL_MS);
                setNextRefreshTime(nextTime);
                timerId = setTimeout(() => {
                console.log("Auto-refresh triggered at", new Date().toLocaleTimeString());
                if (refreshButtonRef.current && !refreshButtonRef.current.disabled) {
                    refreshHandlerRef.current?.(false);
                } else {
                    console.log("Auto-refresh skipped, setting timer again.");
                    setTimer();
                }
                }, REFRESH_INTERVAL_MS);
            };
            setTimer();
            return () => clearTimeout(timerId);
        }, [autoRefresh]);


        // --- Event Handlers ---
        const handleCorrectionChange = (direction, gaugeName, value) => { const parsedValue = parseInt(value, 10); const newValue = value === '' ? 0 : (isNaN(parsedValue) ? (customCorrections[direction][gaugeName] || 0) : parsedValue); const newCorrections = { ...customCorrections, [direction]: { ...customCorrections[direction], [gaugeName]: newValue } }; setCustomCorrections(newCorrections); setCookie('rhineDraftCorrections', newCorrections); };
        const handleJourneyChange = (type, value) => { const newJourney = { ...journey, [type]: value ? parseInt(value, 10) : null }; setJourney(newJourney); setCookie('rhineDraftJourney', newJourney); };
        const handleRefresh = useCallback((force = true) => { console.log("Manual refresh triggered.", `Force: ${force}`); loadGaugeApiData(force); }, [loadGaugeApiData]);
        const refreshHandlerRef = useRef();
        useEffect(() => { refreshHandlerRef.current = handleRefresh; }, [handleRefresh]);
        const handleTabChange = (tab) => { setActiveTab(tab); };
        const handleDisplayModeChange = (event) => { setDisplayMode(event.target.value); };
        const handleUncertaintyToggle = (event) => { setShowUncertainty(event.target.checked); };

        // --- Calculations & Derived State ---
        useEffect(() => { if (journey.start !== null && journey.end !== null) { setTravelDirection(journey.start < journey.end ? 'downstream' : 'upstream'); } }, [journey]);
        const isInJourneyKmRange = useCallback((gaugeKm) => { if (journey.start === null || journey.end === null || gaugeKm === null || gaugeKm === undefined) return false; const startKm = Number(journey.start); const endKm = Number(journey.end); if (isNaN(startKm) || isNaN(endKm)) return false; return gaugeKm >= Math.min(startKm, endKm) && gaugeKm <= Math.max(startKm, endKm); }, [journey]);
        const displayedGaugeData = useMemo(() => { const data = allGaugeStaticData.filter(staticGauge => { const apiData = gaugeApiData[staticGauge.name]; const hasApiData = !!apiData && (apiData.status === 'OK' || apiData.status?.startsWith('CACHED') || apiData.status === 'WARNING'); if (activeTab === 'route') return staticGauge.isMainRoute && isInJourneyKmRange(staticGauge.km) && hasApiData; else return hasApiData; }).map(staticGauge => ({ ...staticGauge, apiData: gaugeApiData[staticGauge.name] })); return data; }, [allGaugeStaticData, gaugeApiData, activeTab, isInJourneyKmRange]);
        const calculateDraft = useCallback((gauge, waterLevel) => { if (!gauge || waterLevel === null || waterLevel === undefined || isNaN(Number(waterLevel))) return null; if (gauge.name === "Konstanz") return null; const numericLevel = Number(waterLevel); const correction = customCorrections[travelDirection]?.[gauge.name] || 0; if (gauge.river === 'Depth') { const safetyMargin = gauge.officialSafetyMargin !== 'N/A' ? Number(gauge.officialSafetyMargin) : DEFAULT_DEPTH_SAFETY_MARGIN; if (isNaN(safetyMargin)) return null; return (numericLevel - safetyMargin + correction); } else if (gauge.customVuistregel !== undefined && gauge.customVuistregel !== null && !isNaN(Number(gauge.customVuistregel))) return (numericLevel + Number(gauge.customVuistregel) + correction); else if (['Rijn', 'IJssel'].includes(gauge.river) && gauge.giw !== 'N/A' && gauge.depthAtGiw !== 'N/A' && gauge.officialSafetyMargin !== 'N/A') { const giw = Number(gauge.giw); const depth = Number(gauge.depthAtGiw); const safety = Number(gauge.officialSafetyMargin); if (!isNaN(giw) && !isNaN(depth) && !isNaN(safety)) return (numericLevel - giw + depth - safety + correction); else return null; } return null; }, [customCorrections, travelDirection]);
        const calculateOfficialRuleOfThumb = useCallback((gauge) => { if (gauge.river === 'Depth' || gauge.giw === 'N/A' || gauge.depthAtGiw === 'N/A' || gauge.officialSafetyMargin === 'N/A') return "N/A"; const giw = Number(gauge.giw); const depth = Number(gauge.depthAtGiw); const safety = Number(gauge.officialSafetyMargin); if (isNaN(giw) || isNaN(depth) || isNaN(safety)) return "N/A"; if (["Nijmegen", "Tiel", "Bingen", "Iffezheim", "Konstanz", "Lobith", "Pannerdense kop", "IJsselkop", "Doesburg", "Deventer", "Katerveer"].includes(gauge.name)) return "N/A"; return (depth - safety - giw).toFixed(0); }, []);
        const calculateCustomRuleOfThumbDisplay = useCallback((gauge, direction) => { if (!gauge || gauge.river === 'Depth' || gauge.name === "Konstanz") return "N/A"; const correction = customCorrections[direction]?.[gauge.name] || 0; let baseRule = null; if (gauge.customVuistregel !== undefined && gauge.customVuistregel !== null && !isNaN(Number(gauge.customVuistregel))) baseRule = Number(gauge.customVuistregel); else { const officialRule = calculateOfficialRuleOfThumb(gauge); if (officialRule !== "N/A") baseRule = Number(officialRule); } if (baseRule !== null) return (baseRule + correction).toFixed(0); return "N/A"; }, [customCorrections, calculateOfficialRuleOfThumb]);
        const findCriticalGauge = useCallback(() => { if (activeTab !== 'route' || displayedGaugeData.length === 0) return { name: null, draft: null, apiData: null }; let criticalGaugeName = null; let minDraft = Infinity; let criticalApiData = null; displayedGaugeData.forEach(gauge => { const apiData = gauge.apiData; if (apiData && apiData.currentLevel !== null) { const draft = calculateDraft(gauge, apiData.currentLevel); if (draft !== null && !isNaN(Number(draft))) { const numericDraft = Number(draft); if (numericDraft < minDraft) { minDraft = numericDraft; criticalGaugeName = gauge.name; criticalApiData = apiData; } } } }); return { name: criticalGaugeName, draft: minDraft === Infinity ? null : minDraft, apiData: criticalApiData }; }, [activeTab, displayedGaugeData, calculateDraft]);
        const { name: criticalGaugeName, draft: criticalDraftValue, apiData: criticalApiDataForHighlight } = findCriticalGauge();
        const todayStr = useMemo(() => { const todayDate = new Date(); const nlYear = todayDate.toLocaleDateString('en-CA', { year: 'numeric', timeZone: 'Europe/Amsterdam' }); const nlMonth = todayDate.toLocaleDateString('en-CA', { month: '2-digit', timeZone: 'Europe/Amsterdam' }); const nlDay = todayDate.toLocaleDateString('en-CA', { day: '2-digit', timeZone: 'Europe/Amsterdam' }); return `${nlYear}-${nlMonth}-${nlDay}`; }, []);

        // --- Forecast Bottleneck Calculation (including weekly uncertainty) ---
        const forecastBottlenecks = useMemo(() => {
            if (activeTab !== 'route' || forecastDates.length === 0 || displayedGaugeData.length === 0) return [];
            return forecastDates.map(dateStr => {
                let criticalGauge = null; let minDraft = Infinity; let forecastTime = null;
                let forecastLevelForCrit = null; let forecastSlotForCrit = null;
                let weeklyForecastSlotForCrit = null; let valueSource = null; let uncertaintyText = '';
                displayedGaugeData.forEach(gauge => {
                    const apiData = gauge.apiData; let potentialDraft = null; let currentForecastLevel = null;
                    let currentForecastTime = null; let currentForecastSlot = null;
                    let currentWeeklyForecastSlot = null; let currentValueSource = null;
                    const forecastsForDate = apiData?.forecasts?.[dateStr];
                    if (forecastsForDate && Object.keys(forecastsForDate).length > 0) {
                        const selectedTime = getBestForecastTime(forecastsForDate, apiData?.currentTime);
                        const dailySlot = selectedTime ? forecastsForDate[selectedTime] : null;
                        if (dailySlot && dailySlot.value !== undefined && dailySlot.value !== null) {
                            currentForecastLevel = dailySlot.value; currentForecastTime = selectedTime;
                            currentForecastSlot = dailySlot; currentValueSource = 'daily';
                            potentialDraft = calculateDraft(gauge, currentForecastLevel);
                        }
                    }
                    if (potentialDraft === null && Array.isArray(apiData?.weeklyForecasts) && apiData.weeklyForecasts.length > 0) {
                         const targetDate = new Date(dateStr + 'T12:00:00Z');
                         for (const weeklyForecast of apiData.weeklyForecasts) {
                            if (weeklyForecast.weekRange && weeklyForecast.median !== null) {
                                try {
                                    const [startStr, endStr] = weeklyForecast.weekRange.split('-');
                                    const [startDay, startMonth, startYear] = startStr.split('.');
                                    const [endDay, endMonth, endYear] = endStr.split('.');
                                    const startDate = new Date(Date.UTC(startYear, startMonth - 1, startDay, 0, 0, 0));
                                    const endDate = new Date(Date.UTC(endYear, endMonth - 1, endDay, 23, 59, 59));
                                    if (!isNaN(startDate.getTime()) && !isNaN(endDate.getTime()) && targetDate >= startDate && targetDate <= endDate) {
                                        currentForecastLevel = weeklyForecast.median; currentForecastTime = "(BfG6W)";
                                        currentForecastSlot = null; currentWeeklyForecastSlot = weeklyForecast;
                                        currentValueSource = 'weekly';
                                        potentialDraft = calculateDraft(gauge, currentForecastLevel); break;
                                    }
                                } catch (e) { console.warn(`Error parsing weekRange in bottleneck calc "${weeklyForecast.weekRange}" for gauge ${gauge.name}:`, e); }
                            }
                        }
                    }
                    if (potentialDraft !== null && !isNaN(Number(potentialDraft))) {
                        const numericDraft = Number(potentialDraft);
                        if (numericDraft < minDraft) {
                            minDraft = numericDraft; criticalGauge = gauge; forecastTime = currentForecastTime;
                            forecastLevelForCrit = currentForecastLevel; forecastSlotForCrit = currentForecastSlot;
                            weeklyForecastSlotForCrit = currentWeeklyForecastSlot; valueSource = currentValueSource;
                        }
                    }
                });
                if (criticalGauge && showUncertainty) {
                    if (valueSource === 'daily' && forecastSlotForCrit) {
                        if (forecastSlotForCrit.low_80 !== null && forecastSlotForCrit.high_80 !== null) {
                            const draftLow = calculateDraft(criticalGauge, forecastSlotForCrit.low_80); const draftHigh = calculateDraft(criticalGauge, forecastSlotForCrit.high_80);
                            if (draftLow !== null && draftHigh !== null && !isNaN(draftLow) && !isNaN(draftHigh)) { uncertaintyText = `(${Math.min(draftLow, draftHigh).toFixed(0)} - ${Math.max(draftLow, draftHigh).toFixed(0)} cm)`; }
                            else { uncertaintyText = '(Bereik N/A)'; }
                        } else if (forecastLevelForCrit !== null) {
                            const daysAhead = diffDays(todayStr, dateStr);
                            if (!isNaN(daysAhead) && daysAhead > 0) {
                                const elwisUncertainty = daysAhead <= 2 ? 10 : 20; const draftLow = calculateDraft(criticalGauge, forecastLevelForCrit - elwisUncertainty); const draftHigh = calculateDraft(criticalGauge, forecastLevelForCrit + elwisUncertainty);
                                if (draftLow !== null && draftHigh !== null && !isNaN(draftLow) && !isNaN(draftHigh)) { uncertaintyText = `(${Math.min(draftLow, draftHigh).toFixed(0)} - ${Math.max(draftLow, draftHigh).toFixed(0)} cm*)`; }
                                else { uncertaintyText = `(±${elwisUncertainty} cm)`; }
                            }
                        }
                    } else if (valueSource === 'weekly' && weeklyForecastSlotForCrit) {
                         if (weeklyForecastSlotForCrit.low_90 !== null && weeklyForecastSlotForCrit.high_90 !== null) {
                             const draftLow = calculateDraft(criticalGauge, weeklyForecastSlotForCrit.low_90); const draftHigh = calculateDraft(criticalGauge, weeklyForecastSlotForCrit.high_90);
                             if (draftLow !== null && draftHigh !== null && !isNaN(draftLow) && !isNaN(draftHigh)) { uncertaintyText = `(${Math.min(draftLow, draftHigh).toFixed(0)} - ${Math.max(draftLow, draftHigh).toFixed(0)} cm)`; }
                             else { uncertaintyText = '(Bereik N/A)'; }
                         }
                    }
                }
                return { date: dateStr, gauge: criticalGauge?.name || null, draft: criticalGauge && minDraft !== Infinity ? minDraft.toFixed(0) : 'N/A', time: forecastTime, uncertainty: uncertaintyText };
            });
        }, [activeTab, forecastDates, displayedGaugeData, calculateDraft, showUncertainty, todayStr, getBestForecastTime]);


        // --- Render ---
        return (
            <div className="container">
                {/* Header */}
                <header className="controls-area">
                     <div className="controls-left">
                         <h1 style={{ margin: '0 0 0.5rem 0' }}>Rijn Diepgang Calculator</h1>
                         <div className="control-group"> <label><input type="checkbox" checked={autoRefresh} onChange={(e) => setAutoRefresh(e.target.checked)} />Auto-verversing ({REFRESH_INTERVAL_MS / 60000} min)</label> {autoRefresh && nextRefreshTime && <span style={{ marginLeft: '8px', fontSize: '0.9em', color: '#aaa' }}>Volgende: {nextRefreshTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>} </div>
                         <div className="control-group"> <label>Traject (Rijn/Waal):</label> <select value={journey.start ?? ''} onChange={(e) => handleJourneyChange('start', e.target.value)}> <option value="">Selecteer begin</option> {allGaugeStaticData.filter(g => g.isMainRoute).map(gauge => <option key={`start-${gauge.km}-${gauge.name}`} value={gauge.km}>{gauge.km} ({gauge.name})</option>)} </select> <span>tot</span> <select value={journey.end ?? ''} onChange={(e) => handleJourneyChange('end', e.target.value)}> <option value="">Selecteer einde</option> {allGaugeStaticData.filter(g => g.isMainRoute).map(gauge => <option key={`end-${gauge.km}-${gauge.name}`} value={gauge.km}>{gauge.km} ({gauge.name})</option>)} </select> </div>
                         <div className="control-group"> <label>Weergave Modus:</label> <div className="view-toggle-group"> <label><input type="radio" value="draft" checked={displayMode === 'draft'} onChange={handleDisplayModeChange} /> Diepgang</label> <label><input type="radio" value="level" checked={displayMode === 'level'} onChange={handleDisplayModeChange} /> Waterstand (ruw) </label> </div> </div>
                         <div className="control-group">
                            <label>
                                <input type="checkbox" checked={showUncertainty} onChange={handleUncertaintyToggle} />
                                Toon Prognose Onzekerheid (indien beschikbaar)
                            </label>
                         </div>
                         <div className="control-group"> <button className="refresh-btn" onClick={() => handleRefresh(true)} ref={refreshButtonRef} disabled={dataStatus.status === 'pending'}> {dataStatus.status === 'pending' ? 'Laden...' : 'Data opnieuw laden'} </button> <div className={`data-status ${dataStatus.status}`}> {dataStatus.message} {dataStatus.status !== 'pending' && lastUpdated ? `(API tijd: ${lastUpdated.toLocaleTimeString()})` : ''} </div> </div>
                    </div>
                    {activeTab === 'route' && (
                        <div className="controls-right highlight-box">
                            <div style={{ marginBottom: '8px', fontWeight: 'bold' }}>Kritieke diepgang ({travelDirection === 'downstream' ? 'Af' : 'Op'}):</div>
                            <div>
                                <span className="label">Nu:</span>
                                <span className="value">{criticalDraftValue !== null ? `${criticalDraftValue.toFixed(0)} cm` : 'N/A'}</span>
                                <span className="gauge">({criticalGaugeName || 'N/A'})</span>
                                <span className="time">({criticalApiDataForHighlight?.currentTime || 'N/A'})</span>
                            </div>
                            {/* Highlight box forecast rendering */}
                            {forecastBottlenecks.map((forecast) => (
    <div key={`forecast-bottleneck-${forecast.date}`}>
        <span className="label">{new Date(forecast.date + 'T12:00:00Z').toLocaleDateString('nl-NL', { weekday: 'short', day: 'numeric' })}:</span>
        <span className="value">
            {forecast.draft !== 'N/A' ? `${forecast.draft} cm` : 'N/A'}
            {showUncertainty && forecast.uncertainty && (
                <span style={{fontSize: '0.85em', color: '#333', fontWeight: 'normal', marginLeft: '5px'}}>
                    {forecast.uncertainty}
                </span>
            )}
        </span>
        <span className="gauge">({forecast.gauge || 'N/A'})</span>
        <span className="time">({forecast.time || 'N/A'})</span>
    </div>
))}
                            {forecastDates.length > 0 && forecastBottlenecks.every(f => f.gauge === null) && dataStatus.status !== 'pending' && <div style={{fontSize: '0.9em', color: '#333', marginTop: '5px'}}>Geen kritieke prognose gevonden</div>}
                            {forecastDates.length === 0 && dataStatus.status !== 'pending' && <div style={{fontSize: '0.9em', color: '#333', marginTop: '5px'}}>Geen prognose data beschikbaar</div>}
                            {dataStatus.status === 'pending' && <div style={{fontSize: '0.9em', color: '#333', marginTop: '5px'}}>Prognoses laden...</div>}
                        </div>
                    )}
                    {activeTab !== 'route' && ( <div className="controls-right"><p style={{fontSize: '0.9em', color: '#aaa'}}>Alle beschikbare peilingen en dieptes.</p></div> )}
                </header>

                {/* Main Content Area */}
                <div className="main-content">
                    {/* Tabs */}
                    <div className="tab-controls">
                        <button className={`tab-button ${activeTab === 'route' ? 'active' : ''}`} onClick={() => handleTabChange('route')} >Route Planner (Rijn/Waal)</button>
                        <button className={`tab-button ${activeTab === 'all' ? 'active' : ''}`} onClick={() => handleTabChange('all')}>Alle Peilingen & Dieptes ({displayedGaugeData.length})</button>
                    </div>

                    {/* Table Container */}
                    {/* IMPORTANT: If sticky header still doesn't work with the CSS changes, */}
                    {/* you might need to wrap the <table> below in a */}
                    {/* <div className="table-scroll-wrapper"> ... </div> */}
                    <div className="table-container">
                            <table>
                            <thead>
                                {/* Header rows */}
                                <tr>
                                    <th rowSpan="2">Rivier</th>
                                    <th rowSpan="2">Strecke</th>
                                    <th rowSpan="2">Naam</th>
                                    <th rowSpan="2" className="numeric">GIW<br/><span style={{fontSize: '0.8em', fontWeight: 'normal'}}>(cm)</span></th>
                                    <th rowSpan="2" className="numeric">TuGIW<br/><span style={{fontSize: '0.8em', fontWeight: 'normal'}}>(cm)</span></th>
                                    <th rowSpan="2" className="numeric"> Waarde <br/> <span style={{fontSize: '0.8em', fontWeight: 'normal'}}>(Actueel, cm)</span></th>
                                    <th rowSpan="2" className="numeric">Tendens<br/> <span style={{fontSize: '0.8em', fontWeight: 'normal'}}>(cm, -24h)</span></th>
                                    <th rowSpan="2" className="numeric">Officiële<br/>Vuistregel<br/><span style={{fontSize: '0.8em', fontWeight: 'normal'}}>(cm)</span></th>
                                    <th colSpan="2" className="center">Correctie (cm)</th>
                                    <th colSpan="2" className="center">Aangepaste <br/> Vuistregel (cm)</th>
                                    <th rowSpan="2" className="numeric"> {displayMode === 'draft' ? 'Diepgang' : 'Waarde'} <br/> <span style={{fontSize: '0.8em', fontWeight: 'normal'}}>(Actueel, cm)</span></th>
                                    {forecastDates.map(dateStr => (
                                        <th key={`forecast-hdr-${dateStr}`} rowSpan="2" className="numeric">
                                            {new Date(dateStr + 'T12:00:00Z').toLocaleDateString('nl-NL', { weekday: 'short', day: 'numeric' })} <br/>
                                            <span style={{ fontSize: '0.8em', fontWeight: 'normal' }}> ({displayMode === 'draft' ? 'D' : 'S'}, cm{showUncertainty ? ' ±' : ''}) </span>
                                        </th>
                                    ))}
                                    {forecastDates.length === 0 && dataStatus.status !== 'pending' && <th rowSpan="2">Geen Prognoses</th>}
                                </tr>
                                <tr>
                                    <th className="numeric">Op</th>
                                    <th className="numeric">Af</th>
                                    <th className="numeric">Op</th>
                                    <th className="numeric">Af</th>
                                </tr>
                            </thead>
                                <tbody>
                                {/* Loading/No Data Messages */}
                                {dataStatus.status === 'pending' && ( <tr><td colSpan={13 + Math.max(1, forecastDates.length)} style={{textAlign: 'center', fontStyle: 'italic'}}>Laden...</td></tr> )}
                                {dataStatus.status !== 'pending' && displayedGaugeData.length === 0 && ( <tr><td colSpan={13 + Math.max(1, forecastDates.length)} style={{textAlign: 'center', fontStyle: 'italic'}}> {activeTab === 'route' ? 'Selecteer een geldig Rijn/Waal traject of geen data beschikbaar voor traject.' : (Object.keys(gaugeApiData).length === 0 ? 'Geen API data geladen.' : 'Geen data beschikbaar voor deze weergave.')} </td></tr> )}

                                {/* Map over displayed gauge data */}
                                {displayedGaugeData.map(gauge => {
                                    const apiData = gauge.apiData; if (!apiData) return null;
                                    const isCritical = activeTab === 'route' && gauge.name === criticalGaugeName;
                                    const currentLevel = apiData.currentLevel; const currentTime = apiData.currentTime || 'N/A'; const currentTrend = apiData.currentTrend ?? '-';
                                    const officialRuleDisplay = calculateOfficialRuleOfThumb(gauge); const customRuleDisplayUp = calculateCustomRuleOfThumbDisplay(gauge, 'upstream'); const customRuleDisplayDown = calculateCustomRuleOfThumbDisplay(gauge, 'downstream');
                                    const currentActualDraft = currentLevel !== null ? calculateDraft(gauge, currentLevel) : null; const currentLevelDisplay = currentLevel;
                                    let lastColumnClass = "numeric "; let lastColumnValue = '-';
                                    if (displayMode === 'draft') { lastColumnClass += 'actual-draft-column'; if (currentActualDraft !== null) { lastColumnValue = currentActualDraft.toFixed(0); if (isCritical) lastColumnClass += ' critical-actual-draft'; } } else { lastColumnClass += 'actual-level-column'; if (currentLevelDisplay !== null) { lastColumnValue = currentLevelDisplay.toFixed(0); if (isCritical) lastColumnClass += ' critical-actual-level'; } }
                                    let levelColumnClass = 'numeric'; if (currentLevelDisplay !== null && isCritical) levelColumnClass += ' critical-level';

                                    return (
                                        <tr key={`${gauge.name}-${gauge.km ?? gauge.streckenAbschnitt ?? apiData?.apiName}`} className={isCritical ? 'critical-row' : ''}>
                                            {/* Cols 1-13 */}
                                            <td>{gauge.river || 'N/A'}</td> <td>{gauge.streckenAbschnitt || 'N/A'}</td>
                                            <td><a href={getGaugeUrl(gauge)} target="_blank" rel="noopener noreferrer" className="gauge-link">{gauge.name}</a></td>
                                            <td className="numeric">{gauge.giw !== 'N/A' ? gauge.giw : '-'}</td> <td className="numeric">{gauge.depthAtGiw !== 'N/A' ? gauge.depthAtGiw : '-'}</td>
                                            <td className={levelColumnClass}> {currentLevelDisplay !== null ? currentLevelDisplay.toFixed(0) : (apiData.status === 'ERROR' ? `Error` : '-')} <div className="time-display">{currentTime !== 'N/A' ? currentTime : (apiData.status ? '' : 'Laden..')}</div> </td>
                                            <td className="numeric">{currentTrend}</td> <td className="numeric">{officialRuleDisplay}</td>
                                            <td className="numeric"><input type="number" value={customCorrections.upstream[gauge.name] ?? ''} onChange={(e) => handleCorrectionChange('upstream', gauge.name, e.target.value)} /></td>
                                            <td className="numeric"><input type="number" value={customCorrections.downstream[gauge.name] ?? ''} onChange={(e) => handleCorrectionChange('downstream', gauge.name, e.target.value)} /></td>
                                            <td className="numeric">{customRuleDisplayUp}</td> <td className="numeric">{customRuleDisplayDown}</td>
                                            <td className={lastColumnClass}> {lastColumnValue} {lastColumnValue !== '-' && <div className="time-display">{currentTime !== 'N/A' ? currentTime : ''}</div>} </td>

                                            {/* Col 14+: Forecasts */}
                                            {forecastDates.map(dateStr => {
                                                let forecastDisplayValue = '-'; let forecastDisplayTime = '';
                                                let uncertaintyText = ''; let valueSource = ''; let foundWeeklySlot = null;

                                                // 1. Check Daily
                                                const forecastsForDate = apiData.forecasts?.[dateStr];
                                                if (forecastsForDate && Object.keys(forecastsForDate).length > 0) {
                                                    const selectedTime = getBestForecastTime(forecastsForDate, currentTime);
                                                    const forecastSlot = selectedTime ? forecastsForDate[selectedTime] : null;
                                                    if (forecastSlot && forecastSlot.value !== undefined && forecastSlot.value !== null) {
                                                        const forecastLevel = forecastSlot.value; forecastDisplayTime = selectedTime; valueSource = 'daily';
                                                        let calculatedFcValue = (displayMode === 'draft') ? calculateDraft(gauge, forecastLevel) : forecastLevel;
                                                        forecastDisplayValue = calculatedFcValue !== null ? calculatedFcValue.toFixed(0) : '-';
                                                        if (showUncertainty && calculatedFcValue !== null) {
                                                            if (forecastSlot.low_80 !== null && forecastSlot.high_80 !== null) {
                                                                let lowVal = forecastSlot.low_80; let highVal = forecastSlot.high_80;
                                                                if (displayMode === 'draft') { lowVal = calculateDraft(gauge, forecastSlot.low_80); highVal = calculateDraft(gauge, forecastSlot.high_80); }
                                                                if (lowVal !== null && !isNaN(lowVal) && highVal !== null && !isNaN(highVal)) { uncertaintyText = `(${Math.min(lowVal, highVal).toFixed(0)} - ${Math.max(lowVal, highVal).toFixed(0)})`; }
                                                                else uncertaintyText = '(Bereik N/A)';
                                                            } else {
                                                                const daysAhead = diffDays(todayStr, dateStr);
                                                                if (!isNaN(daysAhead) && daysAhead > 0) { const elwisUncertainty = daysAhead <= 2 ? 10 : 20; uncertaintyText = `(±${elwisUncertainty} cm)`; }
                                                            }
                                                        }
                                                    }
                                                }

                                                // 2. Check Weekly Fallback
                                                if (forecastDisplayValue === '-' && Array.isArray(apiData.weeklyForecasts) && apiData.weeklyForecasts.length > 0) {
                                                    const targetDate = new Date(dateStr + 'T12:00:00Z');
                                                    for (const weeklyForecast of apiData.weeklyForecasts) {
                                                        if (weeklyForecast.weekRange && weeklyForecast.median !== null) {
                                                            try {
                                                                const [startStr, endStr] = weeklyForecast.weekRange.split('-'); const [startDay, startMonth, startYear] = startStr.split('.'); const [endDay, endMonth, endYear] = endStr.split('.');
                                                                const startDate = new Date(Date.UTC(startYear, startMonth - 1, startDay, 0, 0, 0)); const endDate = new Date(Date.UTC(endYear, endMonth - 1, endDay, 23, 59, 59));
                                                                if (!isNaN(startDate.getTime()) && !isNaN(endDate.getTime()) && targetDate >= startDate && targetDate <= endDate) {
                                                                    const forecastLevel = weeklyForecast.median; let calculatedFcValue = (displayMode === 'draft') ? calculateDraft(gauge, forecastLevel) : forecastLevel;
                                                                    if (calculatedFcValue !== null) {
                                                                        forecastDisplayValue = calculatedFcValue.toFixed(0); forecastDisplayTime = "(BfG6W)"; valueSource = 'weekly'; foundWeeklySlot = weeklyForecast; break;
                                                                    }
                                                                }
                                                            } catch (e) { console.warn(`Error parsing weekRange "${weeklyForecast.weekRange}" for gauge ${gauge.name}:`, e); }
                                                        }
                                                    }
                                                }

                                                // 3. Weekly Uncertainty (if needed)
                                                if (valueSource === 'weekly' && showUncertainty && foundWeeklySlot) {
                                                    if (foundWeeklySlot.low_90 !== null && foundWeeklySlot.high_90 !== null) {
                                                         let lowVal = foundWeeklySlot.low_90; let highVal = foundWeeklySlot.high_90;
                                                         if (displayMode === 'draft') { lowVal = calculateDraft(gauge, foundWeeklySlot.low_90); highVal = calculateDraft(gauge, foundWeeklySlot.high_90); }
                                                         if (lowVal !== null && !isNaN(lowVal) && highVal !== null && !isNaN(highVal)) { uncertaintyText = `(${Math.min(lowVal, highVal).toFixed(0)} - ${Math.max(lowVal, highVal).toFixed(0)})`; }
                                                         else uncertaintyText = '(Bereik N/A)';
                                                    }
                                                }

                                                // 4. Render Cell
                                                return (
                                                    <td key={`forecast-${gauge.name}-${dateStr}`} className="numeric forecast-cell">
                                                        {forecastDisplayValue !== '-' ? (
                                                            <div>
                                                                {forecastDisplayValue}
                                                                {showUncertainty && uncertaintyText && (<span className="uncertainty-display">{uncertaintyText}</span>)}
                                                                {forecastDisplayTime && (<div className={`time-display ${valueSource === 'weekly' ? 'weekly' : ''}`}>{forecastDisplayTime}</div>)}
                                                            </div>
                                                        ) : ('-') }
                                                    </td>
                                                );
                                            })}
                                            {forecastDates.length === 0 && dataStatus.status !== 'pending' && <td>-</td>}
                                        </tr>
                                    );
                                })}
                            </tbody>
                            </table>
                    </div> {/* End .table-container */}
                </div> {/* End .main-content */}

                {/* Footer */}
                <footer>
                     <div>Data API per: {lastUpdated ? lastUpdated.toLocaleString('nl-NL') : 'Nog niet geladen'}</div>
                    <div>RDD Calculator v4.8</div> {/* Version number remains 4.8 */}
                </footer>
            </div>
        );
    }

    ReactDOM.render(<RhineDraftCalculator />, document.getElementById('root'));

</script>
</body>
</html>