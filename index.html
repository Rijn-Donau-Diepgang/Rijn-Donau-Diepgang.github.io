<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rhine Draft Calculator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.21.2/babel.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            color: white;
            background-color: #121212;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100%;
        }

        header {
            background-color: #1e1e1e;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .dashboard-controls {
            display: flex;
            padding: 1rem;
            background-color: #1e1e1e;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        select, input, button {
            background-color: #2a2a2a;
            color: white;
            border: none;
            padding: 0.5rem;
            border-radius: 4px;
        }

        button {
            cursor: pointer;
        }

        .main-content {
            flex-grow: 1;
            padding: 1rem;
            overflow: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid #333;
        }

        th {
            background-color: #1e1e1e;
            position: sticky;
            top: 0;
        }

        tr:hover {
            background-color: #2a2a2a;
        }

        .critical-row {
            background-color: rgba(255, 0, 0, 0.3);
        }

        .draft-highlight {
            font-weight: bold;
            color: #00cc66;
        }

        .critical-draft {
            font-weight: bold;
            color: #ff6666;
        }

        footer {
            background-color: #1e1e1e;
            padding: 1rem;
            font-size: 0.875rem;
            display: flex;
            justify-content: space-between;
        }

        .highlight-box {
            background-color: #cc9900;
            border-radius: 4px;
            padding: 0.5rem;
            color: black;
            font-weight: bold;
        }

        .data-status {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background-color: #333;
            border-radius: 4px;
            font-size: 0.875rem;
        }

        .refresh-btn {
            background-color: #0066cc;
            padding: 0.5rem 1rem;
            cursor: pointer;
        }

        .refresh-btn:hover {
            background-color: #0055aa;
        }
    </style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
    const {useState, useEffect, useCallback, useRef} = React;

    // Cookie utility functions
    function setCookie(name, value, days = 3650) {
        const date = new Date();
        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
        const expires = `expires=${date.toUTCString()}`;
        document.cookie = `${name}=${JSON.stringify(value)};${expires};path=/`;
    }

    function getCookie(name) {
        const nameEQ = `${name}=`;
        const ca = document.cookie.split(';');
        for (let i = 0; i < ca.length; i++) {
            let c = ca[i];
            while (c.charAt(0) === ' ') c = c.substring(1, c.length);
            if (c.indexOf(nameEQ) === 0) {
                try {
                    return JSON.parse(c.substring(nameEQ.length, c.length));
                } catch (e) {
                    console.error("Error parsing cookie:", e);
                    return null;
                }
            }
        }
        return null;
    }


    // Format time display
    function formatTimeDisplay(dateString) {
        try {
            const date = new Date(dateString);
            if (isNaN(date.getTime())) {
                console.error("Invalid date string:", dateString);
                return "N/A";
            }
            return date.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
        } catch (error) {
            console.error("Error formatting date:", error);
            return "N/A";
        }
    }

    // Fetch German water level data using official API
    async function fetchWaterLevelData(gaugeName) {
        const stationCode = gaugeName.toUpperCase().replace(/ /g, '_');
        const now = new Date();
        const startDate = new Date(now.getTime() - 24 * 60 * 60 * 1000); // 24 hours ago
        let formattedForecasts = {};

        try {
            // Fetch measurements from last 24 hours
            const measurementsResponse = await fetch(
                `https://pegelonline.wsv.de/webservices/rest-api/v2/stations/${stationCode}/W/measurements.json?start=${startDate.toISOString()}`
            );
            if (!measurementsResponse.ok) throw new Error('Failed to fetch measurements');
            const measurements = await measurementsResponse.json();

            // Process measurements
            let currentLevel = null;
            let currentTrend = null;
            let currentTime = null;

            if (measurements.length > 0) {
                const sortedMeasurements = measurements.sort((a, b) =>
                    new Date(a.timestamp) - new Date(b.timestamp)
                );

                const first = sortedMeasurements[0];
                const last = sortedMeasurements[sortedMeasurements.length - 1];

                currentLevel = Math.round(last.value);
                currentTrend = Math.round(last.value - first.value);
                currentTime = formatTimeDisplay(last.timestamp);
            }

            // Fetch forecasts - handle separately so measurement data is still returned if forecasts fail
            try {
                const forecastResponse = await fetch(
                    `https://pegelonline.wsv.de/webservices/rest-api/v2/stations/${stationCode}/WV/measurements.json`
                );

                if (forecastResponse.ok) {
                    const forecastsData = await forecastResponse.json();

                    // Process forecasts if data exists
                    if (forecastsData && Array.isArray(forecastsData)) {
                        forecastsData.forEach(entry => {
                            if (entry.type === 'forecast' || entry.type === 'estimate') {
                                const date = new Date(entry.timestamp);
                                const dateStr = date.toISOString().split('T')[0];
                                const timeStr = formatTimeDisplay(entry.timestamp);

                                if (!formattedForecasts[dateStr]) {
                                    formattedForecasts[dateStr] = {};
                                }
                                formattedForecasts[dateStr][timeStr] = Math.round(entry.value);
                            }
                        });
                    }
                } else {
                    console.warn(`No forecast available for ${gaugeName}`);
                }
            } catch (forecastError) {
                console.warn(`Error fetching forecasts for ${gaugeName}, continuing with measurements only:`, forecastError);
            }

            return {
                currentLevel,
                currentTime,
                currentTrend,
                timestamp: now.toISOString(),
                forecasts: formattedForecasts
            };

        } catch (error) {
            console.error(`Error fetching German data for ${gaugeName}:`, error);
            throw error;
        }
    }

    // Fetch Dutch water level data
    async function fetchDutchWaterLevelData(locationInfo) {
        // const proxyUrl = 'https://corsproxy.github.io/';
        // const cacheBuster = `nocache=${new Date().getTime()}-${Math.random()}`;
        // const targetUrl = `https://waterwebservices.rijkswaterstaat.nl/ONLINEWAARNEMINGENSERVICES_DBO/OphalenWaarnemingen?${cacheBuster}`;
        const proxyUrl = '';
        const targetUrl = 'https://corsproxy.io/' + encodeURIComponent(
            'https://waterwebservices.rijkswaterstaat.nl/ONLINEWAARNEMINGENSERVICES_DBO/OphalenWaarnemingen'
        );

        console.log(`Starting Dutch data fetch for ${locationInfo.code}`);

        try {
            // Create date strings for the last 24 hours
            const now = new Date();
            const dayAgo = new Date(now);
            dayAgo.setHours(now.getHours() - 24);

            const formatDate = (date) => {
                const localISOString = new Date(date.getTime() - (date.getTimezoneOffset() * 60000))
                    .toISOString()
                    .replace('Z', '');

                const offset = -date.getTimezoneOffset();
                const offsetHours = Math.floor(Math.abs(offset) / 60).toString().padStart(2, '0');
                const offsetMinutes = (Math.abs(offset) % 60).toString().padStart(2, '0');
                const offsetSign = offset >= 0 ? '+' : '-';

                return `${localISOString}${offsetSign}${offsetHours}:${offsetMinutes}`;
            };

            const startDate = formatDate(dayAgo);
            const endDate = formatDate(now);

            console.log(`Fetching Dutch data for ${locationInfo.code} at ${now.toISOString()}`);

            // Create measurement payload
            const measurementPayload = {
                "Locatie": {
                    "Code": locationInfo.code,
                    "X": locationInfo.x,
                    "Y": locationInfo.y
                },
                "AquoPlusWaarnemingMetadata": {
                    "AquoMetadata": {
                        "Compartiment": {"Code": "OW"},
                        "Grootheid": {"Code": "WATHTE"}
                    }
                },
                "Periode": {
                    "Begindatumtijd": startDate,
                    "Einddatumtijd": endDate
                }
            };

            // Fetch measurements
            const measurementResponse = await fetch(proxyUrl + targetUrl, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(measurementPayload)
            });

            if (!measurementResponse.ok) {
                throw new Error(`Failed to fetch water level data: ${measurementResponse.status}`);
            }

            const measurementData = await measurementResponse.json();

            // Process measurement data
            let currentLevel = null;
            let currentTrend = null;
            let currentTime = null;
            let rawTimestamp = null;

            if (measurementData?.WaarnemingenLijst?.[0]?.MetingenLijst?.length > 1) {
                const measurements = [...measurementData.WaarnemingenLijst[0].MetingenLijst];
                measurements.sort((a, b) => new Date(a.Tijdstip) - new Date(b.Tijdstip));

                const firstMeasurement = measurements[0];
                const lastMeasurement = measurements[measurements.length - 1];

                if (lastMeasurement?.Meetwaarde) {
                    currentLevel = Math.round(lastMeasurement.Meetwaarde.Waarde_Numeriek);
                    rawTimestamp = lastMeasurement.Tijdstip;
                    currentTime = formatTimeDisplay(lastMeasurement.Tijdstip);
                }

                if (firstMeasurement?.Meetwaarde && lastMeasurement?.Meetwaarde) {
                    currentTrend = Math.round(lastMeasurement.Meetwaarde.Waarde_Numeriek -
                        firstMeasurement.Meetwaarde.Waarde_Numeriek);
                }
            }

            // Fetch forecast data
            const forecast24h = new Date(now);
            forecast24h.setHours(now.getHours() + 24);

            const forecast50h = new Date(now);
            forecast50h.setHours(now.getHours() + 50);

            const forecastStartDate = formatDate(forecast24h);
            const forecastEndDate = formatDate(forecast50h);

            const forecastPayload = {
                "Locatie": {
                    "Code": locationInfo.code,
                    "X": locationInfo.x,
                    "Y": locationInfo.y
                },
                "AquoPlusWaarnemingMetadata": {
                    "AquoMetadata": {
                        "Compartiment": {"Code": "OW"},
                        "Grootheid": {"Code": "WATHTEVERWACHT"}
                    }
                },
                "Periode": {
                    "Begindatumtijd": forecastStartDate,
                    "Einddatumtijd": forecastEndDate
                }
            };

            console.log(`Fetching forecast data for location: ${locationInfo.code}...`);

            const forecastResponse = await fetch(proxyUrl + targetUrl, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(forecastPayload)
            });

            if (!forecastResponse.ok) {
                throw new Error(`Failed to fetch forecast data: ${forecastResponse.status}`);
            }

            const forecastData = await forecastResponse.json();

            let formattedForecasts = {};

            if (forecastData?.WaarnemingenLijst?.[0]?.MetingenLijst?.length) {
                const forecasts = [...forecastData.WaarnemingenLijst[0].MetingenLijst];
                forecasts.sort((a, b) => new Date(a.Tijdstip) - new Date(b.Tijdstip));

                forecasts.forEach(forecast => {
                    if (forecast?.Tijdstip && forecast?.Meetwaarde) {
                        const forecastTime = new Date(forecast.Tijdstip);
                        const forecastDate = forecastTime.toISOString().split('T')[0];
                        const forecastTimeStr = formatTimeDisplay(forecast.Tijdstip);
                        const forecastValue = Math.round(forecast.Meetwaarde.Waarde_Numeriek);

                        if (!formattedForecasts[forecastDate]) {
                            formattedForecasts[forecastDate] = {};
                        }

                        formattedForecasts[forecastDate][forecastTimeStr] = forecastValue;
                    }
                });
            }

            console.log(`Successfully fetched Dutch data for ${locationInfo.code}`);

            return {
                currentLevel,
                currentTime,
                currentTrend,
                timestamp: new Date().toISOString(),
                forecasts: formattedForecasts,
                debug: {
                    rawTimestamp: rawTimestamp,
                    requestTime: now.toISOString()
                }
            };

        } catch (error) {
            console.error(`Error fetching data for location ${locationInfo.code}:`, error);
            throw error;
        }
    }

    // Rhine Draft Calculator Component
    function RhineDraftCalculator() {
        const [gaugeData, setGaugeData] = useState([]);
        const [waterLevels, setWaterLevels] = useState({});
        const [waterTrends, setWaterTrends] = useState({});
        const [forecasts, setForecasts] = useState({});
        const [customCorrections, setCustomCorrections] = useState({upstream: {}, downstream: {}})
        const [forecastDates, setForecastDates] = useState([]);
        const [dataLoaded, setDataLoaded] = useState(false);
        const [dataStatus, setDataStatus] = useState({status: 'pending', message: 'Initializing data...'});
        const [lastUpdated, setLastUpdated] = useState(new Date());
        const [travelDirection, setTravelDirection] = useState('downstream');
        const [currentTimes, setCurrentTimes] = useState({});
        const [autoRefresh, setAutoRefresh] = useState(true);
        const [nextRefreshTime, setNextRefreshTime] = useState(null);
        const refreshButtonRef = useRef(null);
        const [journey, setJourney] = useState(() => {
            // Try to load saved journey from cookies
            const savedJourney = getCookie('rhineDraftJourney');
            // Return saved journey if available, otherwise use default (Tiel to Maxau)
            return savedJourney || {start: 914, end: 0};
        });

        // Auto-refresh effect
        useEffect(() => {
            if (!autoRefresh) {
                setNextRefreshTime(null);
                return () => {
                };
            }

            // Set initial next refresh time
            const nextTime = new Date();
            nextTime.setMinutes(nextTime.getMinutes() + 10);
            setNextRefreshTime(nextTime);

            // Create the interval
            const intervalId = setInterval(() => {
                console.log("Auto-refresh triggered at", new Date().toLocaleTimeString());

                // Simulate clicking the refresh button
                if (refreshButtonRef.current) {
                    refreshButtonRef.current.click();
                }

                // Update next refresh time
                const refreshTime = new Date();
                refreshTime.setMinutes(refreshTime.getMinutes() + 10);
                setNextRefreshTime(refreshTime);
            }, 10 * 60 * 1000); // 10 minutes in milliseconds

            // Return cleanup function
            return () => clearInterval(intervalId);
        }, [autoRefresh]);

        // Initialize gauge data
        useEffect(() => {
            const gauges = [
                {
                    name: 'Konstanz',
                    km: 0,
                    streckenAbschnitt: '0-1',
                    giw: 0,
                    depthAtGiw: 0,
                    officialSafetyMargin: 0,
                    correctionOp: 0,
                    correctionAf: 0,
                    customVuistregel: 0
                },
                {
                    name: 'Iffezheim',
                    km: 334,
                    streckenAbschnitt: '334-384',
                    giw: 0,
                    depthAtGiw: 0,
                    officialSafetyMargin: 0,
                    correctionOp: 10,
                    correctionAf: 20,
                    customVuistregel: 80
                },
                {
                    name: 'Maxau',
                    km: 362,
                    streckenAbschnitt: '335-384',
                    giw: 372,
                    depthAtGiw: 210,
                    officialSafetyMargin: 30,
                    correctionOp: 22,
                    correctionAf: 22
                },
                {
                    name: 'Speyer',
                    km: 400,
                    streckenAbschnitt: '384-410.50',
                    giw: 237,
                    depthAtGiw: 210,
                    officialSafetyMargin: 30,
                    correctionOp: 27,
                    correctionAf: 27
                },
                {
                    name: 'Mannheim',
                    km: 424,
                    streckenAbschnitt: '410.50-431.50',
                    giw: 155,
                    depthAtGiw: 210,
                    officialSafetyMargin: 30,
                    correctionOp: 30,
                    correctionAf: 30
                },
                {
                    name: 'Worms',
                    km: 443,
                    streckenAbschnitt: '431.50-462',
                    giw: 68,
                    depthAtGiw: 210,
                    officialSafetyMargin: 30,
                    correctionOp: 33,
                    correctionAf: 33
                },
                {
                    name: 'Mainz',
                    km: 498,
                    streckenAbschnitt: '462-508',
                    giw: 171,
                    depthAtGiw: 210,
                    officialSafetyMargin: 30,
                    correctionOp: 11,
                    correctionAf: 11
                },
                {
                    name: 'Oestrich',
                    km: 518,
                    streckenAbschnitt: '508-540',
                    giw: 92,
                    depthAtGiw: 190,
                    officialSafetyMargin: 30,
                    correctionOp: 32,
                    correctionAf: 32
                },
                {
                    name: 'Bingen',
                    km: 541,
                    streckenAbschnitt: '540-541',
                    giw: 0,
                    depthAtGiw: 0,
                    officialSafetyMargin: 0,
                    correctionOp: 0,
                    correctionAf: 0,
                    customVuistregel: 100
                },
                {
                    name: 'Kaub',
                    km: 546,
                    streckenAbschnitt: '541-566',
                    giw: 77,
                    depthAtGiw: 190,
                    officialSafetyMargin: 30,
                    correctionOp: 17,
                    correctionAf: 27
                },
                {
                    name: 'Koblenz',
                    km: 570,
                    streckenAbschnitt: '566-601',
                    giw: 77,
                    depthAtGiw: 210,
                    officialSafetyMargin: 30,
                    correctionOp: 27,
                    correctionAf: 27
                },
                {
                    name: 'Andernach',
                    km: 613,
                    streckenAbschnitt: '601-624',
                    giw: 91,
                    depthAtGiw: 250,
                    officialSafetyMargin: 30,
                    correctionOp: 0,
                    correctionAf: 0
                },
                {
                    name: 'Bonn',
                    km: 655,
                    streckenAbschnitt: '624-660',
                    giw: 142,
                    depthAtGiw: 250,
                    officialSafetyMargin: 30,
                    correctionOp: 0,
                    correctionAf: 0
                },
                {
                    name: 'Köln',
                    km: 688,
                    streckenAbschnitt: '660-710',
                    giw: 139,
                    depthAtGiw: 250,
                    officialSafetyMargin: 30,
                    correctionOp: 0,
                    correctionAf: 9
                },
                {
                    name: 'Düsseldorf',
                    km: 744,
                    streckenAbschnitt: '710-763',
                    giw: 91,
                    depthAtGiw: 250,
                    officialSafetyMargin: 30,
                    correctionOp: 0,
                    correctionAf: 0
                },
                {
                    name: 'Duisburg-Ruhrort',
                    km: 780,
                    streckenAbschnitt: '763-794',
                    giw: 227,
                    depthAtGiw: 280,
                    officialSafetyMargin: 30,
                    correctionOp: 0,
                    correctionAf: 0
                },
                {
                    name: 'Wesel',
                    km: 814,
                    streckenAbschnitt: '794-837',
                    giw: 174,
                    depthAtGiw: 280,
                    officialSafetyMargin: 30,
                    correctionOp: 0,
                    correctionAf: 0
                },
                {
                    name: 'Emmerich',
                    km: 852,
                    streckenAbschnitt: '837-857',
                    giw: 74,
                    depthAtGiw: 280,
                    officialSafetyMargin: 30,
                    correctionOp: 0,
                    correctionAf: 0
                },
                {
                    name: 'Nijmegen',
                    km: 884,
                    streckenAbschnitt: '857-893',
                    giw: 0,
                    depthAtGiw: 0,
                    officialSafetyMargin: 0,
                    correctionOp: 0,
                    correctionAf: 0,
                    customVuistregel: -275
                },
                {
                    name: 'Tiel',
                    km: 914,
                    streckenAbschnitt: '893-930',
                    giw: 0,
                    depthAtGiw: 0,
                    officialSafetyMargin: 0,
                    correctionOp: 0,
                    correctionAf: 0,
                    customVuistregel: 10
                }
            ];

            const defaultCorrections = {upstream: {}, downstream: {}};
            gauges.forEach(gauge => {
                defaultCorrections.upstream[gauge.name] = gauge.correctionOp;
                defaultCorrections.downstream[gauge.name] = gauge.correctionAf;
            });

            // Try to load saved corrections from cookies
            const savedCorrections = getCookie('rhineDraftCorrections');

            // Set gauge data
            setGaugeData(gauges);

            // Use saved corrections if available, otherwise use defaults
            setCustomCorrections(savedCorrections || defaultCorrections);

            loadWaterLevelData(gauges);
        }, []);

        const handleCorrectionChange = (direction, gaugeName, value) => {
            const newCorrections = {
                ...customCorrections,
                [direction]: {
                    ...customCorrections[direction],
                    [gaugeName]: parseInt(value, 10)
                }
            };

            setCustomCorrections(newCorrections);

            // Save to cookie whenever corrections change
            setCookie('rhineDraftCorrections', newCorrections);
        };

        // Load water level data
        const loadWaterLevelData = async (gauges) => {
            setDataStatus({status: 'pending', message: 'Voorbereiding data verversing...'});

            // Initialize data structures
            const newWaterLevels = {...waterLevels};
            const newWaterTrends = {...waterTrends};
            const newForecasts = {...forecasts};
            const newCurrentTimes = {...currentTimes};
            const allDates = new Set();

            // Dutch gauge location information
            const dutchGaugeInfo = {
                'Nijmegen': {code: 'NIJM', x: 696323.704868814, y: 5748468.59068443},
                'Tiel': {code: 'TIEW', x: 668937.952337159, y: 5752825.4886739}
            };

            try {
                for (const gauge of gauges) {
                    // Update status to show which gauge is being downloaded
                    setDataStatus({
                        status: 'pending',
                        message: `Data van ${gauge.name} downloaden...`
                    });

                    try {
                        let data;

                        // Check if this is a Dutch gauge
                        if (dutchGaugeInfo[gauge.name]) {
                            // Fetch Dutch gauge data
                            data = await fetchDutchWaterLevelData(dutchGaugeInfo[gauge.name]);
                        } else {
                            // Fetch German gauge data with existing function
                            data = await fetchWaterLevelData(gauge.name);
                        }

                        // Update individual gauge data as soon as it's available
                        newWaterLevels[gauge.name] = data.currentLevel || 0;
                        newWaterTrends[gauge.name] = data.currentTrend || 0;
                        newCurrentTimes[gauge.name] = data.currentTime || 'N/A';

                        // Update state immediately for this gauge
                        setWaterLevels({...newWaterLevels});
                        setWaterTrends({...newWaterTrends});
                        setCurrentTimes({...newCurrentTimes});

                        // Process forecast data
                        Object.entries(data.forecasts).forEach(([date, times]) => {
                            if (!newForecasts[date]) newForecasts[date] = {};
                            newForecasts[date][gauge.name] = times;
                            allDates.add(date);
                        });

                        // Update forecasts after each gauge
                        setForecasts({...newForecasts});

                        // Recalculate and update forecast dates after each gauge
                        const sortedDates = Array.from(allDates).sort();
                        const filteredDates = getLogicalForecastDates(sortedDates);
                        setForecastDates(filteredDates);

                    } catch (error) {
                        console.error(`Error fetching ${gauge.name}:`, error);
                        newWaterLevels[gauge.name] = 0;
                        newWaterTrends[gauge.name] = 0;
                        newCurrentTimes[gauge.name] = 'N/A';

                        // Still update state to show empty values
                        setWaterLevels({...newWaterLevels});
                        setWaterTrends({...newWaterTrends});
                        setCurrentTimes({...newCurrentTimes});
                    }
                }

                // Final update
                setDataStatus({status: 'success', message: `Data bijgewerkt: ${new Date().toLocaleString()}`});
                setLastUpdated(new Date());
                setDataLoaded(true);
            } catch (error) {
                setDataStatus({status: 'error', message: error.message});
            }
        };

        // Function to get forecast time at 24h intervals from the last measurement
        function getBestForecastTime(times, referenceTime = null) {
            if (!times || !times.length) return '';

            // Sort times
            const sortedTimes = [...times].sort();

            // If no reference time provided or it's invalid, return the latest time
            if (!referenceTime || !referenceTime.includes(':')) {
                return sortedTimes[sortedTimes.length - 1];
            }

            // Get latest available time
            const latestTime = sortedTimes[sortedTimes.length - 1];

            // Parse latest available time to check if it's a morning-only forecast day
            const [latestHours] = latestTime.split(':').map(part => parseInt(part, 10));

            // If the latest forecast is at or before 8:00, it's likely the last forecast day
            // with only morning forecasts available - so return the latest available time
            if (latestHours <= 8) {
                return latestTime;
            }

            // Parse the reference time
            const [refHours, refMinutes] = referenceTime.split(':').map(part => parseInt(part, 10));
            const refTotalMinutes = (refHours * 60) + (refMinutes || 0);

            // First try to find an exact hour match
            const exactMatches = sortedTimes.filter(time => {
                const [timeHours] = time.split(':').map(part => parseInt(part, 10));
                return timeHours === refHours;
            });

            if (exactMatches.length > 0) {
                return exactMatches[0];
            }

            // Special case for early morning hours (before 7:00)
            if (refHours < 7) {
                // Look for late evening forecasts (20:00-23:59) as alternatives
                const lateForecasts = sortedTimes.filter(time => {
                    const [timeHours] = time.split(':').map(part => parseInt(part, 10));
                    return timeHours >= 20;
                });

                if (lateForecasts.length > 0) {
                    return lateForecasts[lateForecasts.length - 1];
                }
            }

            // For all other cases, find the closest time
            let closestTime = sortedTimes[0];
            let minDiff = 24 * 60; // Minutes in a day

            for (const time of sortedTimes) {
                const [timeHours, timeMinutes] = time.split(':').map(part => parseInt(part, 10));
                const timeTotalMinutes = (timeHours * 60) + (timeMinutes || 0);

                const diff = Math.abs(timeTotalMinutes - refTotalMinutes);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestTime = time;
                }
            }

            return closestTime;
        }

        // Forecast date filtering - 24h intervals from last measurement
        function getLogicalForecastDates() {
            // Always return tomorrow + 3 future days
            const now = new Date();
            const forecastDates = [];

            for (let i = 1; i <= 4; i++) {
                const date = new Date(now);
                date.setDate(date.getDate() + i);
                forecastDates.push(date.toISOString().split('T')[0]);
            }

            return forecastDates;
        }

        const handleRefresh = useCallback(() => {
            // Reset state
            setDataLoaded(false);
            setForecastDates(getLogicalForecastDates());

            // Log refresh
            console.log("Performing full data refresh at", new Date().toISOString());

            // Use a longer delay to ensure state is reset
            setTimeout(() => {
                loadWaterLevelData(gaugeData);
            }, 300);
        }, [gaugeData]);

        // Calculate draft for a given gauge and water level
        const calculateDraft = (gaugeName, waterLevel, direction = travelDirection) => {
            // Special case for Konstanz - return "N/A" directly
            if (gaugeName === "Konstanz") return "N/A";

            const gauge = gaugeData.find(g => g.name === gaugeName);
            if (!gauge || !waterLevel) return null;

            const customCorrection = customCorrections[direction][gauge.name] || 0;

            // Use customVuistregel for Dutch gauges if available
            if (gauge.customVuistregel !== undefined) {
                return (parseInt(waterLevel) + gauge.customVuistregel + parseInt(customCorrection)).toFixed(0);
            } else {
                return (waterLevel - gauge.giw + gauge.depthAtGiw - gauge.officialSafetyMargin + customCorrection).toFixed(0);
            }
        };

        // Calculate official rule of thumb
        const calculateOfficialRuleOfThumb = (gauge) => {
            return (gauge.depthAtGiw - gauge.officialSafetyMargin - gauge.giw).toFixed(0);
        };

        // Calculate custom rule of thumb for a specific direction
        const calculateCustomRuleOfThumb = (gauge, direction) => {
            const customCorrection = customCorrections[direction][gauge.name] || 0;

            // Use customVuistregel for Dutch gauges if available
            if (gauge.customVuistregel !== undefined) {
                return (gauge.customVuistregel + parseInt(customCorrection)).toString();
            } else {
                return (gauge.depthAtGiw - gauge.officialSafetyMargin + customCorrection - gauge.giw).toFixed(0);
            }
        };

        // Check if a gauge is within the selected journey
        const isInJourney = (gaugeKm) => {
            if (!journey.start || !journey.end) return true;
            return gaugeKm >= Math.min(journey.start, journey.end) && gaugeKm <= Math.max(journey.start, journey.end);
        };

        // Determine travel direction based on journey start and end
        useEffect(() => {
            if (journey.start && journey.end) {
                setTravelDirection(journey.start < journey.end ? 'downstream' : 'upstream');
            }
        }, [journey]);

        // Calculate forecasted bottlenecks
        const [forecastBottlenecks, setForecastBottlenecks] = useState([]);

        useEffect(() => {
            if (!dataLoaded || Object.keys(forecasts).length === 0) return;

            const newForecastBottlenecks = forecastDates.map(date => {
                let criticalGauge = null;
                let minDraft = Infinity;

                gaugeData.forEach(gauge => {
                    if (isInJourney(gauge.km) && gauge.name !== "Konstanz") {
                        const times = Object.keys(forecasts[date]?.[gauge.name] || {});
                        const referenceTime = currentTimes[gauge.name];
                        const selectedTime = times.length > 0 ? getBestForecastTime(times, referenceTime) : '';
                        const forecastValue = forecasts[date]?.[gauge.name]?.[selectedTime];

                        if (forecastValue) {
                            const draft = parseFloat(calculateDraft(gauge.name, forecastValue, travelDirection) || 0);
                            if (!isNaN(draft) && draft < minDraft) {
                                minDraft = draft;
                                criticalGauge = gauge.name;
                            }
                        }
                    }
                });

                return {
                    date,
                    gauge: criticalGauge,
                    draft: criticalGauge && minDraft !== Infinity ? minDraft.toFixed(0) : 'N/A'
                };
            });

            setForecastBottlenecks(newForecastBottlenecks);
        }, [dataLoaded, forecasts, forecastDates, gaugeData, journey, travelDirection, currentTimes, isInJourney]);

        // Find the critical gauge (minimum draft) for the current journey
        const findCriticalGauge = () => {
            if (!dataLoaded) return null;

            let criticalGauge = null;
            let minDraft = Infinity;

            gaugeData.forEach(gauge => {
                // Only include gauges in the journey with valid measurements
                if (isInJourney(gauge.km) &&
                    waterLevels[gauge.name] !== 0 &&
                    currentTimes[gauge.name] !== 'N/A') {

                    const draft = parseFloat(calculateDraft(gauge.name, waterLevels[gauge.name], travelDirection) || 0);
                    if (draft < minDraft) {
                        minDraft = draft;
                        criticalGauge = gauge.name;
                    }
                }
            });

            return criticalGauge;
        };
        const handleJourneyChange = (type, value) => {
            const newJourney = {
                ...journey,
                [type]: value ? parseInt(value, 10) : null
            };

            setJourney(newJourney);

            // Save to cookie whenever journey changes
            setCookie('rhineDraftJourney', newJourney);
        };

        const criticalGauge = findCriticalGauge();
        const criticalDraft = criticalGauge ? calculateDraft(criticalGauge, waterLevels[criticalGauge], travelDirection) : 'N/A';

        return (
            <div className="container">
                <div style={{
                    display: 'flex',
                    flexWrap: 'wrap',
                    justifyContent: 'space-between',
                    alignItems: 'flex-start',
                    padding: '1rem',
                    backgroundColor: '#1e1e1e',
                    gap: '1rem'
                }}>
                    {/* Left side - Header and Controls */}
                    <div style={{flex: '2', minWidth: '400px'}}>
                        <h1 style={{margin: '0 0 1rem 0'}}>Rijn diepgang calculator</h1>

                        <div className="control-group" style={{marginBottom: '1rem'}}>
                            <label>
                                <input
                                    type="checkbox"
                                    checked={autoRefresh}
                                    onChange={(e) => setAutoRefresh(e.target.checked)}
                                />
                                Auto-verversing (10 min)
                            </label>
                            {nextRefreshTime && (
                                <span style={{marginLeft: '8px', fontSize: '0.9em', color: '#aaa'}}>
            Volgende: {nextRefreshTime.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})}
          </span>
                            )}
                        </div>

                        <div style={{display: 'flex', gap: '1rem', flexWrap: 'wrap', marginBottom: '1rem'}}>
                            <div className="control-group">
                                <label>Begin (km):</label>
                                <select
                                    value={journey.start || ''}
                                    onChange={(e) => handleJourneyChange('start', e.target.value)}
                                >
                                    <option value="">Selecteer begin</option>
                                    {gaugeData.map(gauge => (
                                        <option key={`start-${gauge.km}`}
                                                value={gauge.km}>{gauge.km} ({gauge.name})</option>
                                    ))}
                                </select>
                            </div>

                            <div className="control-group">
                                <label>Eind (km):</label>
                                <select
                                    value={journey.end || ''}
                                    onChange={(e) => handleJourneyChange('end', e.target.value)}
                                >
                                    <option value="">Selecteer einde</option>
                                    {gaugeData.map(gauge => (
                                        <option key={`end-${gauge.km}`}
                                                value={gauge.km}>{gauge.km} ({gauge.name})</option>
                                    ))}
                                </select>
                            </div>
                        </div>

                        <div className="control-group">
                            <button className="refresh-btn" onClick={handleRefresh} ref={refreshButtonRef}>
                                Data opnieuw laden
                            </button>
                            <div className={`data-status ${dataStatus.status}`}>
                                {dataStatus.message}
                            </div>
                        </div>
                    </div>

                    {/* Right side - Highlight box */}
                    <div className="highlight-box" style={{
                        flex: '1',
                        minWidth: '300px',
                        maxWidth: '500px',
                        alignSelf: 'flex-start',
                        marginTop: '0'
                    }}>
                        <div style={{marginBottom: '8px', fontWeight: 'bold'}}>Kritieke diepgang:</div>
                        <div style={{marginBottom: '4px'}}>
                            <span style={{display: 'inline-block', width: '70px', paddingRight: '5px'}}>Vandaag:</span>
                            <span style={{display: 'inline-block', width: '75px'}}>{criticalDraft} cm.</span>
                            Strecke: {criticalGauge || 'N/A'}
                        </div>
                        {forecastBottlenecks.map((forecast, index) => {
                            let hourLabel;
                            if (index === 0) {
                                hourLabel = '24h:';
                            } else if (index === 1) {
                                hourLabel = '48h:';
                            } else if (index === 2) {
                                hourLabel = '72h:';
                            } else {
                                // Get the actual forecast time for this date
                                const forecastDate = new Date(forecast.date);
                                const gauge = forecast.gauge;

                                if (gauge && forecasts[forecast.date]?.[gauge]) {
                                    // Get all available forecast times for this gauge and date
                                    const forecastTimes = Object.keys(forecasts[forecast.date][gauge]);

                                    if (forecastTimes.length > 0) {
                                        // Sort the times correctly by converting to minutes
                                        const sortedTimes = forecastTimes.sort((a, b) => {
                                            const [aHours, aMinutes] = a.split(':').map(Number);
                                            const [bHours, bMinutes] = b.split(':').map(Number);
                                            return ((aHours * 60) + aMinutes) - ((bHours * 60) + bMinutes);
                                        });

                                        // Get the latest time instead of earliest time
                                        const latestTime = sortedTimes[sortedTimes.length - 1];

                                        // Set the hours and minutes on the forecast date
                                        const [hours, minutes] = latestTime.split(':').map(Number);
                                        forecastDate.setHours(hours, minutes, 0, 0);
                                    }
                                }

                                // Calculate hours difference directly in hours to avoid timezone issues
                                const currentDate = new Date();

                                // Calculate difference in days and convert to hours
                                const daysDiff = Math.floor((forecastDate - currentDate) / (24 * 60 * 60 * 1000));
                                // Only add +1 day if current time is after 7:00
                                const hoursDiff = (currentDate.getHours() >= 7 ? daysDiff + 1 : daysDiff) * 24;

                                // Add the hours difference within the day
                                const forecastHours = forecastDate.getHours();
                                const currentHours = currentDate.getHours();
                                const hoursDiffToday = forecastHours - currentHours;

                                // Calculate final hours difference
                                const totalHoursDiff = hoursDiff + hoursDiffToday;

                                hourLabel = `${totalHoursDiff}h:`;
                            }

                            return (
                                <div key={`forecast-bottleneck-${forecast.date}`} style={{marginBottom: '4px'}}>
            <span style={{display: 'inline-block', width: '70px', paddingRight: '5px'}}>
              {hourLabel}
            </span>
                                    <span style={{display: 'inline-block', width: '75px'}}>{forecast.draft} cm.</span>
                                    Strecke: {forecast.gauge || 'N/A'}
                                </div>
                            );
                        })}
                    </div>
                </div>

                <div className="main-content">
                    <div style={{overflowX: 'auto'}}>
                        <table>
                            <thead>
                            <tr>
                                <th rowSpan="2">Strecke</th>
                                <th rowSpan="2">Naam</th>
                                <th rowSpan="2" style={{textAlign: 'right'}}>Laatst bekende Waterstand (cm)</th>
                                <th rowSpan="2" style={{textAlign: 'right'}}>Tendens (-24h) (cm)</th>
                                <th rowSpan="2" style={{textAlign: 'right'}}>GIW (cm)</th>
                                <th rowSpan="2" style={{textAlign: 'right'}}>TuGIW (cm)</th>
                                <th rowSpan="2" style={{textAlign: 'right'}}>Officiële vuistregel (cm)</th>
                                <th colSpan="2">Correctie vuistregel (cm)</th>
                                <th colSpan="2">Aangepaste Vuistregel (cm)</th>
                                <th rowSpan="2" style={{textAlign: 'right'}}>
                                    Maximale diepgang
                                </th>

                                {/* Forecast headers */}
                                {forecastDates.map(date => (
                                    <th key={`forecast-${date}`} rowSpan="2" style={{textAlign: 'right'}}>
                                        {new Date(date).toLocaleDateString()}
                                    </th>
                                ))}
                            </tr>
                            <tr>
                                <th style={{textAlign: 'right'}}>Op</th>
                                <th style={{textAlign: 'right'}}>Af</th>
                                <th style={{textAlign: 'right'}}>Op</th>
                                <th style={{textAlign: 'right'}}>Af</th>
                            </tr>
                            </thead>
                            <tbody>
                            {gaugeData.filter(gauge => isInJourney(gauge.km)).map(gauge => {
                                const isCritical = gauge.name === criticalGauge;

                                return (
                                    <tr key={gauge.name} className={isCritical ? 'critical-row' : ''}>
                                        <td>{gauge.streckenAbschnitt}</td>
                                        <td>
                                            <a
                                                href={gauge.name === "Nijmegen"
                                                    ? "https://waterinfo.rws.nl/publiek/waterhoogte/Nijmegen-haven%28NIJM%29/details"
                                                    : gauge.name === "Tiel"
                                                        ? "https://waterinfo.rws.nl/publiek/waterhoogte/Tiel-Waal%28TIEW%29/details"
                                                        : `https://www.elwis.de/DE/dynamisch/Wasserstaende/Pegelvorhersage:${gauge.name.toUpperCase()}`
                                                }
                                                target="_blank"
                                                rel="noopener noreferrer"
                                                style={{
                                                    color: '#4da6ff',
                                                    textDecoration: 'underline',
                                                    cursor: 'pointer',
                                                    display: 'inline-block',
                                                    whiteSpace: 'nowrap'
                                                }}
                                            >
                                                {gauge.name}
                                            </a>
                                        </td>
                                        <td style={{textAlign: 'right'}}>
                                            {waterLevels[gauge.name]}
                                            <div style={{
                                                fontSize: '0.8em',
                                                color: '#aaa',
                                                fontWeight: 'normal',
                                                marginTop: '4px'
                                            }}>
                                                {currentTimes[gauge.name] || 'N/A'}
                                            </div>
                                        </td>
                                        <td style={{textAlign: 'right'}}>{waterTrends[gauge.name]}</td>

                                        {/* GIW value */}
                                        <td style={{textAlign: 'right'}}>
                                            {gauge.name === "Nijmegen" || gauge.name === "Tiel" || gauge.name === "Bingen" || gauge.name === "Iffezheim" || gauge.name === "Konstanz" ? "N/A" : gauge.giw}
                                        </td>

                                        {/* TuGIW value */}
                                        <td style={{textAlign: 'right'}}>
                                            {gauge.name === "Nijmegen" || gauge.name === "Tiel" || gauge.name === "Bingen" || gauge.name === "Iffezheim" || gauge.name === "Konstanz" ? "N/A" : gauge.depthAtGiw}
                                        </td>

                                        {/* Official rule of thumb */}
                                        <td style={{textAlign: 'right'}}>
                                            {gauge.name === "Nijmegen" || gauge.name === "Tiel" || gauge.name === "Bingen" || gauge.name === "Iffezheim" || gauge.name === "Konstanz" ? "N/A" : calculateOfficialRuleOfThumb(gauge)}
                                        </td>

                                        <td style={{textAlign: 'right'}}>
                                            <input
                                                type="number"
                                                value={customCorrections.upstream[gauge.name] || 0}
                                                onChange={(e) => handleCorrectionChange('upstream', gauge.name, e.target.value)}
                                                style={{width: '50px'}}
                                            />
                                        </td>
                                        <td style={{textAlign: 'right'}}>
                                            <input
                                                type="number"
                                                value={customCorrections.downstream[gauge.name] || 0}
                                                onChange={(e) => handleCorrectionChange('downstream', gauge.name, e.target.value)}
                                                style={{width: '50px'}}
                                            />
                                        </td>
                                        <td style={{textAlign: 'right'}}>{calculateCustomRuleOfThumb(gauge, 'upstream')}</td>
                                        <td style={{textAlign: 'right'}}>{calculateCustomRuleOfThumb(gauge, 'downstream')}</td>
                                        <td
                                            style={{textAlign: 'right'}}
                                            className={isCritical ? 'critical-draft' : 'draft-highlight'}
                                        >
                                            {calculateDraft(gauge.name, waterLevels[gauge.name], travelDirection)}
                                            <div style={{fontSize: '0.8em', color: '#aaa'}}>
                                                {currentTimes[gauge.name] || 'N/A'}
                                            </div>
                                        </td>

                                        {/* Forecast columns */}
                                        {forecastDates.map(date => {
                                            const times = Object.keys(forecasts[date]?.[gauge.name] || {});
                                            const referenceTime = currentTimes[gauge.name];
                                            const selectedTime = times.length > 0 ? getBestForecastTime(times, referenceTime) : '';
                                            const forecastValue = forecasts[date]?.[gauge.name]?.[selectedTime];

                                            return (
                                                <td key={`forecast-${gauge.name}-${date}`} style={{textAlign: 'right'}}>
                                                    {forecastValue ? (
                                                        <>
                                                            {calculateDraft(gauge.name, forecastValue, travelDirection)}
                                                            <div style={{fontSize: '0.8em', color: '#aaa'}}>
                                                                {selectedTime ? selectedTime.substring(0, 5) : ''}
                                                            </div>
                                                        </>
                                                    ) : '-'}
                                                </td>
                                            );
                                        })}
                                    </tr>
                                );
                            })}
                            </tbody>
                        </table>
                    </div>
                </div>

                <footer>
                    <div>Waterstanden per: {lastUpdated.toLocaleString()}</div>
                    <div>Rijn diepgang calculator</div>
                </footer>
            </div>
        );
    }

    ReactDOM.render(<RhineDraftCalculator/>, document.getElementById('root'));
</script>
</body>

</html>
