
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <!-- I18N: Title will be set dynamically -->
    <title>Diepgang calculator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.21.2/babel.min.js"></script>
    <style>
        /* --- CSS is unchanged, so it is omitted for brevity --- */
        /* --- Base & Layout (Combined - Using Original Base) --- */
        html, body {
            margin: 0;
            padding: 0;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            color: white;
            background-color: #121212;
            min-height: 150vh; /* Ensure enough scroll height for testing */
        }

        .container {
            display: flex;
            flex-direction: column;
            width: 100%;
            min-height: 100vh;
        }

        /* --- Header Controls Area (Merged: Original Layout + Planner Controls) --- */
        header.controls-area {
            background-color: #1e1e1e;
            padding: 1rem;
            border-bottom: 1px solid #333;
            flex-shrink: 0;
            z-index: 20;
            position: relative;
            min-height: 100px;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: flex-start;
            gap: 1rem;
        }

        .controls-left {
            flex: 2;
            min-width: 400px;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .controls-left > div {
            margin-bottom: 0.5rem;
        }

        .controls-left > div:last-child {
            margin-bottom: 0;
        }

        .controls-right {
            flex: 1;
            min-width: 300px;
            max-width: 500px;
            align-self: flex-start;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .control-group label:not(.day-label):not(.toggle-label) {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            min-width: 120px; /* Slightly wider default */
        }

        select, input, button {
            background-color: #2a2a2a;
            color: white;
            border: 1px solid #444;
            padding: 0.5rem;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        input[type="number"] {
            width: 50px;
            text-align: right;
            padding: 0.4rem;
        }

        input[type="datetime-local"] {
            background-color: #2a2a2a;
            color: white;
            border: 1px solid #444;
            padding: 0.4rem;
            border-radius: 4px;
            font-size: 0.9rem;
            color-scheme: dark;
        }

        input[type="checkbox"], input[type="radio"] {
            width: auto;
            margin-right: 0.3rem;
            accent-color: #4da6ff;
        }

        button {
            cursor: pointer;
        }

        button:hover {
            background-color: #383838;
        }

        .view-toggle-group label {
            margin-right: 1rem;
            cursor: pointer;
            min-width: unset;
        }

        /* Override min-width for toggles */
        .view-toggle-group input[type="radio"] {
            margin-right: 0.3rem;
        }

        /* --- Route Planner Specific Styles --- */
        .planner-settings-group {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            margin-bottom: 1rem;
        }

        .planner-settings-group .control-group {
            align-items: center;
            gap: 0.8rem;
        }

        .planner-settings-group .control-group label:not(.day-label):not(.toggle-label) {
            min-width: 180px;
        }

        .planner-settings-group input[type="number"] {
            width: 60px;
        }

        .excluded-days-group {
            display: flex;
            gap: 0.8rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .excluded-days-group label.day-label {
            min-width: 40px;
        }

        .now-button {
            padding: 0.4rem 0.6rem;
            font-size: 0.8rem;
            margin-left: 0.3rem;
            background-color: #444;
        }

        .now-button:hover {
            background-color: #555;
        }

        .planner-calculate-btn {
            background-color: #0080ff;
            font-weight: bold;
            padding: 0.6rem 1.2rem;
        }
        .planner-calculate-btn:hover {
             background-color: #0070e0;
        }

        .planner-calculate-btn:disabled {
            background-color: #444;
            cursor: not-allowed;
        }

        .route-plan-results {
            margin-top: 1.5rem;
            padding: 1rem;
            background-color: #1e1e1e;
            border: 1px solid #333;
            border-radius: 4px;
        }

        .route-plan-summary {
            margin-bottom: 1rem;
            font-size: 1.1em;
        }

        .route-plan-summary strong {
            color: #4da6ff;
        }

        .mgd-warning {
            color: #ffcc00;
            background-color: rgba(255, 204, 0, 0.1);
            border: 1px solid #cc9900;
            padding: 0.5rem;
            border-radius: 4px;
            margin-top: 0.5rem;
            font-size: 0.9em;
        }

        /* --- Main Content Area (Original) --- */
        .main-content {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            padding: 0;
        }

        /* --- Tab Controls (Original) --- */
        .tab-controls {
            margin-bottom: 1rem;
            border-bottom: 1px solid #333;
            padding: 1rem 1rem 0.5rem 1rem;
            background-color: #121212; /* Match body */
            flex-shrink: 0;
            position: relative; /* Keep stacking context */
            z-index: 15; /* Below controls, above table */
        }

        .tab-button {
            background-color: #2a2a2a;
            border: 1px solid #444;
            padding: 0.5rem 1rem;
            margin-right: 0.5rem;
            border-radius: 4px 4px 0 0;
            cursor: pointer;
        }

        .tab-button.active {
            background-color: #3a3a3a;
            border-bottom: 1px solid #3a3a3a;
            font-weight: bold;
        }

        .tab-button:disabled {
            background-color: #222;
            color: #666;
            cursor: not-allowed;
            border-color: #333;
        }

        /* --- Table Area Structures (Original) --- */
        .table-area-padding {
            padding: 0 1rem 1rem 1rem; /* Apply padding here */
            width: 100%;
            box-sizing: border-box;
            flex-grow: 1; /* Allow it to take space */
            display: flex; /* Use flex to make wrapper fill it */
            flex-direction: column; /* Stack sentinel and wrapper */
        }

        .header-sentinel {
            height: 1px; /* Trigger for IntersectionObserver */
            flex-shrink: 0;
        }

        .table-scroll-wrapper {
            overflow-x: auto; /* Handle horizontal scroll */
            overflow-y: visible; /* Allow content height to determine wrapper height */
            width: 100%; /* Take full width of the padding container */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            flex-grow: 1; /* Take remaining space */
            display: block; /* Needed for overflow to work correctly with flex parent */
            flex-shrink: 0; /* Prevent shrinking */
        }

        /* --- Original Table (Styles from FIRST block - DESIRED STATE) --- */
        /* These apply unless overridden by .route-plan-results above */
        table.original-table {
            width: 100%;
            border-collapse: collapse;
            border-spacing: 0;
            background-color: #1a1a1a; /* Table background */
            table-layout: fixed; /* KEY: Use fixed layout */
        }

        /* Original Table Header / Visibility (from FIRST block) */
        .original-table > thead {
            visibility: visible; /* Default state */
        }

        .original-table > thead.hidden {
            visibility: hidden !important; /* Hide when fixed header is active */
        }

        /* Original Header Cells (thead th) - Base Styles (from FIRST block) */
        .original-table > thead th {
            background-color: #1e1e1e; /* Header background */
            border-bottom: 1px solid #555;
            padding: 0.6rem 0.4rem; /* <<< CHANGED: Increased vertical padding for wrapping */
            text-align: left;
            white-space: normal; /* <<< CHANGED: Allow text to wrap */
            overflow: visible;
            text-overflow: clip;
            border-left: 1px solid #333;
            vertical-align: middle;
            font-size: 0.8rem;
            font-weight: bold;
            line-height: 1.3; /* <<< CHANGED: Increased for better multi-line readability */
        }

        .original-table > thead th:first-child {
            border-left: none;
        }

        .original-table > thead th.numeric {
            text-align: right;
        }

        .original-table > thead th.center {
            text-align: center;
        }

        .original-table > thead tr:first-child th {
            border-top: 1px solid #555;
        }

        /* --- Define Column Width Variables & Font Sizes --- */
        :root {
            /* Default width (Original) */
            --col-default-width: 60px;

            /* Column-specific widths (FROM FIRST BLOCK - DESIRED ORIGINAL STATE) */
            --col-1-width: 80px; /* Rivier */
            --col-2-width: 90px; /* Strecke */
            --col-3-width: 95px; /* Naam */
            --col-4-width: 45px; /* GIW */
            --col-5-width: 45px; /* TuGIW */
            --col-6-width: 45px; /* Waarde Actueel */
            --col-7-width: 45px; /* Tendens */
            --col-8-width: 65px; /* Off. Vuist */
            --col-9-width: 150px; /* Correctie Op (Original Wider Value) */
            --col-10-width: 100px; /* Correctie Af (Original Wider Value) */
            --col-11-width: 65px; /* Aang. Vuist Op */
            --col-12-width: 45px; /* Aang. Vuist Af */
            --col-13-width: 100px; /* Diepgang/Waarde Actueel */
            --forecast-width: 45px; /* Forecast Columns */

            /* NEW: Font size for table body cells */
            --table-body-font-size: 0.9rem; /* Adjust this value easily */

            /* Route Plan Table Widths */
            --rp-col-km-width: 50px;
            --rp-col-name-width: 100px;
            --rp-col-eta-width: 140px;
            --rp-col-level-width: 70px;
            --rp-col-offset-width: 65px; /* Offset Column */
            /* NEW: Width for Corrected Rule column */
            --rp-col-rule-width: 75px;
            --rp-col-draft-width: 90px;
            --rp-col-notes-width: 120px;
        }

        /* Original Body Cells (tbody td) - Base Styles */
        .original-table > tbody td {
            padding: 0.5rem 0.4rem; /* Original reduced padding */
            text-align: left;
            border-bottom: 1px solid #333;
            white-space: normal; /* Allow wrapping */
            border-left: 1px solid #333;
            vertical-align: middle;
            /* USE VARIABLE: Apply the font size variable */
            font-size: var(--table-body-font-size);
            line-height: 1.3; /* Original line height */
        }

        .original-table > tbody td:first-child {
            border-left: none;
        }

        .original-table > tbody td.numeric {
            text-align: right;
        }

        .original-table > tbody td.center {
            text-align: center;
        }

        .original-table > tbody tr:hover td {
            background-color: #2a2a2a;
        }

        /* --- Default Column Settings (Original) --- */
        /* Applies to Max Draft/All tabs via .original-table, unless overridden by .route-plan-results */
        .original-table > thead th,
        .original-table > tbody td {
            min-width: var(--col-default-width);
            width: auto; /* Let specific widths below take precedence */
        }

        /* --- Column Width Definitions (Applied to ORIGINAL table - From FIRST block) --- */
        /* Column 1 - Rivier */
        .original-table > thead th:nth-child(1), .original-table > tbody td:nth-child(1) {
            min-width: var(--col-1-width);
            width: var(--col-1-width);
            max-width: var(--col-1-width);
        }

        /* Column 2 - Strecke */
        .original-table > thead th:nth-child(2), .original-table > tbody td:nth-child(2) {
            min-width: var(--col-2-width);
            width: var(--col-2-width);
            max-width: var(--col-2-width);
        }

        /* Column 3 - Naam */
        .original-table > thead th:nth-child(3), .original-table > tbody td:nth-child(3) {
            min-width: var(--col-3-width);
            width: var(--col-3-width);
            max-width: var(--col-3-width);
        }

        /* Column 4 - GIW */
        .original-table > thead th:nth-child(4), .original-table > tbody td:nth-child(4) {
            min-width: var(--col-4-width);
            width: var(--col-4-width);
        }

        /* Column 5 - TuGIW */
        .original-table > thead th:nth-child(5), .original-table > tbody td:nth-child(5) {
            min-width: var(--col-5-width);
            width: var(--col-5-width);
        }

        /* Column 6 - Waarde Actueel */
        .original-table > thead th:nth-child(6), .original-table > tbody td:nth-child(6) {
            min-width: var(--col-6-width);
            width: var(--col-6-width);
        }

        /* Column 7 - Tendens */
        .original-table > thead th:nth-child(7), .original-table > tbody td:nth-child(7) {
            min-width: var(--col-7-width);
            width: var(--col-7-width);
        }

        /* Column 8 - Off. Vuist */
        .original-table > thead th:nth-child(8), .original-table > tbody td:nth-child(8) {
            min-width: var(--col-8-width);
            width: var(--col-8-width);
            max-width: var(--col-8-width);
        }

        /* Column 9 - Correctie Op */
        .original-table > thead th:nth-child(9), .original-table > tbody td:nth-child(9) {
            min-width: var(--col-9-width);
            width: var(--col-9-width);
            max-width: var(--col-9-width);
        }

        /* Column 10 - Correctie Af */
        .original-table > thead th:nth-child(10), .original-table > tbody td:nth-child(10) {
            min-width: var(--col-10-width);
            width: var(--col-10-width);
            max-width: var(--col-10-width);
        }

        /* Column 11 - Aang. Vuist Op */
        .original-table > thead th:nth-child(11), .original-table > tbody td:nth-child(11) {
            min-width: var(--col-11-width);
            width: var(--col-11-width);
            max-width: var(--col-11-width);
        }

        /* Column 12 - Aang. Vuist Af */
        .original-table > thead th:nth-child(12), .original-table > tbody td:nth-child(12) {
            min-width: var(--col-12-width);
            width: var(--col-12-width);
            max-width: var(--col-12-width);
        }

        /* Column 13 - Diepgang/Waarde Actueel */
        .original-table > thead th:nth-child(13), .original-table > tbody td:nth-child(13) {
            min-width: var(--col-13-width);
            width: var(--col-13-width);
            max-width: var(--col-13-width);
        }

        /* Forecast Columns */
        .original-table > thead th.forecast-header, .original-table > tbody td.forecast-cell {
            min-width: var(--forecast-width);
            width: var(--forecast-width);
        }

        /* Optional: Text handling for certain original columns */
        .original-table > tbody td:nth-child(11),
        .original-table > tbody td:nth-child(12) {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* --- Column Width Definitions (Route Plan Table - Specific overrides) --- */
        /* Applied ONLY within the .route-plan-results context */
        /* NOTE: nth-child indexes are shifted after adding the new column */
        .route-plan-results .original-table th:nth-child(1), .route-plan-results .original-table td:nth-child(1) {
            width: var(--rp-col-km-width);
            min-width: var(--rp-col-km-width);
            max-width: none;
            text-align: right;
        }

        /* KM */
        .route-plan-results .original-table th:nth-child(2), .route-plan-results .original-table td:nth-child(2) {
            width: var(--rp-col-name-width);
            min-width: var(--rp-col-name-width);
            max-width: none;
            text-align: left;
        }

        /* Naam */
        .route-plan-results .original-table th:nth-child(3), .route-plan-results .original-table td:nth-child(3) {
            width: var(--rp-col-eta-width);
            min-width: var(--rp-col-eta-width);
            max-width: none;
            text-align: left;
        }

        /* ETA */
        .route-plan-results .original-table th:nth-child(4), .route-plan-results .original-table td:nth-child(4) {
            width: var(--rp-col-level-width);
            min-width: var(--rp-col-level-width);
            max-width: none;
            text-align: right;
        }

        /* Forecast Level */
        .route-plan-results .original-table th:nth-child(5), .route-plan-results .original-table td:nth-child(5) {
            width: var(--rp-col-offset-width);
            min-width: var(--rp-col-offset-width);
            max-width: none;
            text-align: right;
        }

        /* Offset */
        /* NEW: Corrected Rule Column (index 6) */
        .route-plan-results .original-table th:nth-child(6), .route-plan-results .original-table td:nth-child(6) {
            width: var(--rp-col-rule-width);
            min-width: var(--rp-col-rule-width);
            max-width: none;
            text-align: right;
        }

        /* Corrected Rule */
        /* SHIFTED: Max Draft Column (now index 7) */
        .route-plan-results .original-table th:nth-child(7), .route-plan-results .original-table td:nth-child(7) {
            width: var(--rp-col-draft-width);
            min-width: var(--rp-col-draft-width);
            max-width: none;
            text-align: right;
        }

        /* Max Draft */
        /* SHIFTED: Notes Column (now index 8) */
        .route-plan-results .original-table th:nth-child(8), .route-plan-results .original-table td:nth-child(8) {
            width: var(--rp-col-notes-width);
            min-width: var(--rp-col-notes-width);
            max-width: none;
            font-size: 0.8em;
            color: #aaa;
            text-align: left;
        }

        /* Notes */
        /* Reset any further columns in planner results if they exist (unlikely) */
        .route-plan-results .original-table th:nth-child(n+9),
        .route-plan-results .original-table td:nth-child(n+9) {
            width: auto;
            min-width: var(--col-default-width);
            max-width: none;
        }

        /* Styles for table *inside* planner results (overrides general styles) */
        .route-plan-results .original-table th,
        .route-plan-results .original-table td {
            /* USE VARIABLE: Apply the font size variable here too */
            font-size: var(--table-body-font-size);
            padding: 0.4rem 0.5rem;
        }

        .route-plan-results .original-table .critical-route-point td {
            background-color: rgba(255, 100, 100, 0.2) !important;
            font-weight: bold;
        }

        .route-plan-results .original-table .eta-time {
            font-size: 0.9em;
            color: #ccc;
        }

        .route-plan-results .original-table .offset-value {
            font-style: italic;
            color: #bbb;
            font-size: 0.9em;
        }

        /* Ensure specific alignments for planner table body cells (adjusting indexes) */
        .route-plan-results .original-table > tbody td:nth-child(1), /* KM */
        .route-plan-results .original-table > tbody td:nth-child(4), /* Level */
        .route-plan-results .original-table > tbody td:nth-child(5), /* Offset */
            /* NEW: Corrected Rule Alignment */
        .route-plan-results .original-table > tbody td:nth-child(6), /* Corrected Rule */
            /* SHIFTED: Max Draft Alignment */
        .route-plan-results .original-table > tbody td:nth-child(7) /* Max Draft */
        {
            text-align: right;
        }

        /* Left aligned columns */
        .route-plan-results .original-table > tbody td:nth-child(2), /* Name */
        .route-plan-results .original-table > tbody td:nth-child(3), /* ETA */
            /* SHIFTED: Notes Alignment */
        .route-plan-results .original-table > tbody td:nth-child(8) /* Notes */
        {
            text-align: left;
        }

        /* Scroll wrapper for planner table */
        .route-plan-results .table-scroll-wrapper {
            /* INCREASED HEIGHT: Use vh for better responsiveness */
            max-height: 600px; /* Adjust as needed */
            overflow-y: auto;
            /* Add horizontal scroll too */
            overflow-x: auto;
        }


        /* --- Fixed Header Clone Container (Styles from FIRST block) --- */
        .fixed-header-container {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 100;
            overflow: hidden;
            visibility: hidden;
            background-color: #1e1e1e;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            /* width will be set by JS */
        }

        .fixed-header-container.visible {
            visibility: visible;
        }

        .fixed-header-container table {
            table-layout: fixed; /* <<< KEY */
            border-collapse: collapse;
            border-spacing: 0;
            background-color: transparent;
            width: 100%;
        }

        /* Cloned Header Cells - Mirror Original Styles (from FIRST block) */
        .fixed-header-container th {
            background-color: #1e1e1e;
            border-bottom: 1px solid #555;
            padding: 0.6rem 0.4rem; /* <<< CHANGED: Increased vertical padding */
            text-align: left;
            white-space: normal; /* <<< CHANGED: Allow text to wrap */
            overflow: visible;
            text-overflow: clip;
            border-left: 1px solid #333;
            vertical-align: middle;
            font-size: 0.8rem;
            font-weight: bold;
            line-height: 1.3; /* <<< CHANGED: Increased line height */
            border-top: none;
        }

        .fixed-header-container th:first-child {
            border-left: none;
        }

        .fixed-header-container th.numeric {
            text-align: right;
        }

        .fixed-header-container th.center {
            text-align: center;
        }

        .fixed-header-container thead tr:first-child th {
            border-top: 1px solid #555;
        }

        /* Add top border like original */

        /* Apply ORIGINAL table widths to fixed header (from FIRST block) */
        .fixed-header-container th:nth-child(1) {
            min-width: var(--col-1-width);
            width: var(--col-1-width);
            max-width: var(--col-1-width);
        }

        .fixed-header-container th:nth-child(2) {
            min-width: var(--col-2-width);
            width: var(--col-2-width);
            max-width: var(--col-2-width);
        }

        .fixed-header-container th:nth-child(3) {
            min-width: var(--col-3-width);
            width: var(--col-3-width);
            max-width: var(--col-3-width);
        }

        .fixed-header-container th:nth-child(4) {
            min-width: var(--col-4-width);
            width: var(--col-4-width);
        }

        .fixed-header-container th:nth-child(5) {
            min-width: var(--col-5-width);
            width: var(--col-5-width);
        }

        .fixed-header-container th:nth-child(6) {
            min-width: var(--col-6-width);
            width: var(--col-6-width);
        }

        .fixed-header-container th:nth-child(7) {
            min-width: var(--col-7-width);
            width: var(--col-7-width);
        }

        .fixed-header-container th:nth-child(8) {
            min-width: var(--col-8-width);
            width: var(--col-8-width);
            max-width: var(--col-8-width);
        }

        .fixed-header-container th:nth-child(9) {
            min-width: var(--col-9-width);
            width: var(--col-9-width);
            max-width: var(--col-9-width);
        }

        /* Uses original wider var */
        .fixed-header-container th:nth-child(10) {
            min-width: var(--col-10-width);
            width: var(--col-10-width);
            max-width: var(--col-10-width);
        }

        /* Uses original wider var */
        .fixed-header-container th:nth-child(11) {
            min-width: var(--col-11-width);
            width: var(--col-11-width);
            max-width: var(--col-11-width);
        }

        .fixed-header-container th:nth-child(12) {
            min-width: var(--col-12-width);
            width: var(--col-12-width);
            max-width: var(--col-12-width);
        }

        .fixed-header-container th:nth-child(13) {
            min-width: var(--col-13-width);
            width: var(--col-13-width);
            max-width: var(--col-13-width);
        }

        .fixed-header-container th.forecast-header {
            min-width: var(--forecast-width);
            width: var(--forecast-width);
        }


        /* --- Highlights & Cell Content Styling (Merged) --- */
        .critical-row td {
            background-color: rgba(255, 0, 0, 0.2) !important;
        }

        .critical-draft {
            font-weight: bold;
            color: #ff6666;
        }

        .critical-level {
            font-weight: bold;
            color: #ffb3b3;
        }

        .actual-draft-column {
            font-weight: bold;
        }
        .actual-tonnage-column {
            font-weight: bold;
            color: #adebeb;
        }

        .critical-actual-draft {
            font-weight: bold;
            color: #ff4d4d;
        }

        .critical-actual-level {
            font-weight: bold;
            color: #ff9999;
        }

        .forecast-cell div {
            line-height: 1.2;
        }

        .uncertainty-display {
            font-size: 0.75em;
            color: #aaa;
            margin-top: 2px;
            display: block;
        }

        .time-display {
            font-size: 0.75em;
            color: #aaa;
            font-weight: normal;
            margin-top: 3px;
            display: block;
            line-height: 1.1;
        }

        .time-display.weekly {
            font-style: italic;
            color: #ccc;
        }

        .time-display.current {
            font-style: italic;
            color: #8f8;
        }

        /* Style for 'Actueel' */
        .gauge-link {
            color: #4da6ff;
            text-decoration: none;
        }

        .gauge-link:hover {
            text-decoration: underline;
        }

        /* --- Footer & Misc (Merged) --- */
        footer {
            background-color: #1e1e1e;
            padding: 0.8rem 1rem;
            font-size: 0.8rem;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid #333;
            flex-shrink: 0;
            margin-top: auto;
        }

        .highlight-box {
            background-color: #cc9900;
            border-radius: 4px;
            padding: 0.5rem 1rem;
            color: black;
            font-weight: bold;
            border: 1px solid #997300;
        }

        .highlight-box div {
            margin-bottom: 3px;
            line-height: 1.3;
        }

        .highlight-box span.label {
            display: inline-block;
            min-width: 60px;
            padding-right: 5px;
            font-size: 0.9em;
        }

        .highlight-box span.value {
            display: inline-block;
            min-width: 55px;
            font-size: 0.9em;
        }

        .highlight-box span.gauge {
            font-size: 0.8em;
            color: #333;
            margin-left: 4px;
        }

        .highlight-box span.time {
            font-size: 0.75em;
            color: #555;
            margin-left: 4px;
        }

        .highlight-box .forecast-uncertainty {
            font-size: 0.8em;
            color: #333;
            font-weight: normal;
            display: inline-block;
            vertical-align: baseline;
            margin-left: 4px;
            margin-top: 0;
            margin-bottom: 0;
        }

        .data-status {
            padding: 0.4rem 0.8rem;
            background-color: #333;
            border-radius: 4px;
            font-size: 0.8rem;
            border-left: 4px solid #555;
            display: inline-block;
            margin-left: 0.5rem;
        }

        .data-status.pending {
            background-color: #444;
            border-left-color: #aaa;
        }

        .data-status.success {
            background-color: #004d00;
            border-left-color: #00cc66;
        }

        .data-status.warning {
            background-color: #665200;
            border-left-color: #ffcc00;
        }

        .data-status.error {
            background-color: #660000;
            border-left-color: #ff6666;
        }

        .refresh-btn {
            background-color: #0066cc;
            padding: 0.4rem 0.8rem;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .refresh-btn:hover {
            background-color: #0055aa;
        }

        .refresh-btn:disabled {
            background-color: #444;
            cursor: not-allowed;
        }

        /* --- NEW: Cargo Capacity Tab Styles --- */
        .cargo-controls {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-bottom: 1.5rem;
            padding: 1rem;
            background-color: #1e1e1e;
            border: 1px solid #333;
            border-radius: 4px;
        }
        .cargo-controls .control-group label {
            min-width: 150px;
        }
        .cargo-controls-button {
            padding: 0.4rem 0.8rem;
            font-size: 0.85rem;
            margin-left: 0.5rem;
        }
        .ship-category-filter {
            display: flex;
            gap: 0.5rem;
        }
        .ship-category-filter button {
            background-color: #2a2a2a;
            border: 1px solid #444;
            padding: 0.5rem 1rem;
        }
        .ship-category-filter button.active {
            background-color: #4da6ff;
            color: black;
            font-weight: bold;
            border-color: #4da6ff;
        }

        .ship-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .ship-category-group h4 {
            margin-top: 1rem;
            margin-bottom: 0.8rem;
            border-bottom: 1px solid #444;
            padding-bottom: 0.5rem;
            color: #bbb;
        }

        .ship-card {
            background-color: #242424;
            border: 1px solid #3a3a3a;
            border-left: 5px solid #4da6ff;
            border-radius: 4px;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .ship-card.is-tanker {
             border-left-color: #cc33ff;
        }
        .ship-card.disallowed {
            background-color: #2b2525;
            border-left-color: #aa0000;
            opacity: 0.7;
        }
        .ship-card.disallowed .ship-name {
            text-decoration: line-through;
            color: #aaa;
        }
        .ship-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .ship-name {
            font-size: 1.1rem;
            font-weight: bold;
            margin: 0;
        }
        .ship-details {
            font-size: 0.85rem;
            color: #aaa;
        }
        .ship-loading-info {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }
        .loading-bar-container {
            width: 100%;
            height: 20px;
            background-color: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            overflow: hidden;
        }
        .loading-bar {
            height: 100%;
            background-color: #0080ff;
            transition: width 0.3s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.8rem;
            white-space: nowrap;
        }
        .loading-bar.over-100 {
             background-color: #ff9900; /* Orange for exceeding ship's max draft */
        }
        .loading-bar.below-min-draft {
             background-color: #ff4d4d; /* Red bar for below min draft */
        }
        .loading-text {
            font-size: 0.9rem;
            color: #ddd;
        }
        .loading-warning {
            font-size: 0.85rem;
            color: #ffcc00; /* Changed to warning color */
            margin-top: 0.25rem;
        }
        .ship-constraints {
            font-size: 0.85rem;
            color: #ffcc00;
            background-color: rgba(255, 204, 0, 0.1);
            border: 1px solid #cc9900;
            padding: 0.5rem;
            border-radius: 4px;
            margin-top: 0.5rem;
        }
        .ship-card.disallowed .ship-constraints {
            color: #ff8888;
            background-color: rgba(255, 100, 100, 0.1);
            border-color: #cc0000;
        }
        .ship-constraints ul {
            margin: 0;
            padding-left: 1.2rem;
        }
        .add-ship-btn {
            background-color: #00802b;
            font-weight: bold;
        }
        .add-ship-btn:hover {
            background-color: #006622;
        }
        .custom-ship-list {
            margin-top: 1rem;
        }
        .custom-ship-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background-color: #222;
            border-radius: 4px;
            margin-bottom: 0.5rem;
            font-size: 0.9em;
        }
        .delete-ship-btn {
            background-color: #aa0000;
            padding: 0.3rem 0.6rem;
            font-size: 0.8rem;
        }
        .delete-ship-btn:hover {
             background-color: #880000;
        }

        /* --- NEW: Custom Ship Modal Styles --- */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.7);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background-color: #1e1e1e;
            padding: 1.5rem;
            border-radius: 8px;
            border: 1px solid #444;
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #333;
            padding-bottom: 0.8rem;
        }
        .modal-header h3 {
            margin: 0;
        }
        .modal-close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            line-height: 1;
            padding: 0 0.5rem;
            cursor: pointer;
            color: #aaa;
        }
        .modal-close-btn:hover {
            color: white;
            background: none;
        }
        .modal-form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .modal-form-group label {
            font-weight: bold;
            font-size: 0.9em;
        }
        .modal-form-group input, .modal-form-group select {
            width: 100%;
            box-sizing: border-box;
        }
        .modal-form-group .control-group { /* For inline items like points */
            gap: 1rem;
        }
        .modal-form-group .control-group input {
            width: 100px;
        }
        .modal-form-points-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .modal-form-point-item button {
             background-color: #660000;
             padding: 0.3rem 0.6rem;
             font-size: 0.8rem;
        }
         .modal-form-point-item button:hover {
              background-color: #440000;
         }
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
            border-top: 1px solid #333;
            padding-top: 1rem;
            margin-top: 1rem;
        }
        .modal-footer button {
            padding: 0.6rem 1.2rem;
        }
        .modal-footer .save-btn {
            background-color: #0080ff;
            font-weight: bold;
        }
        .modal-footer .save-btn:hover {
            background-color: #0070e0;
        }
        .modal-footer .save-btn:disabled {
            background-color: #444;
            cursor: not-allowed;
        }
        .modal-footer .cancel-btn {
            background-color: #555;
        }
        .modal-footer .cancel-btn:hover {
            background-color: #666;
        }
    </style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
    const {useState, useEffect, useCallback, useRef, useMemo, createContext, useContext} = React;

    // --- I18N: Omitted for Brevity as requested ---
    const translations = {
    "nl": {
        "appTitle": "Diepgang Calculator",
        "language_multilingual": "Taal / Language / Sprache / Langue / Язык",
        "autoRefresh": "Automatisch vernieuwen",
        "nextRefresh": "Volgende",
        "language": "Taal",
        "contextRiver": "Context / Rivier",
        "allRivers": "Alle Rivieren",
        "journey": "Reis",
        "selectStart": "Selecteer start",
        "selectEnd": "Selecteer eind",
        "to": "naar",
        "displayMode": "Weergavemodus",
        "displayModeDraft": "Diepgang",
        "displayModeLevel": "Waterstand (ruw)",
        "displayModeTonnage": "Tonnage",
        "selectRefShip": "Selecteer Ref. Schip",
        "showUncertainty": "Toon Voorspellingsonzekerheid",
        "reloadData": "Gegevens Herladen",
        "loading": "Laden...",
        "apiTime": "API-tijd",
        "initializing": "Initialiseren...",
        "loadingStatic": "Laden statische peilschaaldefinities...",
        "staticLoaded": "Statische data geladen.",
        "fetchingData": "Ophalen van gegevens van API...",
        "dataUpdated": "Gegevens bijgewerkt ({successfulUpdates}/{apiGaugeCount} API-bronnen)",
        "updateError": "Fout bij bijwerken ({errorCount} mislukt). Eerste: {firstError}",
        "updateWarning": "Gedeeltelijk bijgewerkt ({warningCount} waarschuwingen). Eerste: {firstWarning}",
        "loadError": "Fout bij laden: {errorMessage}",
        "criticalDraftTitle": "Kritische diepgang ({direction})",
        "directionUp": "Opvaart",
        "directionDown": "Afvaart",
        "directionMixed": "op/afvaart",
        "now": "Nu",
        "forecast": "Voorspelling",
        "noCriticalForecast": "Geen kritische voorspelling gevonden",
        "noForecastsAvailable": "Geen voorspellingsdata beschikbaar",
        "loadingForecasts": "Voorspellingen laden...",
        "tabMaxDraft": "Max Diepgang (Reis)",
        "tabPlanner": "Routeplanner",
        "tabCargo": "Ladingscapaciteit",
        "tabAllData": "Alle Gegevens",
        "headerRiver": "Rivier",
        "headerSection": "Traject",
        "headerName": "Naam",
        "headerValue": "Waarde",
        "headerTrend": "Trend",
        "headerOfficialRule": "Off. Vuistr.",
        "headerCorrection": "Correctie (cm)",
        "headerUp": "Op",
        "headerDown": "Af",
        "headerAdjRule": "Aang. Vuistr.",
        "headerActualDraft": "Diepgang",
        "headerActualLevel": "Waarde",
        "headerActualTonnage": "Tonnage",
        "headerUnitCm": "(cm)",
        "headerUnitActual": "(Act., cm)",
        "headerUnitTons": "(Act., T)",
        "headerForecastValue": "({mode}, cm)",
        "headerForecastValueTons": "({mode}, T)",
        "noForecasts": "Geen Voorspellingen",
        "noDataForSelection": "Selecteer een geldige reis of geen gegevens beschikbaar voor de reis.",
        "noApiData": "Geen API-data geladen.",
        "noDataForFilter": "Geen gegevens gevonden voor het geselecteerde filter.",
        "plannerSettingsTitle": "Routeplanner Instellingen",
        "departureTime": "Vertrek Datum/Tijd",
        "speedDownstream": "Snelheid Afvaart (km/u)",
        "speedUpstream": "Snelheid Opvaart (km/u)",
        "speedCanal": "Gem. Snelheid Main/RMD (km/u)",
        "speedCanalHint": "(Van Mainz naar Kelheim)",
        "system": "Systeem",
        "systemA1": "A1 (14 uur/dag)",
        "systemA2": "A2 (18 uur/dag)",
        "systemB": "B (24 uur/dag)",
        "systemCustom": "Aangepast",
        "hoursPerDay": "uur/dag",
        "excludedDays": "Uitgesloten Dagen",
        "showUncertaintyPlanner": "Toon Voorspellingsonzekerheid",
        "ifAvailable": "(Indien beschikbaar)",
        "calculateMaxDraft": "Bereken Maximale Diepgang",
        "calculating": "Berekenen...",
        "plannerResultTitle": "Routeplan Resultaat",
        "maxPossibleDraft": "Maximaal Mogelijke Diepgang",
        "limitedBy": "Beperkt door",
        "mgdWarningText": "WAARSCHUWING: De berekende diepgang van {calculatedDraft} cm overschrijdt de MGD voor {mgdName} ({mgdDraft} cm). Varen met deze diepgang is op eigen risico.",
        "canalLimitReason": "(boven) Main (max 250 cm)",
        "routeDetails": "Routedetails",
        "plannerHeaderKm": "KM",
        "plannerHeaderName": "Naam",
        "plannerHeaderEta": "ETA",
        "plannerHeaderForecastLevel": "Vrsp. Peil (cm)",
        "plannerHeaderOffset": "Offset (cm)",
        "plannerHeaderAdjRule": "Aang. Vuistr. (cm)",
        "plannerHeaderMaxDraft": "Max Diepgang (cm)",
        "plannerHeaderNotes": "Notities",
        "noRoutePoints": "Geen routepunten berekend (mogelijk geen voorspellingen beschikbaar voor ETA's).",
        "notesNoDataForEta": "Geen data voor ETA",
        "notesWeeklyForecast": "Wekelijkse vrsp.",
        "notesCurrentLevel": "Huidig",
        "footerApiDate": "Data API per",
        "notLoadedYet": "Nog niet geladen",
        "optionalSegment": "Optioneel Extra Segment",
        "extraDistance": "Extra Afstand (km)",
        "extraSpeed": "Snelheid Extra Segment (km/u)",
        "extraPosition": "Positie Extra Segment",
        "posAfter": "Na de berekende route",
        "posBefore": "Voor de berekende route",
        "posHint": "(Voegt tijd toe aan begin/eind ETA)",
        "errorInvalidDate": "Ongeldige startdatum/tijd.",
        "errorNoRoute": "Selecteer een start- en eindpunt.",
        "errorInvalidSpeed": "Snelheden moeten groter dan 0 zijn.",
        "errorInvalidHours": "Ongeldige aangepaste uren (1-24).",
        "errorNoPath": "Geen route gevonden tussen {start} en {end}. Controleer of er een logische verbinding bestaat.",
        "errorCustomSegmentSpeed": "Snelheid voor extra segment moet groter dan 0 zijn als afstand is ingevoerd.",
        "calculationError": "Fout bij berekening: {error}",
        "cargoInputDraft": "Beschikbare Diepgang (m)",
        "useCriticalDraft": "Gebruik Huidige Kritische Diepgang",
        "usePlannerDraft": "Gebruik Kritische Diepgang Planner",
        "shipFilterCategory": "Filter Categorie",
        "categoryAll": "Alle",
        "categoryDryCargo": "Droge Lading",
        "categoryTanker": "Tankers",
        "addCustomShip": "Voeg Aangepast Schip Toe",
        "manageCustomShips": "Beheer Aangepaste Schepen",
        "customShipDeleted": "Aangepast schip '{name}' verwijderd.",
        "crew": "Bemanning",
        "loadingWarningMinDraft": "Beschikbare diepgang is lager dan de minimale diepgang van het schip van {min_draft}m.",
        "loadingWarningMDKDraft": "Waarschuwing: Ingediende diepgang van {input_draft}m overschrijdt de 2,50m limiet op de Main.",
        "notAllowedOnRoute": "Niet toegestaan op deze route:",
        "warnings": "Waarschuwingen:",
        "constraintShipTooWideMDK": "Schip overschrijdt max afmetingen voor Main-Donaukanaal (135/190x11.45m).",
        "constraintHofkirchenUnknown": "Peil Hofkirchen onbekend, brede konvooien (>135x22,90m) mogelijk niet toegestaan.",
        "constraintHofkirchenLow": "Konvooi (>135x22,90m) niet toegestaan, peil Hofkirchen < 350cm (huidig: {currentLevel}cm).",
        "constraintRhenusOnDanube": "Rhenus Koppelverband is niet geschikt voor Main/Donau.",
        "constraintShipTooWideBingen": "Schip te breed voor traject Bingen-St.Goar (>17.70m).",
        "constraintLobithUnknown": "Peil Lobith onbekend, 6-baks konvooi mogelijk niet toegestaan.",
        "constraintLobithLow": "6-baks konvooi niet toegestaan, peil Lobith < 750cm (huidig: {currentLevel}cm).",
        "constraintWideUpstream": "Brede konvooien (>22.90m) alleen toegestaan in de afvaart tussen Karlsruhe-Lorch.",
        "constraintKaubUnknown": "Peil Kaub onbekend, reis met breedte >22.90m mogelijk niet toegestaan.",
        "constraintKaubLow": "Reis met breedte >22.90m niet toegestaan (St.Goar-Gorinchem), peil Kaub < 120cm (huidig: {currentLevel}cm).",
        "constraintShipTooLargeIJssel": "Schip overschrijdt max afmetingen voor IJssel (110x11.45m).",
        "constraint6BargeUpstream": "6-baks konvooi alleen toegestaan afvarend van Bad Salzig (km 564.30).",
        "modalTitleAddShip": "Voeg een Aangepast Schip Toe",
        "modalShipName": "Scheepsnaam",
        "modalCreationMethod": "Aanmaakmethode",
        "modalMethodTpc": "TPC (Ton per cm)",
        "modalMethodPoints": "Diepgang/Tonnage Punten",
        "modalMethodInherit": "Erf Curve + 1 Punt",
        "modalEmptyDraft": "Lege Diepgang (m)",
        "modalTpc": "Ton per Centimeter",
        "modalAddPoint": "Punt Toevoegen",
        "modalDraft": "Diepgang (m)",
        "modalTonnage": "Tonnage (T)",
        "modalBaseShip": "Basisschip voor Curve",
        "modalSave": "Schip Opslaan",
        "modalCancel": "Annuleren",
        "modalErrorName": "Scheepsnaam is verplicht.",
        "modalErrorTpc": "TPC en Lege Diepgang moeten positieve getallen zijn.",
        "modalErrorPoints": "Minstens twee datapunten zijn vereist.",
        "modalErrorInherit": "Basisschip en een geldig datapunt zijn vereist.",
        "constraintRhenusTooLongMDK": "Waarschuwing: Rhenus konvooi ({length}m) is {overage}m langer dan 190m MDK-limiet.",
        "constraintRuhrortUnknown": "Peil Duisburg-Ruhrort onbekend, breed konvooi (>22.90m) mogelijk niet toegestaan.",
        "constraintRuhrortLow": "Breed konvooi (>22.90m) niet toegestaan, peil Duisburg-Ruhrort < 210cm (huidig: {currentLevel}cm).",
        "constraintLobithLowWide": "Breed konvooi (>22.90m) niet toegestaan, peil Lobith < 750cm (huidig: {currentLevel}cm).",
        "shipDescWideExtraLongGMS": "Breed Extra lang GMS",
        "shipDescExtraLongGMSLightweight": "Extra lang GMS, lichtgewicht",
        "shipDescExtraLongGMSHeavy": "Extra lang GMS, zwaar",
        "shipDescGMSSunriseShallow": "GMS type Sunrise laagwater",
        "shipDescGMSStandard": "GMS standaard type",
        "shipDescGMSCDSShallow": "GMS CDS droge lading laagwater",
        "shipDescJowiContainer": "JOWI (container)",
        "shipDescEuropeSunriseShallow": "Europaschip type Sunrise laagwater",
        "shipDescEuropeStandard": "Europaschip standaard type",
        "shipDescDortmunder": "Dortmunder",
        "shipDescDortmunderExtended": "Dortmunder verlengd",
        "shipDescElbeConvoy": "Elbe Konvooi",
        "shipDescGMSEcoNomyShallow": "GMS type ECO-NOMY laagwater",
        "shipDescStoltLudwigshafenShallow": "Stolt Ludwigshafen, laagwater",
        "shipDescCoupledConvoyRhineDanube": "Koppelverband Rijn/Donau",
        "shipDescCoupledConvoyMosel": "Koppelverband Moezel",
        "shipDescRhenus1BargeShallow": "Koppelverband Rhenus (1 bak), Rijn laagwater",
        "shipDescRhenus3BargeShallow": "Koppelverband Rhenus (3 bak), Rijn laagwater",
        "shipDescSomtransLNG": "Somtrans LNG (schatting)",
        "comboNamePushedDanube1": "Duwkonvooi Donau (1 bak)",
        "comboNamePushedDanube2": "Duwkonvooi Donau (2 bakken)",
        "comboNamePushedDanube4": "Duwkonvooi Donau (4 bakken)",
        "comboNamePushedDanube6": "Duwkonvooi Donau (6 bakken)",
        "comboNamePushedRhine4": "Duwkonvooi Rijn (4 bakken)",
        "comboNamePushedRhine6": "Duwkonvooi Rijn (6 bakken)",
        "comboNameJohannaPlus2": "Koppelverband Rijn/Donau + 2 Rijn bakken",
        "comboNameAnimoPlus2": "Extra lang GMS, zwaar + 2 Rijn bakken",
        "comboNameTanker1": "Tankerkonvooi (1 bak)",
        "comboNameTanker2": "Tankerkonvooi (2 bakken)",
        "comboNameTanker4": "Tankerkonvooi (4 bakken)",
        "comboNameTanker6": "Tankerkonvooi (6 bakken)",
            "constraintDanubeKelheimRegensburg": "Schip overschrijdt max afmetingen voor Donau-traject Kelheim-Regensburg (190/135x11.45m).",
        "constraintDanubeDownstreamStraubingVilshofen": "Schip overschrijdt afvaart-afmetingen voor Straubing-Vilshofen (max 190x11.45 of 135x22.90m).",
        "constraintDanubeRegensburgPassauWide": "Schip overschrijdt max afmetingen voor dit Donau-traject (190x22.90m).",
},
    "en": {
        "appTitle": "Draft Calculator",
        "language_multilingual": "Language / Taal / Sprache / Langue / Язык",
        "autoRefresh": "Auto-refresh",
        "nextRefresh": "Next",
        "language": "Language",
        "contextRiver": "Context / River",
        "allRivers": "All Rivers",
        "journey": "Journey",
        "selectStart": "Select start",
        "selectEnd": "Select end",
        "to": "to",
        "displayMode": "Display Mode",
        "displayModeDraft": "Draft",
        "displayModeLevel": "Water Level (raw)",
        "displayModeTonnage": "Tonnage",
        "selectRefShip": "Select Ref. Ship",
        "showUncertainty": "Show Forecast Uncertainty",
        "reloadData": "Reload Data",
        "loading": "Loading...",
        "apiTime": "API time",
        "initializing": "Initializing...",
        "loadingStatic": "Loading static gauge definitions...",
        "staticLoaded": "Static data loaded.",
        "fetchingData": "Fetching data from API...",
        "dataUpdated": "Data updated ({successfulUpdates}/{apiGaugeCount} API sources)",
        "updateError": "Error updating ({errorCount} failed). First: {firstError}",
        "updateWarning": "Partially updated ({warningCount} warnings). First: {firstWarning}",
        "loadError": "Error loading: {errorMessage}",
        "criticalDraftTitle": "Critical draft ({direction})",
        "directionUp": "Upstream",
        "directionDown": "Downstream",
        "directionMixed": "up/down",
        "now": "Now",
        "forecast": "Forecast",
        "noCriticalForecast": "No critical forecast found",
        "noForecastsAvailable": "No forecast data available",
        "loadingForecasts": "Loading forecasts...",
        "tabMaxDraft": "Max Draft (Journey)",
        "tabPlanner": "Route Planner",
        "tabCargo": "Cargo Capacity",
        "tabAllData": "All Data",
        "headerRiver": "River",
        "headerSection": "Section",
        "headerName": "Name",
        "headerValue": "Value",
        "headerTrend": "Trend",
        "headerOfficialRule": "Off. Rule",
        "headerCorrection": "Correction (cm)",
        "headerUp": "Up",
        "headerDown": "Down",
        "headerAdjRule": "Adj. Rule",
        "headerActualDraft": "Draft",
        "headerActualLevel": "Value",
        "headerActualTonnage": "Tonnage",
        "headerUnitCm": "(cm)",
        "headerUnitActual": "(Act., cm)",
        "headerUnitTons": "(Act., T)",
        "headerForecastValue": "({mode}, cm)",
        "headerForecastValueTons": "({mode}, T)",
        "noForecasts": "No Forecasts",
        "noDataForSelection": "Select a valid journey or no data available for journey.",
        "noApiData": "No API data loaded.",
        "noDataForFilter": "No data found for the selected filter.",
        "plannerSettingsTitle": "Route Planner Settings",
        "departureTime": "Departure Date/Time",
        "speedDownstream": "Speed Downstream (km/h)",
        "speedUpstream": "Speed Upstream (km/h)",
        "speedCanal": "Avg. Speed Main/RMD (km/h)",
        "speedCanalHint": "(From Mainz to Kelheim)",
        "system": "System",
        "systemA1": "A1 (14 hours/day)",
        "systemA2": "A2 (18 hours/day)",
        "systemB": "B (24 hours/day)",
        "systemCustom": "Custom",
        "hoursPerDay": "hours/day",
        "excludedDays": "Excluded Days",
        "showUncertaintyPlanner": "Show Forecast Uncertainty",
        "ifAvailable": "(If available)",
        "calculateMaxDraft": "Calculate Maximum Draft",
        "calculating": "Calculating...",
        "plannerResultTitle": "Route Plan Result",
        "maxPossibleDraft": "Maximum Possible Draft",
        "limitedBy": "Limited by",
        "mgdWarningText": "WARNING: The calculated draft of {calculatedDraft} cm exceeds the MGD for {mgdName} ({mgdDraft} cm). Sailing at this draft is at your own risk.",
        "canalLimitReason": "(upper) Main (max 250 cm)",
        "routeDetails": "Route Details",
        "plannerHeaderKm": "KM",
        "plannerHeaderName": "Name",
        "plannerHeaderEta": "ETA",
        "plannerHeaderForecastLevel": "Fcst. Level (cm)",
        "plannerHeaderOffset": "Offset (cm)",
        "plannerHeaderAdjRule": "Adj. Rule (cm)",
        "plannerHeaderMaxDraft": "Max Draft (cm)",
        "plannerHeaderNotes": "Notes",
        "noRoutePoints": "No route points calculated (possibly no forecasts available for ETAs).",
        "notesNoDataForEta": "No data for ETA",
        "notesWeeklyForecast": "Weekly fcst.",
        "notesCurrentLevel": "Current",
        "footerApiDate": "Data API as of",
        "notLoadedYet": "Not loaded yet",
        "optionalSegment": "Optional Extra Segment",
        "extraDistance": "Extra Distance (km)",
        "extraSpeed": "Speed Extra Segment (km/h)",
        "extraPosition": "Position Extra Segment",
        "posAfter": "After calculated route",
        "posBefore": "Before calculated route",
        "posHint": "(Adds time to start/end ETA)",
        "errorInvalidDate": "Invalid start date/time.",
        "errorNoRoute": "Please select a start and end point.",
        "errorInvalidSpeed": "Speeds must be greater than 0.",
        "errorInvalidHours": "Invalid custom hours (1-24).",
        "errorNoPath": "No route found between {start} and {end}. Check if a logical connection exists.",
        "errorCustomSegmentSpeed": "Speed for extra segment must be greater than 0 if distance is entered.",
        "calculationError": "Error calculating: {error}",
        "cargoInputDraft": "Available Draft (m)",
        "useCriticalDraft": "Use Current Critical Draft",
        "usePlannerDraft": "Use Planner Critical Draft",
        "shipFilterCategory": "Filter Category",
        "categoryAll": "All",
        "categoryDryCargo": "Dry Cargo",
        "categoryTanker": "Tankers",
        "addCustomShip": "Add Custom Ship",
        "manageCustomShips": "Manage Custom Ships",
        "customShipDeleted": "Custom ship '{name}' deleted.",
        "crew": "Crew",
        "loadingWarningMinDraft": "Available draft is below ship's minimum draft of {min_draft}m.",
        "loadingWarningMDKDraft": "Warning: Input draft of {input_draft}m exceeds 2.50m limit on Main river.",
        "notAllowedOnRoute": "Not allowed on this route:",
        "warnings": "Warnings:",
        "constraintShipTooWideMDK": "Ship exceeds max dimensions for Main-Danube Canal (135/190x11.45m).",
        "constraintHofkirchenUnknown": "Hofkirchen gauge level unknown, wide convoys (>135x22,90m) might not be allowed.",
        "constraintHofkirchenLow": "Convoy (>135x22,90m) not allowed, Hofkirchen level < 350cm (current: {currentLevel}cm).",
        "constraintRhenusOnDanube": "Rhenus Koppelverband is not suitable for Main/Danube.",
        "constraintShipTooWideBingen": "Ship too wide for Bingen-St.Goar section (>17.70m).",
        "constraintLobithUnknown": "Lobith gauge level unknown, 6-barge convoy might not be allowed.",
        "constraintLobithLow": "6-barge convoy not allowed, Lobith level < 750cm (current: {currentLevel}cm).",
        "constraintWideUpstream": "Wide convoys (>22.90m) only allowed downstream between Karlsruhe-Lorch.",
        "constraintKaubUnknown": "Kaub gauge level unknown, voyage with width >22.90m might not be allowed.",
        "constraintKaubLow": "Voyage with width >22.90m not allowed (St.Goar-Gorinchem), Kaub level < 120cm (current: {currentLevel}cm).",
        "constraintShipTooLargeIJssel": "Ship exceeds max dimensions for IJssel (110x11.45m).",
        "constraint6BargeUpstream": "6-barge convoy only allowed downstream of Bad Salzig (km 564.30).",
        "modalTitleAddShip": "Add a Custom Ship",
        "modalShipName": "Ship Name",
        "modalCreationMethod": "Creation Method",
        "modalMethodTpc": "TPC (Tons per cm)",
        "modalMethodPoints": "Draft/Tonnage Points",
        "modalMethodInherit": "Inherit Curve + 1 Point",
        "modalEmptyDraft": "Empty Draft (m)",
        "modalTpc": "Tons per Centimeter",
        "modalAddPoint": "Add Point",
        "modalDraft": "Draft (m)",
        "modalTonnage": "Tonnage (T)",
        "modalBaseShip": "Base Ship for Curve",
        "modalSave": "Save Ship",
        "modalCancel": "Cancel",
        "modalErrorName": "Ship name is required.",
        "modalErrorTpc": "TPC and Empty Draft must be positive numbers.",
        "modalErrorPoints": "At least two data points are required.",
        "modalErrorInherit": "Base ship and a valid data point are required.",
        "constraintRhenusTooLongMDK": "Warning: Rhenus convoy ({length}m) is {overage}m longer than 190m MDK limit.",
        "constraintRuhrortUnknown": "Duisburg-Ruhrort gauge level unknown, wide convoy (>22.90m) might not be allowed.",
        "constraintRuhrortLow": "Wide convoy (>22.90m) not allowed, Duisburg-Ruhrort level < 210cm (current: {currentLevel}cm).",
        "constraintLobithLowWide": "Wide convoy (>22.90m) not allowed, Lobith level < 750cm (current: {currentLevel}cm).",
        "shipDescWideExtraLongGMS": "Wide Extra long GMS",
        "shipDescExtraLongGMSLightweight": "Extra long GMS, lightweight",
        "shipDescExtraLongGMSHeavy": "Extra long GMS, heavy",
        "shipDescGMSSunriseShallow": "GMS type Sunrise shallow water",
        "shipDescGMSStandard": "GMS standard type",
        "shipDescGMSCDSShallow": "GMS CDS dry cargo shallow water",
        "shipDescJowiContainer": "JOWI (container)",
        "shipDescEuropeSunriseShallow": "Europe vessel type Sunrise shallow water",
        "shipDescEuropeStandard": "Europe vessel type standard",
        "shipDescDortmunder": "Dortmunder",
        "shipDescDortmunderExtended": "Dortmunder extended",
        "shipDescElbeConvoy": "Elbe Convoy",
        "shipDescGMSEcoNomyShallow": "GMS type ECO-NOMY shallow water",
        "shipDescStoltLudwigshafenShallow": "Stolt Ludwigshafen, shallow water",
        "shipDescCoupledConvoyRhineDanube": "Coupled convoy Rhine/Danube",
        "shipDescCoupledConvoyMosel": "Coupled Convoy Mosel",
        "shipDescRhenus1BargeShallow": "Coupled convoy Rhenus (1 barge), Rhine shallow water",
        "shipDescRhenus3BargeShallow": "Coupled convoy Rhenus (3 barge), Rhine shallow water",
        "shipDescSomtransLNG": "Somtrans LNG (est.)",
        "comboNamePushedDanube1": "Pushed Convoy Danube (1 barge)",
        "comboNamePushedDanube2": "Pushed Convoy Danube (2 barges)",
        "comboNamePushedDanube4": "Pushed Convoy Danube (4 barges)",
        "comboNamePushedDanube6": "Pushed Convoy Danube (6 barges)",
        "comboNamePushedRhine4": "Pushed Convoy Rhine (4 barges)",
        "comboNamePushedRhine6": "Pushed Convoy Rhine (6 barges)",
        "comboNameJohannaPlus2": "Coupled convoy Rhine/Danube + 2 Rhine Barges",
        "comboNameAnimoPlus2": "Extra long GMS, heavy + 2 Rhine Barges",
        "comboNameTanker1": "Tanker convoy (1 barge)",
        "comboNameTanker2": "Tanker convoy (2 barges)",
        "comboNameTanker4": "Tanker convoy (4 barges)",
        "comboNameTanker6": "Tanker convoy (6 barges)",
            "constraintDanubeKelheimRegensburg": "Ship exceeds max dimensions for Danube section Kelheim-Regensburg (190/135x11.45m).",
        "constraintDanubeDownstreamStraubingVilshofen": "Ship exceeds downstream dimension limits for Straubing-Vilshofen (max 190x11.45 or 135x22.90m).",
        "constraintDanubeRegensburgPassauWide": "Ship exceeds max dimensions for this Danube section (190x22.90m).",
},
    "de": {
        "appTitle": "Tiefgangsrechner",
        "language_multilingual": "Sprache / Language / Taal / Langue / Язык",
        "autoRefresh": "Automatische Aktualisierung",
        "nextRefresh": "Nächste",
        "language": "Sprache",
        "contextRiver": "Kontext / Fluss",
        "allRivers": "Alle Flüsse",
        "journey": "Reise",
        "selectStart": "Start wählen",
        "selectEnd": "Ziel wählen",
        "to": "nach",
        "displayMode": "Anzeigemodus",
        "displayModeDraft": "Tiefgang",
        "displayModeLevel": "Wasserstand (roh)",
        "displayModeTonnage": "Tonnage",
        "selectRefShip": "Ref.-Schiff wählen",
        "showUncertainty": "Vorhersage-Unsicherheit anzeigen",
        "reloadData": "Daten neu laden",
        "loading": "Laden...",
        "apiTime": "API-Zeit",
        "initializing": "Initialisiere...",
        "loadingStatic": "Lade statische Pegeldefinitionen...",
        "staticLoaded": "Statische Daten geladen.",
        "fetchingData": "Daten von API abrufen...",
        "dataUpdated": "Daten aktualisiert ({successfulUpdates}/{apiGaugeCount} API-Quellen)",
        "updateError": "Fehler bei Aktualisierung ({errorCount} fehlgeschlagen). Erster: {firstError}",
        "updateWarning": "Teilweise aktualisiert ({warningCount} Warnungen). Erste: {firstWarning}",
        "loadError": "Fehler beim Laden: {errorMessage}",
        "criticalDraftTitle": "Kritischer Tiefgang ({direction})",
        "directionUp": "Bergfahrt",
        "directionDown": "Talfahrt",
        "directionMixed": "Berg/Talfahrt",
        "now": "Jetzt",
        "forecast": "Vorhersage",
        "noCriticalForecast": "Keine kritische Vorhersage gefunden",
        "noForecastsAvailable": "Keine Vorhersagedaten verfügbar",
        "loadingForecasts": "Lade Vorhersagen...",
        "tabMaxDraft": "Max. Tiefgang (Reise)",
        "tabPlanner": "Routenplaner",
        "tabCargo": "Ladekapazität",
        "tabAllData": "Alle Daten",
        "headerRiver": "Fluss",
        "headerSection": "Abschnitt",
        "headerName": "Name",
        "headerValue": "Wert",
        "headerTrend": "Tendenz",
        "headerOfficialRule": "Off. Faustr.",
        "headerCorrection": "Korrektur (cm)",
        "headerUp": "Berg",
        "headerDown": "Tal",
        "headerAdjRule": "Ang. Faustr.",
        "headerActualDraft": "Tiefgang",
        "headerActualLevel": "Wert",
        "headerActualTonnage": "Tonnage",
        "headerUnitCm": "(cm)",
        "headerUnitActual": "(Akt., cm)",
        "headerUnitTons": "(Akt., T)",
        "headerForecastValue": "({mode}, cm)",
        "headerForecastValueTons": "({mode}, T)",
        "noForecasts": "Keine Vorhersagen",
        "noDataForSelection": "Wählen Sie eine gültige Reise oder keine Daten für die Reise verfügbar.",
        "noApiData": "Keine API-Daten geladen.",
        "noDataForFilter": "Keine Daten für den gewählten Filter gefunden.",
        "plannerSettingsTitle": "Routenplaner-Einstellungen",
        "departureTime": "Abfahrtsdatum/Zeit",
        "speedDownstream": "Geschw. Talfahrt (km/h)",
        "speedUpstream": "Geschw. Bergfahrt (km/h)",
        "speedCanal": "Durchschn. Geschw. Main/MDK (km/h)",
        "speedCanalHint": "(Von Mainz bis Kelheim)",
        "system": "Betriebsform",
        "systemA1": "A1 (14 Stunden/Tag)",
        "systemA2": "A2 (18 Stunden/Tag)",
        "systemB": "B (24 Stunden/Tag)",
        "systemCustom": "Benutzerdefiniert",
        "hoursPerDay": "Stunden/Tag",
        "excludedDays": "Ausgeschlossene Tage",
        "showUncertaintyPlanner": "Vorhersage-Unsicherheit anzeigen",
        "ifAvailable": "(Falls verfügbar)",
        "calculateMaxDraft": "Maximalen Tiefgang berechnen",
        "calculating": "Berechne...",
        "plannerResultTitle": "Routenplan-Ergebnis",
        "maxPossibleDraft": "Maximal möglicher Tiefgang",
        "limitedBy": "Begrenzt durch",
        "mgdWarningText": "WARNUNG: Der berechnete Tiefgang von {calculatedDraft} cm überschreitet den MGD für {mgdName} ({mgdDraft} cm). Die Fahrt mit diesem Tiefgang erfolgt auf eigenes Risiko.",
        "canalLimitReason": "(oberer) Main (max 250 cm)",
        "routeDetails": "Routendetails",
        "plannerHeaderKm": "KM",
        "plannerHeaderName": "Name",
        "plannerHeaderEta": "Ank.-Zeit",
        "plannerHeaderForecastLevel": "Vorh. Pegel (cm)",
        "plannerHeaderOffset": "Offset (cm)",
        "plannerHeaderAdjRule": "Ang. Faustr. (cm)",
        "plannerHeaderMaxDraft": "Max Tiefg. (cm)",
        "plannerHeaderNotes": "Anmerkungen",
        "noRoutePoints": "Keine Routenpunkte berechnet (möglicherweise keine Vorhersagen für Ankunftszeiten verfügbar).",
        "notesNoDataForEta": "Keine Daten für Ank.-Zeit",
        "notesWeeklyForecast": "Wöchentl. Vorh.",
        "notesCurrentLevel": "Aktuell",
        "footerApiDate": "API-Daten vom",
        "notLoadedYet": "Noch nicht geladen",
        "optionalSegment": "Optionales Zusatzsegment",
        "extraDistance": "Zusätzliche Distanz (km)",
        "extraSpeed": "Geschw. Zusatzsegment (km/h)",
        "extraPosition": "Position Zusatzsegment",
        "posAfter": "Nach berechneter Route",
        "posBefore": "Vor berechneter Route",
        "posHint": "(Fügt Zeit zur Start/End-Ankunftszeit hinzu)",
        "errorInvalidDate": "Ungültiges Startdatum/-zeit.",
        "errorNoRoute": "Bitte Start- und Endpunkt auswählen.",
        "errorInvalidSpeed": "Geschwindigkeiten müssen größer als 0 sein.",
        "errorInvalidHours": "Ungültige benutzerdefinierte Stunden (1-24).",
        "errorNoPath": "Keine Route zwischen {start} und {end} gefunden. Prüfen Sie, ob eine logische Verbindung besteht.",
        "errorCustomSegmentSpeed": "Geschwindigkeit für Zusatzsegment muss > 0 sein, wenn Distanz eingegeben wird.",
        "calculationError": "Fehler bei Berechnung: {error}",
        "cargoInputDraft": "Verfügbarer Tiefgang (m)",
        "useCriticalDraft": "Akt. krit. Tiefgang verwenden",
        "usePlannerDraft": "Krit. Tiefgang d. Planers verw.",
        "shipFilterCategory": "Kategorie filtern",
        "categoryAll": "Alle",
        "categoryDryCargo": "Trockenfrachter",
        "categoryTanker": "Tanker",
        "addCustomShip": "Eigenes Schiff hinzufügen",
        "manageCustomShips": "Eigene Schiffe verwalten",
        "customShipDeleted": "Eigenes Schiff '{name}' gelöscht.",
        "crew": "Besatzung",
        "loadingWarningMinDraft": "Verfügbarer Tiefgang liegt unter dem Mindesttiefgang des Schiffes von {min_draft}m.",
        "loadingWarningMDKDraft": "Warnung: Eingegebener Tiefgang von {input_draft}m überschreitet 2,50m-Limit auf dem Main.",
        "notAllowedOnRoute": "Auf dieser Route nicht erlaubt:",
        "warnings": "Warnungen:",
        "constraintShipTooWideMDK": "Schiff überschreitet max. Abmessungen für Main-Donau-Kanal (135/190x11.45m).",
        "constraintHofkirchenUnknown": "Pegel Hofkirchen unbekannt, breite Verbände (>135x22,90m) evtl. nicht erlaubt.",
        "constraintHofkirchenLow": "Verband (>135x22,90m) nicht erlaubt, Pegel Hofkirchen < 350cm (aktuell: {currentLevel}cm).",
        "constraintRhenusOnDanube": "Rhenus Koppelverband ist nicht für Main/Donau geeignet.",
        "constraintShipTooWideBingen": "Schiff zu breit für Strecke Bingen-St.Goar (>17.70m).",
        "constraintLobithUnknown": "Pegel Lobith unbekannt, 6-Leichter-Verband evtl. nicht erlaubt.",
        "constraintLobithLow": "6-Leichter-Verband nicht erlaubt, Pegel Lobith < 750cm (aktuell: {currentLevel}cm).",
        "constraintWideUpstream": "Breite Verbände (>22.90m) nur in Talfahrt zwischen Karlsruhe-Lorch erlaubt.",
        "constraintKaubUnknown": "Pegel Kaub unbekannt, Fahrt mit Breite >22.90m evtl. nicht erlaubt.",
        "constraintKaubLow": "Fahrt mit Breite >22.90m nicht erlaubt (St.Goar-Gorinchem), Pegel Kaub < 120cm (aktuell: {currentLevel}cm).",
        "constraintShipTooLargeIJssel": "Schiff überschreitet max. Abmessungen für IJssel (110x11.45m).",
        "constraint6BargeUpstream": "6-Leichter-Verband nur talwärts von Bad Salzig (km 564.30) erlaubt.",
        "modalTitleAddShip": "Eigenes Schiff hinzufügen",
        "modalShipName": "Schiffsname",
        "modalCreationMethod": "Erstellungsmethode",
        "modalMethodTpc": "TPC (Tonnen pro cm)",
        "modalMethodPoints": "Tiefgangs-/Tonnage-Punkte",
        "modalMethodInherit": "Kurve erben + 1 Punkt",
        "modalEmptyDraft": "Leertiefgang (m)",
        "modalTpc": "Tonnen pro Zentimeter",
        "modalAddPoint": "Punkt hinzufügen",
        "modalDraft": "Tiefgang (m)",
        "modalTonnage": "Tonnage (T)",
        "modalBaseShip": "Basisschiff für Kurve",
        "modalSave": "Schiff speichern",
        "modalCancel": "Abbrechen",
        "modalErrorName": "Schiffsname ist erforderlich.",
        "modalErrorTpc": "TPC und Leertiefgang müssen positive Zahlen sein.",
        "modalErrorPoints": "Mindestens zwei Datenpunkte sind erforderlich.",
        "modalErrorInherit": "Basisschiff und ein gültiger Datenpunkt sind erforderlich.",
        "constraintRhenusTooLongMDK": "Warnung: Rhenus Verband ({length}m) ist {overage}m länger als 190m MDK-Limit.",
        "constraintRuhrortUnknown": "Pegel Duisburg-Ruhrort unbekannt, breiter Verband (>22.90m) evtl. nicht erlaubt.",
        "constraintRuhrortLow": "Breiter Verband (>22.90m) nicht erlaubt, Pegel Duisburg-Ruhrort < 210cm (aktuell: {currentLevel}cm).",
        "constraintLobithLowWide": "Breiter Verband (>22.90m) nicht erlaubt, Pegel Lobith < 750cm (aktuell: {currentLevel}cm).",
        "shipDescWideExtraLongGMS": "Breites Extra langes GMS",
        "shipDescExtraLongGMSLightweight": "Extra langes GMS, leicht",
        "shipDescExtraLongGMSHeavy": "Extra langes GMS, schwer",
        "shipDescGMSSunriseShallow": "GMS Typ Sunrise Niedrigwasser",
        "shipDescGMSStandard": "GMS Standardtyp",
        "shipDescGMSCDSShallow": "GMS CDS Trockenfrachter Niedrigwasser",
        "shipDescJowiContainer": "JOWI (Container)",
        "shipDescEuropeSunriseShallow": "Europaschiff Typ Sunrise Niedrigwasser",
        "shipDescEuropeStandard": "Europaschiff Standardtyp",
        "shipDescDortmunder": "Dortmunder",
        "shipDescDortmunderExtended": "Dortmunder verlängert",
        "shipDescElbeConvoy": "Elbe Verband",
        "shipDescGMSEcoNomyShallow": "GMS Typ ECO-NOMY Niedrigwasser",
        "shipDescStoltLudwigshafenShallow": "Stolt Ludwigshafen, Niedrigwasser",
        "shipDescCoupledConvoyRhineDanube": "Koppelverband Rhein/Donau",
        "shipDescCoupledConvoyMosel": "Koppelverband Mosel",
        "shipDescRhenus1BargeShallow": "Koppelverband Rhenus (1 Leichter), Rhein Niedrigwasser",
        "shipDescRhenus3BargeShallow": "Koppelverband Rhenus (3 Leichter), Rhein Niedrigwasser",
        "shipDescSomtransLNG": "Somtrans LNG (geschätzt)",
        "comboNamePushedDanube1": "Schubverband Donau (1 Leichter)",
        "comboNamePushedDanube2": "Schubverband Donau (2 Leichter)",
        "comboNamePushedDanube4": "Schubverband Donau (4 Leichter)",
        "comboNamePushedDanube6": "Schubverband Donau (6 Leichter)",
        "comboNamePushedRhine4": "Schubverband Rhein (4 Leichter)",
        "comboNamePushedRhine6": "Schubverband Rhein (6 Leichter)",
        "comboNameJohannaPlus2": "Koppelverband Rhein/Donau + 2 Rhein Leichter",
        "comboNameAnimoPlus2": "Extra langes GMS, schwer + 2 Rhein Leichter",
        "comboNameTanker1": "Tanker-Verband (1 Leichter)",
        "comboNameTanker2": "Tanker-Verband (2 Leichter)",
        "comboNameTanker4": "Tanker-Verband (4 Leichter)",
        "comboNameTanker6": "Tanker-Verband (6 Leichter)",
            "constraintDanubeKelheimRegensburg": "Schiff überschreitet max. Abmessungen für Donauabschnitt Kelheim-Regensburg (190/135x11.45m).",
        "constraintDanubeDownstreamStraubingVilshofen": "Schiff überschreitet Abmessungen für Talfahrt auf Straubing-Vilshofen (max 190x11.45 oder 135x22.90m).",
        "constraintDanubeRegensburgPassauWide": "Schiff überschreitet max. Abmessungen für diesen Donauabschnitt (190x22.90m).",
},
    "fr": {
        "appTitle": "Calculateur de Tirant d'eau",
        "language_multilingual": "Langue / Language / Taal / Sprache / Язык",
        "autoRefresh": "Actualisation auto",
        "nextRefresh": "Prochaine",
        "language": "Langue",
        "contextRiver": "Contexte / Fleuve",
        "allRivers": "Tous les Fleuves",
        "journey": "Trajet",
        "selectStart": "Choisir départ",
        "selectEnd": "Choisir arrivée",
        "to": "vers",
        "displayMode": "Mode d'affichage",
        "displayModeDraft": "Tirant d'eau",
        "displayModeLevel": "Niveau d'eau (brut)",
        "displayModeTonnage": "Tonnage",
        "selectRefShip": "Choisir Bateau Réf.",
        "showUncertainty": "Afficher l'incertitude de prévision",
        "reloadData": "Recharger les Données",
        "loading": "Chargement...",
        "apiTime": "Heure API",
        "initializing": "Initialisation...",
        "loadingStatic": "Chargement des définitions de jauge statiques...",
        "staticLoaded": "Données statiques chargées.",
        "fetchingData": "Récupération des données de l'API...",
        "dataUpdated": "Données mises à jour ({successfulUpdates}/{apiGaugeCount} sources API)",
        "updateError": "Erreur de mise à jour ({errorCount} échecs). Premier: {firstError}",
        "updateWarning": "Partiellement mis à jour ({warningCount} avertissements). Premier: {firstWarning}",
        "loadError": "Erreur de chargement: {errorMessage}",
        "criticalDraftTitle": "Tirant d'eau critique ({direction})",
        "directionUp": "Amont",
        "directionDown": "Aval",
        "directionMixed": "amont/aval",
        "now": "Maintenant",
        "forecast": "Prévision",
        "noCriticalForecast": "Aucune prévision critique trouvée",
        "noForecastsAvailable": "Aucune donnée de prévision disponible",
        "loadingForecasts": "Chargement des prévisions...",
        "tabMaxDraft": "Tirant d'eau Max (Trajet)",
        "tabPlanner": "Planificateur d'Itinéraire",
        "tabCargo": "Capacité de Chargement",
        "tabAllData": "Toutes les Données",
        "headerRiver": "Fleuve",
        "headerSection": "Section",
        "headerName": "Nom",
        "headerValue": "Valeur",
        "headerTrend": "Tendance",
        "headerOfficialRule": "Règle off.",
        "headerCorrection": "Correction (cm)",
        "headerUp": "Amont",
        "headerDown": "Aval",
        "headerAdjRule": "Règle ajus.",
        "headerActualDraft": "Tirant d'eau",
        "headerActualLevel": "Valeur",
        "headerActualTonnage": "Tonnage",
        "headerUnitCm": "(cm)",
        "headerUnitActual": "(Act., cm)",
        "headerUnitTons": "(Act., T)",
        "headerForecastValue": "({mode}, cm)",
        "headerForecastValueTons": "({mode}, T)",
        "noForecasts": "Aucune Prévision",
        "noDataForSelection": "Sélectionnez un trajet valide ou aucune donnée disponible pour le trajet.",
        "noApiData": "Aucune donnée API chargée.",
        "noDataForFilter": "Aucune donnée trouvée pour le filtre sélectionné.",
        "plannerSettingsTitle": "Paramètres du Planificateur d'Itinéraire",
        "departureTime": "Date/Heure de Départ",
        "speedDownstream": "Vitesse Aval (km/h)",
        "speedUpstream": "Vitesse Amont (km/h)",
        "speedCanal": "Vit. moy. Main/RMD (km/h)",
        "speedCanalHint": "(De Mayence à Kelheim)",
        "system": "Système",
        "systemA1": "A1 (14 heures/jour)",
        "systemA2": "A2 (18 heures/jour)",
        "systemB": "B (24 heures/jour)",
        "systemCustom": "Personnalisé",
        "hoursPerDay": "heures/jour",
        "excludedDays": "Jours Exclus",
        "showUncertaintyPlanner": "Afficher l'incertitude de prévision",
        "ifAvailable": "(Si disponible)",
        "calculateMaxDraft": "Calculer le Tirant d'eau Maximum",
        "calculating": "Calcul en cours...",
        "plannerResultTitle": "Résultat du Plan d'Itinéraire",
        "maxPossibleDraft": "Tirant d'eau Maximum Possible",
        "limitedBy": "Limité par",
        "mgdWarningText": "AVERTISSEMENT: Le tirant d'eau calculé de {calculatedDraft} cm dépasse le MGD pour {mgdName} ({mgdDraft} cm). Naviguer à ce tirant d'eau est à vos propres risques.",
        "canalLimitReason": "Main (supérieur) (max 250 cm)",
        "routeDetails": "Détails de l'itinéraire",
        "plannerHeaderKm": "KM",
        "plannerHeaderName": "Nom",
        "plannerHeaderEta": "HPA",
        "plannerHeaderForecastLevel": "Niv. Prévu (cm)",
        "plannerHeaderOffset": "Décalage (cm)",
        "plannerHeaderAdjRule": "Règle ajus. (cm)",
        "plannerHeaderMaxDraft": "T.E. Max (cm)",
        "plannerHeaderNotes": "Notes",
        "noRoutePoints": "Aucun point de route calculé (probablement aucune prévision disponible pour les HPA).",
        "notesNoDataForEta": "Pas de données pour HPA",
        "notesWeeklyForecast": "Prév. hebd.",
        "notesCurrentLevel": "Actuel",
        "footerApiDate": "Données API du",
        "notLoadedYet": "Pas encore chargé",
        "optionalSegment": "Segment Supplémentaire Optionnel",
        "extraDistance": "Distance Supplémentaire (km)",
        "extraSpeed": "Vitesse Segment Suppl. (km/h)",
        "extraPosition": "Position Segment Suppl.",
        "posAfter": "Après l'itinéraire calculé",
        "posBefore": "Avant l'itinéraire calculé",
        "posHint": "(Ajoute du temps à l'HPA de départ/fin)",
        "errorInvalidDate": "Date/heure de départ invalide.",
        "errorNoRoute": "Veuillez sélectionner un point de départ et d'arrivée.",
        "errorInvalidSpeed": "Les vitesses doivent être supérieures à 0.",
        "errorInvalidHours": "Heures personnalisées invalides (1-24).",
        "errorNoPath": "Aucun itinéraire trouvé entre {start} et {end}. Vérifiez si une connexion logique existe.",
        "errorCustomSegmentSpeed": "La vitesse pour le segment supplémentaire doit être > 0 si une distance est entrée.",
        "calculationError": "Erreur de calcul: {error}",
        "cargoInputDraft": "Tirant d'eau Disponible (m)",
        "useCriticalDraft": "Utiliser T.E. Critique Actuel",
        "usePlannerDraft": "Utiliser T.E. Critique du Planif.",
        "shipFilterCategory": "Filtrer par Catégorie",
        "categoryAll": "Tous",
        "categoryDryCargo": "Cargaison Sèche",
        "categoryTanker": "Pétroliers",
        "addCustomShip": "Ajouter Bateau Personnalisé",
        "manageCustomShips": "Gérer Bateaux Personnalisés",
        "customShipDeleted": "Bateau personnalisé '{name}' supprimé.",
        "crew": "Équipage",
        "loadingWarningMinDraft": "Le tirant d'eau disponible est inférieur au tirant d'eau minimum du bateau de {min_draft}m.",
        "loadingWarningMDKDraft": "Avertissement: Le tirant d'eau de {input_draft}m dépasse la limite de 2,50m sur le Main.",
        "notAllowedOnRoute": "Non autorisé sur cet itinéraire :",
        "warnings": "Avertissements :",
        "constraintShipTooWideMDK": "Le bateau dépasse les dimensions max pour le canal Main-Danube (135/190x11.45m).",
        "constraintHofkirchenUnknown": "Niveau de jauge Hofkirchen inconnu, convois larges (>135x22,90m) pourraient ne pas être autorisés.",
        "constraintHofkirchenLow": "Convoi (>135x22,90m) non autorisé, niveau Hofkirchen < 350cm (actuel: {currentLevel}cm).",
        "constraintRhenusOnDanube": "Le Koppelverband Rhenus n'est pas adapté pour Main/Danube.",
        "constraintShipTooWideBingen": "Bateau trop large pour la section Bingen-St.Goar (>17.70m).",
        "constraintLobithUnknown": "Niveau de jauge Lobith inconnu, convoi de 6 barges pourrait ne pas être autorisé.",
        "constraintLobithLow": "Convoi de 6 barges non autorisé, niveau Lobith < 750cm (actuel: {currentLevel}cm).",
        "constraintWideUpstream": "Convois larges (>22.90m) autorisés uniquement en aval entre Karlsruhe-Lorch.",
        "constraintKaubUnknown": "Niveau de jauge Kaub inconnu, voyage avec largeur >22.90m pourrait ne pas être autorisé.",
        "constraintKaubLow": "Voyage avec largeur >22.90m non autorisé (St.Goar-Gorinchem), niveau Kaub < 120cm (actuel: {currentLevel}cm).",
        "constraintShipTooLargeIJssel": "Le bateau dépasse les dimensions max pour l'IJssel (110x11.45m).",
        "constraint6BargeUpstream": "Convoi de 6 barges autorisé uniquement en aval de Bad Salzig (km 564.30).",
        "modalTitleAddShip": "Ajouter un Bateau Personnalisé",
        "modalShipName": "Nom du Bateau",
        "modalCreationMethod": "Méthode de Création",
        "modalMethodTpc": "TPC (Tonnes par cm)",
        "modalMethodPoints": "Points Tirant d'eau/Tonnage",
        "modalMethodInherit": "Hériter Courbe + 1 Point",
        "modalEmptyDraft": "Tirant d'eau à Vide (m)",
        "modalTpc": "Tonnes par Centimètre",
        "modalAddPoint": "Ajouter Point",
        "modalDraft": "Tirant d'eau (m)",
        "modalTonnage": "Tonnage (T)",
        "modalBaseShip": "Bateau de Base pour Courbe",
        "modalSave": "Sauvegarder Bateau",
        "modalCancel": "Annuler",
        "modalErrorName": "Le nom du bateau est requis.",
        "modalErrorTpc": "TPC et Tirant d'eau à Vide doivent être des nombres positifs.",
        "modalErrorPoints": "Au moins deux points de données sont requis.",
        "modalErrorInherit": "Un bateau de base et un point de données valide sont requis.",
        "constraintRhenusTooLongMDK": "Avertissement: Le convoi Rhenus ({length}m) est {overage}m plus long que la limite de 190m du MDK.",
        "constraintRuhrortUnknown": "Niveau de jauge Duisburg-Ruhrort inconnu, convoi large (>22.90m) pourrait ne pas être autorisé.",
        "constraintRuhrortLow": "Convoi large (>22.90m) non autorisé, niveau Duisburg-Ruhrort < 210cm (actuel: {currentLevel}cm).",
        "constraintLobithLowWide": "Convoi large (>22.90m) non autorisé, niveau Lobith < 750cm (actuel: {currentLevel}cm).",
        "shipDescWideExtraLongGMS": "GMS Large Extra long",
        "shipDescExtraLongGMSLightweight": "GMS Extra long, léger",
        "shipDescExtraLongGMSHeavy": "GMS Extra long, lourd",
        "shipDescGMSSunriseShallow": "GMS type Sunrise basses eaux",
        "shipDescGMSStandard": "GMS type standard",
        "shipDescGMSCDSShallow": "GMS CDS cargo sec basses eaux",
        "shipDescJowiContainer": "JOWI (conteneur)",
        "shipDescEuropeSunriseShallow": "Bateau Europe type Sunrise basses eaux",
        "shipDescEuropeStandard": "Bateau Europe type standard",
        "shipDescDortmunder": "Dortmunder",
        "shipDescDortmunderExtended": "Dortmunder étendu",
        "shipDescElbeConvoy": "Convoi de l'Elbe",
        "shipDescGMSEcoNomyShallow": "GMS type ECO-NOMY basses eaux",
        "shipDescStoltLudwigshafenShallow": "Stolt Ludwigshafen, basses eaux",
        "shipDescCoupledConvoyRhineDanube": "Convoi couplé Rhin/Danube",
        "shipDescCoupledConvoyMosel": "Convoi Couplé Moselle",
        "shipDescRhenus1BargeShallow": "Convoi couplé Rhenus (1 barge), Rhin basses eaux",
        "shipDescRhenus3BargeShallow": "Convoi couplé Rhenus (3 barges), Rhin basses eaux",
        "shipDescSomtransLNG": "Somtrans LNG (est.)",
        "comboNamePushedDanube1": "Convoi Poussé Danube (1 barge)",
        "comboNamePushedDanube2": "Convoi Poussé Danube (2 barges)",
        "comboNamePushedDanube4": "Convoi Poussé Danube (4 barges)",
        "comboNamePushedDanube6": "Convoi Poussé Danube (6 barges)",
        "comboNamePushedRhine4": "Convoi Poussé Rhin (4 barges)",
        "comboNamePushedRhine6": "Convoi Poussé Rhin (6 barges)",
        "comboNameJohannaPlus2": "Convoi couplé Rhin/Danube + 2 Barges du Rhin",
        "comboNameAnimoPlus2": "GMS Extra long, lourd + 2 Barges du Rhin",
        "comboNameTanker1": "Convoi citerne (1 barge)",
        "comboNameTanker2": "Convoi citerne (2 barges)",
        "comboNameTanker4": "Convoi citerne (4 barges)",
        "comboNameTanker6": "Convoi citerne (6 barges)",
            "constraintDanubeKelheimRegensburg": "Le bateau dépasse les dimensions max pour la section Danube Kelheim-Regensburg (190/135x11.45m).",
        "constraintDanubeDownstreamStraubingVilshofen": "Le bateau dépasse les limites de dimensions en aval pour Straubing-Vilshofen (max 190x11.45 ou 135x22.90m).",
        "constraintDanubeRegensburgPassauWide": "Le bateau dépasse les dimensions max pour cette section du Danube (190x22.90m).",
},
    "ru": {
        "appTitle": "Калькулятор Осадки",
        "language_multilingual": "Язык / Language / Taal / Sprache / Langue",
        "autoRefresh": "Автообновление",
        "nextRefresh": "След.",
        "language": "Язык",
        "contextRiver": "Контекст / Река",
        "allRivers": "Все Реки",
        "journey": "Рейс",
        "selectStart": "Выберите старт",
        "selectEnd": "Выберите финиш",
        "to": "в",
        "displayMode": "Режим отображения",
        "displayModeDraft": "Осадка",
        "displayModeLevel": "Уровень воды (сырой)",
        "displayModeTonnage": "Тоннаж",
        "selectRefShip": "Выберите реф. судно",
        "showUncertainty": "Показать неопределенность прогноза",
        "reloadData": "Перезагрузить Данные",
        "loading": "Загрузка...",
        "apiTime": "Время API",
        "initializing": "Инициализация...",
        "loadingStatic": "Загрузка статических определений постов...",
        "staticLoaded": "Статические данные загружены.",
        "fetchingData": "Получение данных от API...",
        "dataUpdated": "Данные обновлены ({successfulUpdates}/{apiGaugeCount} источников API)",
        "updateError": "Ошибка обновления ({errorCount} неудач). Первая: {firstError}",
        "updateWarning": "Частично обновлено ({warningCount} предупреждений). Первое: {firstWarning}",
        "loadError": "Ошибка загрузки: {errorMessage}",
        "criticalDraftTitle": "Критическая осадка ({direction})",
        "directionUp": "Вверх по течению",
        "directionDown": "Вниз по течению",
        "directionMixed": "вверх/вниз",
        "now": "Сейчас",
        "forecast": "Прогноз",
        "noCriticalForecast": "Критический прогноз не найден",
        "noForecastsAvailable": "Данные прогноза недоступны",
        "loadingForecasts": "Загрузка прогнозов...",
        "tabMaxDraft": "Макс. Осадка (Рейс)",
        "tabPlanner": "Планировщик Маршрута",
        "tabCargo": "Грузовместимость",
        "tabAllData": "Все Данные",
        "headerRiver": "Река",
        "headerSection": "Участок",
        "headerName": "Название",
        "headerValue": "Значение",
        "headerTrend": "Тренд",
        "headerOfficialRule": "Офф. правило",
        "headerCorrection": "Коррекция (см)",
        "headerUp": "Вверх",
        "headerDown": "Вниз",
        "headerAdjRule": "Скорр. правило",
        "headerActualDraft": "Осадка",
        "headerActualLevel": "Значение",
        "headerActualTonnage": "Тоннаж",
        "headerUnitCm": "(см)",
        "headerUnitActual": "(Акт., см)",
        "headerUnitTons": "(Акт., т)",
        "headerForecastValue": "({mode}, см)",
        "headerForecastValueTons": "({mode}, т)",
        "noForecasts": "Нет Прогнозов",
        "noDataForSelection": "Выберите действительный рейс или данные для рейса недоступны.",
        "noApiData": "Данные API не загружены.",
        "noDataForFilter": "Данные для выбранного фильтра не найдены.",
        "plannerSettingsTitle": "Настройки Планировщика Маршрута",
        "departureTime": "Дата/Время Отправления",
        "speedDownstream": "Скорость вниз (км/ч)",
        "speedUpstream": "Скорость вверх (км/ч)",
        "speedCanal": "Сред. скор. Майн/РМД (км/ч)",
        "speedCanalHint": "(От Майнца до Кельхайма)",
        "system": "Система",
        "systemA1": "A1 (14 часов/день)",
        "systemA2": "A2 (18 часов/день)",
        "systemB": "B (24 часа/день)",
        "systemCustom": "Пользовательская",
        "hoursPerDay": "часов/день",
        "excludedDays": "Исключенные Дни",
        "showUncertaintyPlanner": "Показать неопределенность прогноза",
        "ifAvailable": "(Если доступно)",
        "calculateMaxDraft": "Рассчитать Максимальную Осадку",
        "calculating": "Расчет...",
        "plannerResultTitle": "Результат Плана Маршрута",
        "maxPossibleDraft": "Максимально Возможная Осадка",
        "limitedBy": "Ограничено",
        "mgdWarningText": "ВНИМАНИЕ: Расчетная осадка {calculatedDraft} см превышает MGD для {mgdName} ({mgdDraft} см). Движение с такой осадкой на ваш страх и риск.",
        "canalLimitReason": "(верхний) Майн (макс 250 см)",
        "routeDetails": "Детали маршрута",
        "plannerHeaderKm": "КМ",
        "plannerHeaderName": "Название",
        "plannerHeaderEta": "ПВП",
        "plannerHeaderForecastLevel": "Прогн. Ур. (см)",
        "plannerHeaderOffset": "Смещение (см)",
        "plannerHeaderAdjRule": "Скорр. пр. (см)",
        "plannerHeaderMaxDraft": "Макс. Осадка (см)",
        "plannerHeaderNotes": "Примечания",
        "noRoutePoints": "Точки маршрута не рассчитаны (возможно, нет прогнозов для ПВП).",
        "notesNoDataForEta": "Нет данных для ПВП",
        "notesWeeklyForecast": "Недельный прогн.",
        "notesCurrentLevel": "Текущий",
        "footerApiDate": "Данные API от",
        "notLoadedYet": "Еще не загружено",
        "optionalSegment": "Дополнительный Сегмент",
        "extraDistance": "Доп. Расстояние (км)",
        "extraSpeed": "Скорость Доп. Сегмента (км/ч)",
        "extraPosition": "Позиция Доп. Сегмента",
        "posAfter": "После расчетного маршрута",
        "posBefore": "До расчетного маршрута",
        "posHint": "(Добавляет время к началу/концу ПВП)",
        "errorInvalidDate": "Неверная дата/время старта.",
        "errorNoRoute": "Пожалуйста, выберите начальную и конечную точки.",
        "errorInvalidSpeed": "Скорости должны быть больше 0.",
        "errorInvalidHours": "Неверные пользовательские часы (1-24).",
        "errorNoPath": "Маршрут между {start} и {end} не найден. Проверьте наличие логического соединения.",
        "errorCustomSegmentSpeed": "Скорость для доп. сегмента должна быть > 0, если введено расстояние.",
        "calculationError": "Ошибка расчета: {error}",
        "cargoInputDraft": "Доступная Осадка (м)",
        "useCriticalDraft": "Исп. Текущую Крит. Осадку",
        "usePlannerDraft": "Исп. Крит. Осадку Планировщика",
        "shipFilterCategory": "Фильтр по Категории",
        "categoryAll": "Все",
        "categoryDryCargo": "Сухогруз",
        "categoryTanker": "Танкеры",
        "addCustomShip": "Добавить Свое Судно",
        "manageCustomShips": "Управление Судами",
        "customShipDeleted": "Пользовательское судно '{name}' удалено.",
        "crew": "Экипаж",
        "loadingWarningMinDraft": "Доступная осадка меньше минимальной осадки судна {min_draft}м.",
        "loadingWarningMDKDraft": "Внимание: Введенная осадка {input_draft}м превышает лимит в 2,50м на реке Майн.",
        "notAllowedOnRoute": "Не разрешено на этом маршруте:",
        "warnings": "Предупреждения:",
        "constraintShipTooWideMDK": "Судно превышает макс. размеры для канала Майн-Дунай (135/190x11.45м).",
        "constraintHofkirchenUnknown": "Уровень поста Хофкирхен неизвестен, широкие составы (>135x22,90м) могут быть не разрешены.",
        "constraintHofkirchenLow": "Состав (>135x22,90м) не разрешен, уровень Хофкирхен < 350см (текущий: {currentLevel}см).",
        "constraintRhenusOnDanube": "Состав Rhenus не подходит для Майна/Дуная.",
        "constraintShipTooWideBingen": "Судно слишком широкое для участка Бинген-Санкт-Гоар (>17.70м).",
        "constraintLobithUnknown": "Уровень поста Лобит неизвестен, состав из 6 барж может быть не разрешен.",
        "constraintLobithLow": "Состав из 6 барж не разрешен, уровень Лобит < 750см (текущий: {currentLevel}см).",
        "constraintWideUpstream": "Широкие составы (>22.90м) разрешены только вниз по течению между Карлсруэ-Лорх.",
        "constraintKaubUnknown": "Уровень поста Кауб неизвестен, рейс с шириной >22.90м может быть не разрешен.",
        "constraintKaubLow": "Рейс с шириной >22.90м не разрешен (Санкт-Гоар-Горинхем), уровень Кауб < 120см (текущий: {currentLevel}см).",
        "constraintShipTooLargeIJssel": "Судно превышает макс. размеры для реки Эйссел (110x11.45м).",
        "constraint6BargeUpstream": "Состав из 6 барж разрешен только вниз по течению от Бад-Зальциг (км 564.30).",
        "modalTitleAddShip": "Добавить Свое Судно",
        "modalShipName": "Название Судна",
        "modalCreationMethod": "Метод Создания",
        "modalMethodTpc": "TPC (Тонн на см)",
        "modalMethodPoints": "Точки Осадка/Тоннаж",
        "modalMethodInherit": "Наследовать Кривую + 1 Точка",
        "modalEmptyDraft": "Осадка Порожнем (м)",
        "modalTpc": "Тонн на сантиметр",
        "modalAddPoint": "Добавить Точку",
        "modalDraft": "Осадка (м)",
        "modalTonnage": "Тоннаж (т)",
        "modalBaseShip": "Базовое Судно для Кривой",
        "modalSave": "Сохранить Судно",
        "modalCancel": "Отмена",
        "modalErrorName": "Название судна обязательно.",
        "modalErrorTpc": "TPC и Осадка Порожнем должны быть положительными числами.",
        "modalErrorPoints": "Требуется не менее двух точек данных.",
        "modalErrorInherit": "Требуется базовое судно и действительная точка данных.",
        "constraintRhenusTooLongMDK": "Внимание: Состав Rhenus ({length}м) на {overage}м длиннее лимита МДК в 190м.",
        "constraintRuhrortUnknown": "Уровень поста Дуйсбург-Рурорт неизвестен, широкий состав (>22.90м) может быть не разрешен.",
        "constraintRuhrortLow": "Широкий состав (>22.90м) не разрешен, уровень Дуйсбург-Рурорт < 210см (текущий: {currentLevel}см).",
        "constraintLobithLowWide": "Широкий состав (>22.90м) не разрешен, уровень Лобит < 750см (текущий: {currentLevel}см).",
        "shipDescWideExtraLongGMS": "Широкий Сверхдлинный GMS",
        "shipDescExtraLongGMSLightweight": "Сверхдлинный GMS, легкий",
        "shipDescExtraLongGMSHeavy": "Сверхдлинный GMS, тяжелый",
        "shipDescGMSSunriseShallow": "GMS тип Sunrise для мелководья",
        "shipDescGMSStandard": "GMS стандартного типа",
        "shipDescGMSCDSShallow": "GMS CDS сухогруз для мелководья",
        "shipDescJowiContainer": "JOWI (контейнеровоз)",
        "shipDescEuropeSunriseShallow": "Европейское судно тип Sunrise для мелководья",
        "shipDescEuropeStandard": "Европейское судно стандартного типа",
        "shipDescDortmunder": "Дортмундер",
        "shipDescDortmunderExtended": "Дортмундер удлиненный",
        "shipDescElbeConvoy": "Эльбский состав",
        "shipDescGMSEcoNomyShallow": "GMS тип ECO-NOMY для мелководья",
        "shipDescStoltLudwigshafenShallow": "Stolt Ludwigshafen, для мелководья",
        "shipDescCoupledConvoyRhineDanube": "Сцепной состав Рейн/Дунай",
        "shipDescCoupledConvoyMosel": "Сцепной состав Мозель",
        "shipDescRhenus1BargeShallow": "Сцепной состав Rhenus (1 баржа), Рейн мелководье",
        "shipDescRhenus3BargeShallow": "Сцепной состав Rhenus (3 баржи), Рейн мелководье",
        "shipDescSomtransLNG": "Somtrans LNG (оценка)",
        "comboNamePushedDanube1": "Толкаемый состав Дунай (1 баржа)",
        "comboNamePushedDanube2": "Толкаемый состав Дунай (2 баржи)",
        "comboNamePushedDanube4": "Толкаемый состав Дунай (4 баржи)",
        "comboNamePushedDanube6": "Толкаемый состав Дунай (6 барж)",
        "comboNamePushedRhine4": "Толкаемый состав Рейн (4 баржи)",
        "comboNamePushedRhine6": "Толкаемый состав Рейн (6 барж)",
        "comboNameJohannaPlus2": "Сцепной состав Рейн/Дунай + 2 рейнские баржи",
        "comboNameAnimoPlus2": "Сверхдлинный GMS, тяжелый + 2 рейнские баржи",
        "comboNameTanker1": "Танкерный состав (1 баржа)",
        "comboNameTanker2": "Танкерный состав (2 баржи)",
        "comboNameTanker4": "Танкерный состав (4 баржи)",
        "comboNameTanker6": "Танкерный состав (6 барж)",
            "constraintDanubeKelheimRegensburg": "Судно превышает макс. размеры для участка Дуная Кельхайм-Регенсбург (190/135x11.45м).",
        "constraintDanubeDownstreamStraubingVilshofen": "Судно превышает габаритные ограничения при движении вниз по течению на участке Штраубинг-Фильсхофен (макс. 190x11.45 или 135x22.90м).",
        "constraintDanubeRegensburgPassauWide": "Судно превышает макс. размеры для этого участка Дуная (190x22.90м).",
}
};
    const localeMap = { nl: 'nl-NL', en: 'en-GB', de: 'de-DE', fr: 'fr-FR', ru: 'ru-RU' };
    const I18nContext = createContext();
    function I18nProvider({ children }) {
        const [language, setLanguageState] = useState(() => getCookie('appLanguage') || 'nl');
        const setLanguage = (lang) => { setCookie('appLanguage', lang, 365); setLanguageState(lang); document.documentElement.lang = lang; };
        useEffect(() => { document.documentElement.lang = language; }, [language]);
        const t = (key, replacements = {}) => {
            const defaultTranslations = {
                appTitle: "Draft Calculator",
                autoRefresh: "Auto-refresh",
                nextRefresh: "Next",
                language: "Language",
                contextRiver: "Context / River",
                allRivers: "All Rivers",
                journey: "Journey",
                selectStart: "Select start",
                selectEnd: "Select end",
                to: "to",
                displayMode: "Display Mode",
                displayModeDraft: "Draft",
                displayModeLevel: "Water Level (raw)",
                displayModeTonnage: "Tonnage",
                selectRefShip: "Select Ref. Ship",
                showUncertainty: "Show Forecast Uncertainty",
                reloadData: "Reload Data",
                loading: "Loading...",
                apiTime: "API time",
                initializing: "Initializing...",
                loadingStatic: "Loading static gauge definitions...",
                staticLoaded: "Static data loaded.",
                fetchingData: "Fetching data from API...",
                dataUpdated: "Data updated ({successfulUpdates}/{apiGaugeCount} API sources)",
                updateError: "Error updating ({errorCount} failed). First: {firstError}",
                updateWarning: "Partially updated ({warningCount} warnings). First: {firstWarning}",
                loadError: "Error loading: {errorMessage}",
                criticalDraftTitle: "Critical draft ({direction})",
                directionUp: "Upstream",
                directionDown: "Downstream",
                directionMixed: "up/down",
                now: "Now",
                forecast: "Forecast",
                noCriticalForecast: "No critical forecast found",
                noForecastsAvailable: "No forecast data available",
                loadingForecasts: "Loading forecasts...",
                tabMaxDraft: "Max Draft (Journey)",
                tabPlanner: "Route Planner",
                tabCargo: "Cargo Capacity",
                tabAllData: "All Data",
                headerRiver: "River",
                headerSection: "Section",
                headerName: "Name",
                headerValue: "Value",
                headerTrend: "Trend",
                headerOfficialRule: "Off. Rule",
                headerCorrection: "Correction (cm)",
                headerUp: "Up",
                headerDown: "Down",
                headerAdjRule: "Adj. Rule",
                headerActualDraft: "Draft",
                headerActualLevel: "Value",
                headerActualTonnage: "Tonnage",
                headerUnitCm: "(cm)",
                headerUnitActual: "(Act., cm)",
                headerUnitTons: "(Act., T)",
                headerForecastValue: "({mode}, cm)",
                headerForecastValueTons: "({mode}, T)",
                noForecasts: "No Forecasts",
                noDataForSelection: "Select a valid journey or no data available for journey.",
                noApiData: "No API data loaded.",
                noDataForFilter: "No data found for the selected filter.",
                plannerSettingsTitle: "Route Planner Settings",
                departureTime: "Departure Date/Time",
                speedDownstream: "Speed Downstream (km/h)",
                speedUpstream: "Speed Upstream (km/h)",
                speedCanal: "Avg. Speed Main/RMD (km/h)",
                speedCanalHint: "(From Mainz to Kelheim)",
                system: "System",
                systemA1: "A1 (14 hours/day)",
                systemA2: "A2 (18 hours/day)",
                systemB: "B (24 hours/day)",
                systemCustom: "Custom",
                hoursPerDay: "hours/day",
                excludedDays: "Excluded Days",
                showUncertaintyPlanner: "Show Forecast Uncertainty",
                ifAvailable: "(If available)",
                calculateMaxDraft: "Calculate Maximum Draft",
                calculating: "Calculating...",
                plannerResultTitle: "Route Plan Result",
                maxPossibleDraft: "Maximum Possible Draft",
                limitedBy: "Limited by",
                mgdWarningText: "WARNING: The calculated draft of {calculatedDraft} cm exceeds the MGD for {mgdName} ({mgdDraft} cm). Sailing at this draft is at your own risk.",
                canalLimitReason: "(upper) Main (max 250 cm)",
                routeDetails: "Route Details",
                plannerHeaderKm: "KM",
                plannerHeaderName: "Name",
                plannerHeaderEta: "ETA",
                plannerHeaderForecastLevel: "Fcst. Level (cm)",
                plannerHeaderOffset: "Offset (cm)",
                plannerHeaderAdjRule: "Adj. Rule (cm)",
                plannerHeaderMaxDraft: "Max Draft (cm)",
                plannerHeaderNotes: "Notes",
                noRoutePoints: "No route points calculated (possibly no forecasts available for ETAs).",
                notesNoDataForEta: "No data for ETA",
                notesWeeklyForecast: "Weekly fcst.",
                notesCurrentLevel: "Current",
                footerApiDate: "Data API as of",
                notLoadedYet: "Not loaded yet",
                optionalSegment: "Optional Extra Segment",
                extraDistance: "Extra Distance (km)",
                extraSpeed: "Speed Extra Segment (km/h)",
                extraPosition: "Position Extra Segment",
                posAfter: "After calculated route",
                posBefore: "Before calculated route",
                posHint: "(Adds time to start/end ETA)",
                errorInvalidDate: "Invalid start date/time.",
                errorNoRoute: "Please select a start and end point.",
                errorInvalidSpeed: "Speeds must be greater than 0.",
                errorInvalidHours: "Invalid custom hours (1-24).",
                errorNoPath: "No route found between {start} and {end}. Check if a logical connection exists.",
                errorCustomSegmentSpeed: "Speed for extra segment must be greater than 0 if distance is entered.",
                calculationError: "Error calculating: {error}",
                cargoInputDraft: "Available Draft (m)",
                useCriticalDraft: "Use Current Critical Draft",
                usePlannerDraft: "Use Planner Critical Draft",
                shipFilterCategory: "Filter Category",
                categoryAll: "All",
                categoryDryCargo: "Dry Cargo",
                categoryTanker: "Tankers",
                addCustomShip: "Add Custom Ship",
                manageCustomShips: "Manage Custom Ships",
                customShipDeleted: "Custom ship '{name}' deleted.",
                crew: "Crew",
                loadingWarningMinDraft: "Available draft is below ship's minimum draft of {min_draft}m.",
                loadingWarningMDKDraft: "Warning: Input draft of {input_draft}m exceeds 2.50m limit on Main river.",
                notAllowedOnRoute: "Not allowed on this route:",
                warnings: "Warnings:",
                constraintShipTooWideMDK: "Ship exceeds max dimensions for Main-Danube Canal (135/190x11.45m).",
                constraintHofkirchenUnknown: "Hofkirchen gauge level unknown, wide convoys (>135x22,90m) might not be allowed.",
                constraintHofkirchenLow: "Convoy (>135x22,90m) not allowed, Hofkirchen level < 350cm (current: {currentLevel}cm).",
                constraintRhenusOnDanube: "Rhenus Koppelverband is not suitable for Main/Danube.",
                constraintShipTooWideBingen: "Ship too wide for Bingen-St.Goar section (>17.70m).",
                constraintLobithUnknown: "Lobith gauge level unknown, 6-barge convoy might not be allowed.",
                constraintLobithLow: "6-barge convoy not allowed, Lobith level < 750cm (current: {currentLevel}cm).",
                constraintWideUpstream: "Wide convoys (>22.90m) only allowed downstream between Karlsruhe-Lorch.",
                constraintKaubUnknown: "Kaub gauge level unknown, voyage with width >22.90m might not be allowed.",
                constraintKaubLow: "Voyage with width >22.90m not allowed (St.Goar-Gorinchem), Kaub level < 120cm (current: {currentLevel}cm).",
                constraintShipTooLargeIJssel: "Ship exceeds max dimensions for IJssel (110x11.45m).",
                constraint6BargeUpstream: "6-barge convoy only allowed downstream of Bad Salzig (km 564.30).",
                modalTitleAddShip: "Add a Custom Ship",
                modalShipName: "Ship Name",
                modalCreationMethod: "Creation Method",
                modalMethodTpc: "TPC (Tons per cm)",
                modalMethodPoints: "Draft/Tonnage Points",
                modalMethodInherit: "Inherit Curve + 1 Point",
                modalEmptyDraft: "Empty Draft (m)",
                modalTpc: "Tons per Centimeter",
                modalAddPoint: "Add Point",
                modalDraft: "Draft (m)",
                modalTonnage: "Tonnage (T)",
                modalBaseShip: "Base Ship for Curve",
                modalSave: "Save Ship",
                modalCancel: "Cancel",
                modalErrorName: "Ship name is required.",
                modalErrorTpc: "TPC and Empty Draft must be positive numbers.",
                modalErrorPoints: "At least two data points are required.",
                modalErrorInherit: "Base ship and a valid data point are required.",
                constraintRhenusOnDanube: "Rhenus Koppelverband is not suitable for Main/Danube.",
                constraintRhenusTooLongMDK: "Warning: Rhenus convoy ({length}m) is {overage}m longer than 190m MDK limit.",
                constraintRuhrortUnknown: "Duisburg-Ruhrort gauge level unknown, wide convoy (>22.90m) might not be allowed.",
                constraintRuhrortLow: "Wide convoy (>22.90m) not allowed, Duisburg-Ruhrort level < 210cm (current: {currentLevel}cm).",
                constraintLobithLowWide: "Wide convoy (>22.90m) not allowed, Lobith level < 750cm (current: {currentLevel}cm).",
                constraintShipTooWideBingen: "Ship too wide for Bingen-St.Goar section (>17.70m).",
            };
            let text = translations[language]?.[key] || defaultTranslations[key] || key;
            for (const placeholder in replacements) { text = text.replace(`{${placeholder}}`, replacements[placeholder]); }
            return text;
        };
        const value = { language, setLanguage, t, locale: localeMap[language] || 'en-GB', weekdays: ['Zo', 'Ma', 'Di', 'Wo', 'Do', 'Vr', 'Za'] };
        return ( <I18nContext.Provider value={value}> {children} </I18nContext.Provider> );
    }

    // --- Constants ---
    const API_URL = 'https://rdd-backend.vercel.app/api/data';
    const REFRESH_INTERVAL_MS = 10 * 60 * 1000;
    const DEFAULT_DEPTH_SAFETY_MARGIN = 0;
    const MAX_FORECAST_DAYS = 8;
    const MAIN_ROUTE_RIVERS = ['Rijn', 'Waal'];
    const WEEKDAYS = ['Zo', 'Ma', 'Di', 'Wo', 'Do', 'Vr', 'Za'];

    // --- Cookie Utilities ---
    function setCookie(name, value, days = 3650) {
        const date = new Date();
        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
        const expires = `expires=${date.toUTCString()}`;
        document.cookie = `${name}=${JSON.stringify(value)};${expires};path=/;SameSite=Lax`;
    }

    function getCookie(name) {
        const nameEQ = `${name}=`;
        const ca = document.cookie.split(';');
        for (let i = 0; i < ca.length; i++) {
            let c = ca[i];
            while (c.charAt(0) === ' ') c = c.substring(1, c.length);
            if (c.indexOf(nameEQ) === 0) {
                try {
                    return JSON.parse(c.substring(nameEQ.length, c.length));
                } catch (e) {
                    console.error("Error parsing cookie:", name, e);
                    return null;
                }
            }
        }
        return null;
    }

    // --- API Fetch Function ---
    async function fetchConsolidatedData(force = false) { /* ... Unchanged ... */
        const url = `${API_URL}?t=${Date.now()}`;
        console.log(`Fetching data from: ${url}`);
        try {
            const response = await fetch(url);
            if (!response.ok) {
                let errorText = `API request failed: ${response.status}`;
                try {
                    const errorBody = await response.json();
                    errorText += ` - ${errorBody.error || JSON.stringify(errorBody)}`;
                } catch (parseError) {
                    try {
                        const textBody = await response.text();
                        errorText += ` - ${textBody.substring(0, 200)}`;
                    } catch (readError) {
                    }
                }
                throw new Error(errorText);
            }
            const data = await response.json();
            console.log("API Data Received:", Object.keys(data).length, "gauges");
            return data;
        } catch (error) {
            console.error("Error fetching consolidated data:", error);
            throw error;
        }
    }

    // --- Helper Functions ---
    // I18N: Updated to accept a locale
    function formatTimeDisplay(timeString, locale = 'nl-NL') {
        if (!timeString || typeof timeString !== 'string') return "N/A";
        if (timeString.length === 5 && timeString.includes(':')) return timeString;
        if (timeString.includes(' ') && timeString.includes(':')) {
            const timePart = timeString.split(' ')[1];
            if (timePart && timePart.length >= 5) return timePart.substring(0, 5);
        }
        try {
            const date = new Date(timeString);
            if (!isNaN(date.getTime())) return date.toLocaleTimeString(locale, {hour: '2-digit', minute: '2-digit'});
        } catch (e) {
        }
        return timeString || "N/A";
    }

    function getGaugeUrl(gauge) { /* ... Unchanged ... */
        if (!gauge) return '#';
        const gaugeName = gauge.name;
        const gaugeRiver = gauge.river;
        const gaugeRegion = gauge.region || gauge.apiData?.region;
        if (gaugeRiver === 'MGD' || (gaugeRegion && gaugeRegion.includes('depths'))) return `https://www.vaarweginformatie.nl/frp/main/#/hydro/mgd`;
        const dutchGaugeUrlCodes = {
            'Nijmegen': 'Nijmegen-haven(NIJM)',
            'Tiel': 'Tiel-Waal(TIEW)',
            'Pannerdense kop': 'Pannerdense-kop(PANN)',
            'IJsselkop': 'IJsselkop(IJSS)',
            'Doesburg': 'Doesburg-brug(DOES)',
            'Deventer': 'Deventer(DEVE)',
            'Katerveer': 'Katerveer(KATV)'
        };
        const germanGaugeIds = {
            'Konstanz': '00007',
            'Iffezheim': '09137',
            'Maxau': '09016',
            'Speyer': '09017',
            'Mannheim': '09001',
            'Worms': '09018'
        };
        const rlpGaugeUrls = {
            'Mainz': 'https://www.hochwasser.rlp.de/flussgebiet/mittelrhein/mainz',
            'Bingen': 'https://www.hochwasser.rlp.de/flussgebiet/mittelrhein/bingen',
            'Andernach': 'https://www.hochwasser.rlp.de/flussgebiet/mittelrhein/andernach',
            'Bonn': 'https://www.hochwasser.rlp.de/flussgebiet/mittelrhein/bonn',
            'Wesel': 'https://www.hochwasser.rlp.de/flussgebiet/niederrhein/wesel'
        };
        if (rlpGaugeUrls[gaugeName]) return rlpGaugeUrls[gaugeName];
        if (gaugeName === 'Lobith') return 'https://www.rijkswaterstaat.nl/water/waterdata-en-waterberichtgeving/waterdata/lobith-waterstanden-en-afvoeren';
        if (germanGaugeIds[gaugeName]) return `https://www.hvz.baden-wuerttemberg.de/pegel.html?id=${germanGaugeIds[gaugeName]}`;
        if (dutchGaugeUrlCodes[gaugeName] || (gaugeRegion && gaugeRegion.includes('dutch'))) {
            const urlCode = dutchGaugeUrlCodes[gaugeName] || encodeURIComponent(gaugeName);
            return `https://waterinfo.rws.nl/publiek/waterhoogte/${urlCode}/details`;
        }
        const elwisNameBase = gauge.apiDataName || gauge.name || '';
        const elwisName = elwisNameBase.toUpperCase();
        if (elwisName) return `https://www.elwis.de/DE/dynamisch/Wasserstaende/Pegelvorhersage:${elwisName}`;
        return '#';
    }

    function diffDays(dateStr1, dateStr2) { /* ... Unchanged ... */
        try {
            const date1 = new Date(Date.UTC(parseInt(dateStr1.substring(0, 4)), parseInt(dateStr1.substring(5, 7)) - 1, parseInt(dateStr1.substring(8, 10)), 12, 0, 0));
            const date2 = new Date(Date.UTC(parseInt(dateStr2.substring(0, 4)), parseInt(dateStr2.substring(5, 7)) - 1, parseInt(dateStr2.substring(8, 10)), 12, 0, 0));
            if (isNaN(date1.getTime()) || isNaN(date2.getTime())) return NaN;
            return Math.round((date2 - date1) / (1000 * 60 * 60 * 24));
        } catch (e) {
            console.error("Error calculating date difference:", dateStr1, dateStr2, e);
            return NaN;
        }
    }

    // --- Date/Time Helper for Operational Time (Unchanged) ---
    function addOperationalTime(startDate, durationHours, operationalHoursPerDay, excludedDaysOfWeek) { /* ... Unchanged ... */
        if (operationalHoursPerDay <= 0 || durationHours <= 0) return startDate;

        let currentTime = new Date(startDate.getTime());
        let remainingDurationHours = durationHours;

        const getOperationalWindow = (date, mode) => {
            let startHour, endHour;
            const dayOfWeek = date.getDay();

            if (excludedDaysOfWeek.includes(dayOfWeek)) {
                return { start: null, end: null }; // Not an operational day
            }

            switch (mode) {
                case 'A1':
                    startHour = 6;
                    endHour = 20;
                    break;
                case 'A2':
                    startHour = 5;
                    endHour = 23;
                    break;
                case 'B':
                default: // Default to 24-hour operation
                    startHour = 0;
                    endHour = 24;
                    break;
            }
            const startTime = new Date(date.getFullYear(), date.getMonth(), date.getDate(), startHour, 0, 0);
            const endTime = new Date(date.getFullYear(), date.getMonth(), date.getDate(), endHour, 0, 0);
            return { start: startTime, end: endTime };
        };

        let mode = 'B'; // Default
        if (operationalHoursPerDay === 14) mode = 'A1';
        if (operationalHoursPerDay === 18) mode = 'A2';

        while (remainingDurationHours > 1e-6) {
            let { start: opStart, end: opEnd } = getOperationalWindow(currentTime, mode);

            if (!opStart) {
                currentTime.setDate(currentTime.getDate() + 1);
                currentTime.setHours(0, 0, 0, 0);
                continue;
            }
            if (currentTime < opStart) {
                currentTime = new Date(opStart.getTime());
            }

            if (currentTime >= opEnd) {
                currentTime.setDate(currentTime.getDate() + 1);
                let { start: nextOpStart } = getOperationalWindow(currentTime, mode);
                while(!nextOpStart) {
                    currentTime.setDate(currentTime.getDate() + 1);
                    nextOpStart = getOperationalWindow(currentTime, mode).start;
                }
                currentTime = new Date(nextOpStart.getTime());
                continue;
            }

            const availableMs = opEnd.getTime() - currentTime.getTime();
            const availableHours = availableMs / (1000 * 60 * 60);
            const timeToConsume = Math.min(remainingDurationHours, availableHours);

            currentTime.setTime(currentTime.getTime() + timeToConsume * 1000 * 60 * 60);
            remainingDurationHours -= timeToConsume;
        }

        return currentTime;
    }

    // --- Get Forecast for specific Date/Time (Unchanged) ---
    function getForecastForDateTime(apiData, targetDateTime) { /* ... Unchanged ... */
        if (!apiData || !targetDateTime || isNaN(targetDateTime.getTime())) return null;
        const targetYear = targetDateTime.getFullYear();
        const targetMonth = String(targetDateTime.getMonth() + 1).padStart(2, '0');
        const targetDay = String(targetDateTime.getDate()).padStart(2, '0');
        const targetDateStr = `${targetYear}-${targetMonth}-${targetDay}`;
        const targetHour = targetDateTime.getHours();
        const targetMinute = targetDateTime.getMinutes();
        const targetTotalMins = targetHour * 60 + targetMinute;
        const forecastsForDate = apiData.forecasts?.[targetDateStr];
        if (forecastsForDate && Object.keys(forecastsForDate).length > 0) {
            const availableTimes = Object.keys(forecastsForDate).filter(t => t.match(/^\d{2}:\d{2}$/));
            if (availableTimes.length > 0) {
                let bestMatchTime = null;
                let minDiff = Infinity;
                for (const time of availableTimes) {
                    const [h, m] = time.split(':').map(Number);
                    const totalMins = h * 60 + m;
                    const diff = Math.abs(totalMins - targetTotalMins);
                    if (diff < minDiff) {
                        minDiff = diff;
                        bestMatchTime = time;
                    }
                }
                if (bestMatchTime) {
                    const forecastSlot = forecastsForDate[bestMatchTime];
                    if (forecastSlot && forecastSlot.value !== undefined && forecastSlot.value !== null) {
                        let uncertainty = null;
                        if (forecastSlot.low_80 !== null && forecastSlot.high_80 !== null) {
                            uncertainty = {low: forecastSlot.low_80, high: forecastSlot.high_80};
                        }
                        return {
                            value: forecastSlot.value,
                            time: bestMatchTime,
                            source: 'daily',
                            uncertainty: uncertainty
                        };
                    }
                }
            }
        }
        if (Array.isArray(apiData.weeklyForecasts) && apiData.weeklyForecasts.length > 0) {
            const targetDateUtc = new Date(Date.UTC(targetYear, targetMonth - 1, targetDay, 12, 0, 0));
            for (const weeklyForecast of apiData.weeklyForecasts) {
                if (weeklyForecast.weekRange && weeklyForecast.median !== null) {
                    try {
                        const [startStr, endStr] = weeklyForecast.weekRange.split('-');
                        const [startDay, startMonth, startYear] = startStr.split('.');
                        const [endDay, endMonth, endYear] = endStr.split('.');
                        const startDate = new Date(Date.UTC(startYear, startMonth - 1, startDay, 0, 0, 0));
                        const endDate = new Date(Date.UTC(endYear, endMonth - 1, endDay, 23, 59, 59));
                        if (!isNaN(startDate.getTime()) && !isNaN(endDate.getTime()) && targetDateUtc >= startDate && targetDateUtc <= endDate) {
                            let uncertainty = null;
                            if (weeklyForecast.low_90 !== null && weeklyForecast.high_90 !== null) {
                                uncertainty = {low: weeklyForecast.low_90, high: weeklyForecast.high_90};
                            }
                            return {
                                value: weeklyForecast.median,
                                time: "(BfG6W)",
                                source: 'weekly',
                                uncertainty: uncertainty,
                                weeklySlot: weeklyForecast
                            };
                        }
                    } catch (e) {
                        console.warn(`Error parsing weekRange "${weeklyForecast.weekRange}" in getForecastForDateTime for gauge ${apiData.apiName}:`, e);
                    }
                }
            }
        }
        return null;
    }

    // --- NEW: Calculate Forecast Uncertainty based on river and publication time (Unchanged) ---
    function calculateForecastUncertainty(gauge, forecastDateStr, now) { /* ... Unchanged ... */
        if (!gauge || !gauge.river || !forecastDateStr || !now) {
            return null;
        }

        let publishHour;
        let thresholdHours;

        // 1. Determine rules based on the river
        switch (gauge.river) {
            case 'Rijn':
            case 'Waal':
            case 'Pannerdens Kanaal':
            case 'IJssel':
                publishHour = 7;
                thresholdHours = 48.1;
                break;
            case 'Donau':
                publishHour = 5;
                thresholdHours = 24.1;
                break;
            default:
                return null; // No uncertainty rules for this river
        }

        // 2. Determine the most recent forecast publication time
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate(), publishHour, 0, 0);
        let mostRecentPublishTime = today;

        if (now < today) {
            // If it's before today's publication time, the latest forecast is from yesterday
            mostRecentPublishTime.setDate(mostRecentPublishTime.getDate() - 1);
        }

        // 3. Calculate the difference in hours from publication to the forecast date
        const forecastDate = new Date(forecastDateStr + 'T00:00:00Z'); // Use midnight for correct threshold calculation
        const diffMs = forecastDate.getTime() - mostRecentPublishTime.getTime();
        const diffHours = diffMs / (1000 * 60 * 60);

        if (diffHours < 0) {
            return null; // Forecast is for a date before the last publication, unlikely but safe to handle
        }

        // 4. Apply the threshold
        if (diffHours <= thresholdHours) {
            return 10; // ±10 cm
        } else {
            return 20; // ±20 cm
        }
    }
    // --- NEW: Standalone Pathfinding Helper Function (Unchanged) ---
    const findRoutePath = (startGaugeName, endGaugeName, allGauges, speeds) => { /* ... Unchanged ... */
        if (!startGaugeName || !endGaugeName) return null;

        const gaugeMap = new Map(allGauges.map(g => [g.name, g]));
        const graph = new Map();

        // Build graph with weighted edges (travel time in hours)
        allGauges.forEach(gauge => {
            if (!graph.has(gauge.name)) graph.set(gauge.name, []);

            const neighbors = new Map(); // Use map to avoid duplicate neighbors

            // Add explicit connections (junctions, canals)
            if (gauge.connections) {
                gauge.connections.forEach(conn => {
                    const targetGauge = gaugeMap.get(conn.targetGaugeName);
                    if (targetGauge) {
                        const distance = conn.distance || Math.abs(gauge.km - targetGauge.km);
                        const speed = conn.speed || speeds.downstream; // Default speed for simple connections
                        const travelTime = distance / speed;
                        neighbors.set(targetGauge.name, {
                            node: targetGauge.name,
                            weight: travelTime,
                            targetGauge: targetGauge
                        });
                    }
                });
            }

            // Add implicit connections to adjacent gauges on the same river
            const sameRiverGauges = allGauges.filter(g => g.river === gauge.river && g.name !== gauge.name);
            if (sameRiverGauges.length > 0) {
                let nextUpstream = null, nextDownstream = null;

                // Determine next gauge based on KM value, handling Danube's inverted system
                if (gauge.river === 'Donau') {
                    nextUpstream = sameRiverGauges.filter(g => g.km > gauge.km).sort((a,b) => a.km - b.km)[0];
                    nextDownstream = sameRiverGauges.filter(g => g.km < gauge.km).sort((a,b) => b.km - a.km)[0];
                } else {
                    nextUpstream = sameRiverGauges.filter(g => g.km < gauge.km).sort((a,b) => b.km - a.km)[0];
                    nextDownstream = sameRiverGauges.filter(g => g.km > gauge.km).sort((a,b) => a.km - b.km)[0];
                }

                [nextUpstream, nextDownstream].forEach(neighbor => {
                    if (neighbor && !neighbors.has(neighbor.name)) {
                        const distance = Math.abs(gauge.km - neighbor.km);
                        const isDownstream = (gauge.river === 'Donau') ? neighbor.km < gauge.km : neighbor.km > gauge.km;
                        const speed = isDownstream ? speeds.downstream : speeds.upstream;
                        if (speed > 0) {
                            neighbors.set(neighbor.name, {
                                node: neighbor.name,
                                weight: distance / speed,
                                targetGauge: neighbor
                            });
                        }
                    }
                });
            }
            graph.set(gauge.name, Array.from(neighbors.values()));
        });

        // Dijkstra's algorithm
        const distances = new Map();
        const prev = new Map();
        const pq = new Set();

        allGauges.forEach(g => {
            distances.set(g.name, Infinity);
            prev.set(g.name, null);
            pq.add(g.name);
        });

        distances.set(startGaugeName, 0);

        while (pq.size > 0) {
            let u = null;
            pq.forEach(gaugeName => {
                if (u === null || distances.get(gaugeName) < distances.get(u)) {
                    u = gaugeName;
                }
            });

            if (u === endGaugeName) break;
            if (u === null) break;

            pq.delete(u);

            const uNeighbors = graph.get(u) || [];
            uNeighbors.forEach(neighbor => {
                const alt = distances.get(u) + neighbor.weight;
                if (alt < distances.get(neighbor.node)) {
                    distances.set(neighbor.node, alt);
                    prev.set(neighbor.node, u);
                }
            });
        }

        // Reconstruct path
        const path = [];
        let current = endGaugeName;
        if (prev.get(current) || current === startGaugeName) {
            while (current) {
                path.unshift(gaugeMap.get(current));
                current = prev.get(current);
            }
        }

        return (path.length > 0 && path[0].name === startGaugeName) ? path : null;
    };


    // --- SHIP DATA AND CALCULATION LOGIC ---
// §19.02 – Motorschiffe & Schubboote (GMS)
const CREW_GMS_STUFE1 = { // L ≤ 70 m
    'A1': { 'S1': 2, 'S2': 2 },
    'A2': { 'S1': 2, 'S2': 2 },
    'B':  { 'S1': 4, 'S2': 4 }
};

const CREW_GMS_STUFE2 = { // 70 m < L ≤ 86 m
    'A1': { 'S1': 2, 'S2': 3 },
    'A2': { 'S1': 3, 'S2': 3 },
    'B':  { 'S1': 4, 'S2': 4 }
};

const CREW_GMS_STUFE3 = { // L > 86 m
    'A1': { 'S1': 3, 'S2': 3 },
    'A2': { 'S1': 4, 'S2': 4 },
    'B':  { 'S1': 4, 'S2': 5 }
};

// §19.03 – Starre Verbände & andere starre Zusammenstellungen (KVB)
const CREW_KVB_STUFE1 = { // L ≤ 37 m / B ≤ 15 m
    'A1': { 'S1': 2, 'S2': 2 },
    'A2': { 'S1': 2, 'S2': 2 },
    'B':  { 'S1': 4, 'S2': 4 }
};

const CREW_KVB_STUFE2 = { // 37 m < L ≤ 86 m / B ≤ 15 m
    'A1': { 'S1': 2, 'S2': 3 },
    'A2': { 'S1': 3, 'S2': 3 },
    'B':  { 'S1': 4, 'S2': 4 }
};

const CREW_KVB_STUFE3 = { // Schubboot + 1 Leichter > 86 m OR L 86–116,5 m / B ≤ 15 m
    'A1': { 'S1': 3, 'S2': 3 },
    'A2': { 'S1': 4, 'S2': 4 },
    'B':  { 'S1': 4, 'S2': 5 }
};

const CREW_KVB_STUFE4 = { // Schubboot + 2 Schubleichter / Motorschiff + 1 Schubleichter
    'A1': { 'S1': 4, 'S2': 4 },
    'A2': { 'S1': 5, 'S2': 5 },
    'B':  { 'S1': 5, 'S2': 5 }
};

const CREW_KVB_STUFE5 = { // Schubboot + 3+ Schubleichter / Motorschiff + 2+ Schubleichter
    'A1': { 'S1': 5, 'S2': 5 },
    'A2': { 'S1': 6, 'S2': 6 },
    'B':  { 'S1': 6, 'S2': 6 }
};

    // RAW_SHIP_DATA moved into component scope below

    // JS implementation of a simple linear regression
    function linearRegression(points) { // points is an array of {x: draft, y: tonnage}
        let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
        const n = points.length;
        if (n < 2) return { m: 0, c: n === 1 ? points[0].y : 0 };

        for (const p of points) {
            sumX += p.x;
            sumY += p.y;
            sumXY += p.x * p.y;
            sumX2 += p.x * p.x;
        }

        const denominator = (n * sumX2 - sumX * sumX);
        if (Math.abs(denominator) < 1e-9) {
             return { m: 0, c: sumY / n };
        }

        const m = (n * sumXY - sumX * sumY) / denominator;
        const c = (sumY - m * sumX) / n;

        return { m, c }; // Represents y = mx + c
    }

    // Process raw ship data to add calculation functions
    function processShipData(shipDataList, customShips) {
        const allShipsList = [...shipDataList, ...customShips];
        const shipDict = new Map(allShipsList.map(ship => [ship.id, ship]));
        const processedList = [];

        // First pass: Calculate fit for ships with data arrays or custom definitions
        allShipsList.forEach(ship => {
            const newShip = { ...ship };
            if (newShip.creationMethod) { // Process custom ships
                switch(newShip.creationMethod) {
                    case 'tpc':
                        const m_tpc = (newShip.tpc || 0) * 100; // t/cm -> t/m
                        const c_tpc = -(newShip.emptyDraft || 0) * m_tpc;
                        newShip.fitParams = { m: m_tpc, c: c_tpc };
                        newShip.fitFunc = (draft) => m_tpc * draft + c_tpc;
                        break;
                    case 'points':
                        const points = newShip.points || [];
                        const {m: m_pts, c: c_pts} = linearRegression(points.map(p => ({x: p.draft, y:p.tonnage})));
                        newShip.fitParams = {m: m_pts, c: c_pts};
                        newShip.fitFunc = (draft) => m_pts * draft + c_pts;
                        break;
                    case 'inherit':
                        // This requires a second pass after all base ships are processed
                        break;
                }
            } else if (Array.isArray(newShip.draft) && newShip.draft.length > 0) {
                const points = newShip.draft.map((d, i) => ({ x: d, y: newShip.tonnage[i] }));
                const { m, c } = linearRegression(points);
                newShip.fitParams = { m, c };
                newShip.fitFunc = (draft) => m * draft + c;
            } else if (typeof newShip.draft === 'number') { // Handle components with single draft value
                newShip.fitParams = { m: 0, c: newShip.tonnage?.[0] || 0 };
                newShip.fitFunc = (draft) => newShip.fitParams.c;
            }
            processedList.push(newShip);
        });

        const processedDict = new Map(processedList.map(ship => [ship.id, ship]));

        // Second pass: Handle inherited slopes for single-point ships and custom ships
        processedList.forEach(ship => {
            const handleInheritance = (sourceShipId, singlePoint) => {
                 const sourceShip = processedDict.get(sourceShipId);
                if (sourceShip && sourceShip.fitParams) {
                    const m = sourceShip.fitParams.m;
                    const c = singlePoint.y - m * singlePoint.x;
                    ship.fitParams = { m, c };
                    ship.fitFunc = (draft) => m * draft + c;
                }
            };

            if (ship.use_slope_from && ship.draft && ship.tonnage) {
                handleInheritance(ship.use_slope_from, { x: ship.draft[0], y: ship.tonnage[0] });
            } else if (ship.creationMethod === 'inherit' && ship.points && ship.points.length > 0) {
                 handleInheritance(ship.baseShip, { x: ship.points[0].draft, y: ship.points[0].tonnage });
            }

             // Calculate and store max tonnage
            if(ship.fitFunc && ship.max_draft) {
                ship.max_tonnage = ship.fitFunc(ship.max_draft);
            } else if (Array.isArray(ship.tonnage) && ship.tonnage.length > 0) {
                 ship.max_tonnage = Math.max(...ship.tonnage);
            }
        });
        return processedList;
    }

    // Create virtual convoy vessels
    function createCombination(id, name, components, baseVesselsDict, options) {
        let combined_m = 0;
        let combined_c = 0;
        const all_min_drafts = [];
        const barge_max_drafts = [];

        for (const [compId, count] of components) {
            const comp = baseVesselsDict.get(compId);
            if (!comp || !comp.fitParams) {
                console.warn(`Component '${compId}' not found for combo '${name}'.`);
                return null;
            }
            combined_m += comp.fitParams.m * count;
            combined_c += comp.fitParams.c * count;

            all_min_drafts.push(comp.min_draft || 0);
            if (!compId.includes('pusher')) {
                barge_max_drafts.push(comp.max_draft || 10);
            }
        }

        const final_min_draft = Math.max(...all_min_drafts);
        const final_max_draft = barge_max_drafts.length > 0 ? Math.min(...barge_max_drafts) : final_min_draft;

        const fitFunc = (draft) => combined_m * draft + combined_c;

        return {
            id, name,
            length: options.length,
            width: options.width,
            fitParams: { m: combined_m, c: combined_c },
            fitFunc,
            min_draft: final_min_draft,
            max_draft: final_max_draft,
            max_tonnage: fitFunc(final_max_draft),
            category: options.category || 'dry_cargo',
            min_crew_required: options.crew,
            is_combo: true,
            components, // Store for constraint checking
        };
    }

    // --- NEW HELPER: Check if a ship is allowed on a route based on dimensional/gauge rules ---
            // --- NEW HELPER: Check if a ship is allowed on a route based on dimensional/gauge rules ---
            const isShipAllowed = (ship, routeGauges, travelDirection, gaugeApiData, t) => {
            if (!routeGauges || routeGauges.length < 2) {
                return { allowed: true, warnings: [] };
            }

            let isAllowed = true;
            const warnings = new Set(); // Use a Set to avoid duplicate warnings
            const gaugeNames = routeGauges.map(g => g.name);
            const rivers = [...new Set(routeGauges.map(g => g.river))];

            const isConvoy = ship.is_combo || ship.name.toLowerCase().includes('convoy') || ship.name.toLowerCase().includes('duwstel') || ship.name.toLowerCase().includes('verband');
            const isRhenus1Barge = ship.id === 'kvb_rhenus_1_bak';

            const addRhenusWarning = () => {
                warnings.add(t('constraintRhenusOnDanube'));
                warnings.add(t('constraintRhenusTooLongMDK', { length: ship.length, overage: (ship.length - 190).toFixed(0) }));
            };

            // --- MDK Check (Mainz-Kelheim) ---
            const isOnMDK = gaugeNames.includes('Kelheim') && (gaugeNames.includes('Mainz') || rivers.includes('Rijn'));
            if (isOnMDK) {
                const isOversizedForMDK = (isConvoy && (ship.length > 190 || ship.width > 11.45)) || (!isConvoy && (ship.length > 135 || ship.width > 11.45));
                if (isOversizedForMDK) {
                    if (isRhenus1Barge) {
                        addRhenusWarning();
                    } else {
                        isAllowed = false;
                        warnings.add(t('constraintShipTooWideMDK'));
                        if (ship.id === 'kvb_rhenus_3_bak') {
                             warnings.add(t('constraintRhenusTooLongMDK', { length: ship.length, overage: (ship.length - 190).toFixed(0) }));
                        }
                    }
                }
            }

            // --- Danube Sections Check ---
            const donauGauges = routeGauges.filter(g => g.river === 'Donau');
            if (donauGauges.length > 0) {
                const allDonauKm = donauGauges.map(g => g.km);
                const minRouteKm = Math.min(...allDonauKm); // downstream point
                const maxRouteKm = Math.max(...allDonauKm); // upstream point

                const routeOverlaps = (sectionUpstreamKm, sectionDownstreamKm) => {
                    return maxRouteKm > sectionDownstreamKm && minRouteKm < sectionUpstreamKm;
                };

                // Section 1: Kelheim (2410) to Regensburg (2377) - Same rules as MDK
                if (routeOverlaps(2410, 2377)) {
                    const isOversized = (isConvoy && (ship.length > 190 || ship.width > 11.45)) || (!isConvoy && (ship.length > 135 || ship.width > 11.45));
                    if (isOversized) {
                        if (isRhenus1Barge) {
                            addRhenusWarning();
                        } else {
                            isAllowed = false;
                            warnings.add(t('constraintDanubeKelheimRegensburg'));
                        }
                    }
                }

                // Section 2 & 4: Regensburg (2377) -> Straubing (2306) AND Vilshofen (2249) -> Passau (2227)
                if (routeOverlaps(2377, 2306) || routeOverlaps(2249, 2227)) {
                    if (ship.length > 190 || ship.width > 22.90) {
                        if (isRhenus1Barge) {
                           addRhenusWarning();
                        } else {
                            isAllowed = false;
                            warnings.add(t('constraintDanubeRegensburgPassauWide'));
                        }
                    }
                }

                // Section 3: Straubing (2306) to Vilshofen (2249) - Complex rules
                if (routeOverlaps(2306, 2249)) {
                    // Upstream wide convoy rule (Rhenus width is OK, so no special handling needed here)
                    if (travelDirection === 'upstream' && ship.width > 11.45 && ship.length > 135) {
                        const hofkirchenLevel = gaugeApiData['Hofkirchen']?.currentLevel;
                        if (hofkirchenLevel === null || hofkirchenLevel === undefined) {
                            warnings.add(t('constraintHofkirchenUnknown'));
                        } else if (hofkirchenLevel < 350) {
                            isAllowed = false;
                            warnings.add(t('constraintHofkirchenLow', { currentLevel: hofkirchenLevel.toFixed(0) }));
                        }
                    }
                    // Downstream dimension rule
                    if (travelDirection === 'downstream') {
                        const isOkForDownstream = (ship.length <= 190 && ship.width <= 11.45) || (ship.length <= 135 && ship.width <= 22.90);
                        if (!isOkForDownstream) {
                             if (isRhenus1Barge) {
                                addRhenusWarning();
                             } else {
                                isAllowed = false;
                                warnings.add(t('constraintDanubeDownstreamStraubingVilshofen'));
                             }
                        }
                    }
                }
            }

            // --- IJssel and Rhine Checks (preserved and adjusted) ---
            if (rivers.includes('IJssel')) {
                if (ship.length > 110 || ship.width > 11.45) {
                    isAllowed = false;
                    warnings.add(t('constraintShipTooLargeIJssel'));
                }
            }
            const rhineGauges = routeGauges.filter(g => ['Rijn', 'Waal', 'Pannerdens Kanaal'].includes(g.river));
            if (rhineGauges.length > 1) {
                const minRhineKm = Math.min(...rhineGauges.map(g => g.km));
                const maxRhineKm = Math.max(...rhineGauges.map(g => g.km));
                const is6Barge = ship.is_combo && ship.components && ship.components.some(([id, count]) => id === 'rhine_barge' && count >= 6);

                if (is6Barge && travelDirection === 'upstream' && minRhineKm < 564.30) {
                    isAllowed = false;
                    warnings.add(t('constraint6BargeUpstream'));
                }
            }

            return { allowed: isAllowed, warnings: Array.from(warnings) };
        };



// --- React Component ---
function RhineDraftCalculator() {
        const { t, locale, weekdays, language, setLanguage } = useContext(I18nContext);

        const RAW_SHIP_DATA = useMemo(() => (
[
// --- MOTOR VESSELS (GMS - Dry Cargo) ---
{ 'id': 'riposa', 'name': `135x14.27m, ${t('shipDescWideExtraLongGMS')}`, length: 14.27, width: 14.27, 'draft': [2.5, 3, 3.76], 'tonnage': [2749, 3651, 5040], 'min_draft': 1.6, 'max_draft': 3.76, 'category': 'dry_cargo', 'min_crew_required': CREW_GMS_STUFE3 },
{ 'id': 'avelie', 'name': `135x11.45m, ${t('shipDescExtraLongGMSLightweight')}`, length: 135, width: 11.45, 'draft': [3.41], 'tonnage': [3842], 'min_draft': 1.4, 'max_draft': 3.41, 'category': 'dry_cargo', 'use_slope_from': 'ares', 'min_crew_required': CREW_GMS_STUFE3 },
{ 'id': 'animo', 'name': `135x11.45m, ${t('shipDescExtraLongGMSHeavy')}`, length: 135, width: 11.45, 'draft': [1.9, 2.2, 2.5, 2.8, 3, 3.61], 'tonnage': [1356, 1788, 2224, 2664, 2960, 3867], 'min_draft': 1.4, 'max_draft': 3.61, 'category': 'dry_cargo', 'min_crew_required': CREW_GMS_STUFE3 },
{ 'id': 'elan', 'name': `110x11.45m, ${t('shipDescGMSSunriseShallow')}`, length: 110, width: 11.45, 'draft': [0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.5, 1.9, 2.2, 2.5, 2.8, 3, 3.19], 'tonnage': [0.0, 107.757, 217.074, 327.134, 437.963, 550.1, 896.5, 1368.6, 1724.5, 2081.6, 2439.4, 2678.6, 2907.6], 'min_draft': 1.1, 'max_draft': 3.19, 'category': 'dry_cargo', 'min_crew_required': CREW_GMS_STUFE3 },
//{ 'id': 'paul', 'name': '110x11.45m, MBS Paul (Niedrigwasser)', length: 110, width: 11.45, 'draft': [2.8, 3.05], 'tonnage': [2500, 2810], 'min_draft': 1.1, 'max_draft': 3.05, 'category': 'dry_cargo', 'min_crew_required': CREW_GMS_STUFE3 },
{ 'id': 'houdou', 'name': `110x11.45m, ${t('shipDescGMSStandard')}`, length: 110, width: 11.45, 'draft': [1.9, 2.2, 2.5, 2.8, 3, 3.5], 'tonnage': [1116, 1463, 1813, 2167, 2404, 3004], 'min_draft': 1.4, 'max_draft': 3.5, 'category': 'dry_cargo', 'min_crew_required': CREW_GMS_STUFE3 },
{ 'id': 'cds_dry', 'name': `110x11.45m, ${t('shipDescGMSCDSShallow')}`, length: 110, width: 11.45, 'draft': [2, 2.5, 3.0, 3.5, 3.75], 'tonnage': [1400, 2000, 2600, 3230, 3550], 'min_draft': 1.2, 'max_draft': 3.75, 'category': 'dry_cargo', 'min_crew_required': CREW_GMS_STUFE3 },
{ 'id': 'jowi_container', 'name': `135x16.8m, ${t('shipDescJowiContainer')}`, length: 135, width: 16.8, 'draft': [1.6, 3.5], 'tonnage': [1300, 5200], 'min_draft': 1.6, 'max_draft': 3.5, 'category': 'dry_cargo', 'min_crew_required': CREW_GMS_STUFE3 },
{ 'id': 'Manacor_europaschip', 'name': `85x9.60m, ${t('shipDescEuropeSunriseShallow')}`, length: 85, width: 9.6, 'draft': [2.5, 3.2], 'tonnage': [1314, 1868], 'min_draft': 1.0, 'max_draft': 3.2, 'category': 'dry_cargo', 'min_crew_required': CREW_GMS_STUFE2 },
{ 'id': 'Amigos_europaschip', 'name': `85x9.60m, ${t('shipDescEuropeStandard')}`, length: 85, width: 9.6, 'draft': [2.2, 2.5, 2.8, 3, 3.28], 'tonnage': [964, 1184, 1405, 1554, 1765], 'min_draft': 1.2, 'max_draft': 3.28, 'category': 'dry_cargo', 'min_crew_required': CREW_GMS_STUFE2 },
{ 'id': 'Bausyl_dortmunder', 'name': `67x8,20m, ${t('shipDescDortmunder')}`, length: 67, width: 8.2, 'draft': [2.2, 2.5, 2.52], 'tonnage': [690, 840, 850], 'min_draft': 0.9, 'max_draft': 2.52, 'category': 'dry_cargo', 'min_crew_required': CREW_GMS_STUFE2 },
{ 'id': 'Serfra_dortmunder', 'name': `80x8,20m, ${t('shipDescDortmunderExtended')}`, length: 80, width: 8.2, 'draft': [2.2, 2.5, 2.74], 'tonnage': [940, 1120, 1269], 'min_draft': 0.9, 'max_draft': 2.74, 'category': 'dry_cargo', 'min_crew_required': CREW_GMS_STUFE1 },
//{ 'id': 'courage', 'name': '110m, Courage', length: 110, width: 11.45, 'draft': [4.05], 'tonnage': [3550], 'min_draft': 1.4, 'max_draft': 4.05, 'category': 'dry_cargo', 'use_slope_from': 'houdou', 'min_crew_required': CREW_GMS_STUFE3 },
//{ 'id': 'vigilia_II', 'name': '135m, Vigilia II', length: 135, width: 11.45, 'draft': [3.61], 'tonnage': [3860], 'min_draft': 1.4, 'max_draft': 3.61, 'category': 'dry_cargo', 'use_slope_from': 'animo', 'min_crew_required': CREW_GMS_STUFE3 },
//{ 'id': 'threant', 'name': '110m, Threant', length: 110, width: 11.45, 'draft': [4.0], 'tonnage': [3650], 'min_draft': 1.4, 'max_draft': 4.0, 'category': 'dry_cargo', 'use_slope_from': 'houdou', 'min_crew_required': CREW_GMS_STUFE3 },
{ 'id': 'pushed_elbe', 'name': `129x9,60m, ${t('shipDescElbeConvoy')}`, length: 129, width: 9.5, 'draft': [1.0, 2.1], 'tonnage': [540, 1800], 'min_draft': 1.0, 'max_draft': 2.1, 'category': 'dry_cargo', 'min_crew_required': CREW_KVB_STUFE4 },
// --- TANKERS ---
{ 'id': 'excellence', 'name': `110x11.45m, ${t('shipDescGMSEcoNomyShallow')}`, length: 110, width: 11.45, 'draft': [0.87, 1, 1.5, 2, 2.5, 3, 3.31], 'tonnage': [0, 141.373, 702.259, 1285.964, 1880.786, 2482.899, 2859.073], 'min_draft': 1.3, 'max_draft': 3.31, 'category': 'tanker', 'min_crew_required': CREW_GMS_STUFE3 },
{ 'id': 'stolt_ludwigshafen', 'name': `135x17.5m, ${t('shipDescStoltLudwigshafenShallow')}`, length: 135, width: 17.5, 'draft': [1.2, 2.05, 3.24], 'tonnage': [650, 2500, 5100], 'min_draft': 1.2, 'max_draft': 3.24, 'category': 'tanker', 'min_crew_required': CREW_GMS_STUFE3 },
{ 'id': 'carpe_auroram', 'name': `135x17.5m, ${t('shipDescWideExtraLongGMS')}`, length: 135, width: 17.5, 'draft': [5.0], 'tonnage': [8656], 'min_draft': 1.2, 'max_draft': 5.0, 'category': 'tanker', 'use_slope_from': 'stolt_ludwigshafen', 'min_crew_required': CREW_GMS_STUFE3 },
{ 'id': 'sunrise_tanker_110m', 'name': `110x11.45m, ${t('shipDescGMSSunriseShallow')}`, length: 110, width: 11.45, 'draft': [2, 2.5, 3.13], 'tonnage': [1339, 1934, 2690], 'min_draft': 1.1, 'max_draft': 3.13, 'category': 'tanker', 'min_crew_required': CREW_GMS_STUFE3 },
{ 'id': 'normale_tanker', 'name': `110x11.45m, ${t('shipDescGMSStandard')}`, length: 110, width: 11.45, 'draft': [1.5, 2, 2.5, 2.6, 2.8, 3, 3.5, 3.6], 'tonnage': [530, 1105, 1690, 1808, 2045, 2284, 2884, 3005], 'min_draft': 1.5, 'max_draft': 3.6, 'category': 'tanker', 'min_crew_required': CREW_GMS_STUFE3 },
{ 'id': 'normale_tanker_85m', 'name': `85x9.60m, ${t('shipDescEuropeStandard')}`, length: 85, width: 9.6, 'draft': [2.2, 2.8, 3.1], 'tonnage': [900, 1363, 1598], 'min_draft': 1.3, 'max_draft': 3.1, 'category': 'tanker', 'min_crew_required': CREW_GMS_STUFE2 },
{ 'id': 'sunrise_tanker_85m', 'name': `85x9.60m, ${t('shipDescEuropeSunriseShallow')}`, length: 85, width: 9.6, 'draft': [3.3], 'tonnage': [1908], 'min_draft': 1.0, 'max_draft': 3.3, 'category': 'tanker', 'use_slope_from': 'normale_tanker_85m', 'min_crew_required': CREW_GMS_STUFE2 },
// --- PRE-DEFINED CONVOYS (KVB) - Re-categorized as dry_cargo ---
{ 'id': 'johanna', 'name': `186x11.45m, ${t('shipDescCoupledConvoyRhineDanube')}`, length: 186, width: 11.45, 'draft': [1.5, 2, 2.5, 2.6, 2.8, 3], 'tonnage': [1437, 2449, 3468, 3673, 4084, 4496], 'min_draft': 1.5, 'max_draft': 3.63, 'category': 'dry_cargo', 'min_crew_required': CREW_KVB_STUFE4 },
{ 'id': 'mediation', 'name': `172x11.45m, ${t('shipDescCoupledConvoyMosel')}`, length: 172, width: 11.45, 'draft': [1.5, 2, 2.5, 2.6, 2.8, 3.6], 'tonnage': [1317, 2232, 3153, 3339, 3711, 5209], 'min_draft': 1.3, 'max_draft': 3.6, 'category': 'dry_cargo', 'min_crew_required': CREW_KVB_STUFE4 },
{ 'id': 'kvb_rhenus_1_bak', 'name': `193x11.45m, ${t('shipDescRhenus1BargeShallow')}`, length: 193, width: 11.45, 'draft': [1.2, 2.9], 'tonnage': [1270, 4799], 'min_draft': 1.2, 'max_draft': 2.9, 'category': 'dry_cargo', 'min_crew_required': CREW_KVB_STUFE4 },
{ 'id': 'kvb_rhenus_3_bak', 'name': `193x22,90m, ${t('shipDescRhenus3BargeShallow')}`, length: 193, width: 22.9, 'draft': [1.2, 2.9], 'tonnage': [2750, 9318], 'min_draft': 1.2, 'max_draft': 2.9, 'category': 'dry_cargo', 'min_crew_required': CREW_KVB_STUFE5 },
// --- COMPONENTS (Not plotted directly) ---
{ 'id': 'ares', 'name': '135m, Ares', length: 135, width: 11.45, 'draft': [1.9, 2.2, 2.5, 2.8, 3, 3.82], 'tonnage': [1533.6, 1990.7, 2431.3, 2875.5, 3173.25, 4406], 'min_draft': 1.4, 'max_draft': 3.82, 'category': 'component', 'plot': false },
{ 'id': 'rhine_barge', 'name': 'Rijn Duwbak', length: 76.5, width: 11.45, 'draft': [0.61, 1, 1.5, 2, 2.5, 3, 3.5, 3.97], 'tonnage': [23.7, 333.2, 736.3, 1146.6, 1561.7, 1980.1, 2403.3, 2804.7], 'min_draft': 0.61, 'max_draft': 3.97, 'category': 'component', 'plot': false },
{ 'id': 'danube_barge', 'name': 'Donau Duwbak', length: 76, width: 11, 'draft': [0.45, 2.6], 'tonnage': [0, 1750], 'min_draft': 0.45, 'max_draft': 2.6, 'category': 'component', 'plot': false },
{ 'id': 'danube_tank_barge', 'name': 'Donau Tankduwbak', length: 76.5, width: 11, 'draft': [2.7], 'tonnage': [1709.6], 'min_draft': 0.63, 'max_draft': 2.7, 'category': 'component', 'use_slope_from': 'danube_barge', 'plot': false },
{ 'id': 'veerhaven_pusher', 'name': 'Veerhaven/Rijn Duwboot', length: 40, width: 15, 'draft': 1.75, 'min_draft': 1.75, 'max_draft': 1.75, 'tonnage': [0], 'category': 'component', plot: false },
{ 'id': 'tr27_pusher', 'name': 'TR27 Elbe/Donau Duwboot', length: 27, width: 8.7, 'draft': 1.0, 'min_draft': 1.0, 'max_draft': 1.0, 'tonnage': [0], 'category': 'component', plot: false },
{ 'id': 'donau_tankbarge_pusher', 'name': 'Aurora Donau Tanker Duwboot', length: 35, width: 10, 'draft': 1.3, 'min_draft': 1.3, 'max_draft': 1.6, 'tonnage': [0], 'category': 'component', plot: false },
]
), [t]);

        useEffect(() => { document.title = t('appTitle'); }, [t]);

        const [allGaugeStaticData, setAllGaugeStaticData] = useState([]);
        const [gaugeApiData, setGaugeApiData] = useState({});
        const [customCorrections, setCustomCorrections] = useState(() => getCookie('rhineDraftCorrections') || { upstream: {}, downstream: {} });
        const [forecastDates, setForecastDates] = useState([]);
        const [dataStatus, setDataStatus] = useState({status: 'pending', message: t('initializing')});
        const [lastUpdated, setLastUpdated] = useState(null);
        const [travelDirection, setTravelDirection] = useState('downstream');
        const [autoRefresh, setAutoRefresh] = useState(true);
        const [nextRefreshTime, setNextRefreshTime] = useState(null);
        const refreshButtonRef = useRef(null);
        const [journey, setJourney] = useState(() => getCookie('riverJourneys') || { 'Rijn/Waal': {start: 'Tiel', end: 'Emmerich'}, 'Donau': {start: 'Kelheim', end: 'Passau Donau'}, 'IJssel': {start: 'Katerveer', end: 'IJsselkop'}, 'all': { start: null, end: null } });
        const [activeTab, setActiveTab] = useState('planner');
        const [displayMode, setDisplayMode] = useState(() => getCookie('rhineDisplayMode') || 'draft');
        const [showUncertainty, setShowUncertainty] = useState(() => getCookie('rhineShowUncertainty') ?? false);
        const defaultStartDate = useMemo(() => {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }, []);


        const [routePlanResult, setRoutePlanResult] = useState(null);
        const [routePlanStatus, setRoutePlanStatus] = useState('idle');
                const [selectedRiver, setSelectedRiver] = useState(() => getCookie('selectedRiverContext') || 'all');
        // // const [forecastBaseTime, setForecastBaseTime] = useState(null); // Removed for gauge-specific logic // Removed for gauge-specific logic
                const [plannerSettings, setPlannerSettings] = useState(() => {
            const savedSettings = getCookie('rhinePlannerSettings');
            const defaultValues = {
                speedDownstream: 20,
                speedUpstream: 9,
                speedCanal: 7.1,
                operationalMode: 'A1',
                customOperationalHours: 14,
                excludedDays: [0, 6],
                customSegmentKm: 0,
                customSegmentSpeed: 0,
                customSegmentPosition: 'end',
            };
            // Always use current time for startDate, but keep other saved settings.
            return {
                ...defaultValues,
                ...(savedSettings || {}),
                startDate: defaultStartDate,
            };
        });

        const [cargoDraft, setCargoDraft] = useState(2.5);
        const [shipFilter, setShipFilter] = useState('all');
        const [customShips, setCustomShips] = useState(() => getCookie('customShips') || []);
        const [isCustomShipModalOpen, setIsCustomShipModalOpen] = useState(false);
        const [tonnageReferenceShipId, setTonnageReferenceShipId] = useState(getCookie('tonnageRefShip') || 'elan');

        const sentinelRef = useRef(null);
        const scrollWrapperRef = useRef(null);
        const originalTableRef = useRef(null);
        const originalTheadRef = useRef(null);
        const fixedHeaderContainerRef = useRef(null);
        const fixedHeaderTableRef = useRef(null);
        const isHeaderFixedRef = useRef(false);
        const [gaugesOnRoute, setGaugesOnRoute] = useState([]);

        const processedShipData = useMemo(() => {
            console.log("Processing and combining ship data...");
            const baseShips = processShipData(RAW_SHIP_DATA, customShips);
            const baseShipsDict = new Map(baseShips.map(s => [s.id, s]));

            // Special case: Somtrans LNG estimation
            const stolt = baseShipsDict.get('stolt_ludwigshafen');
            if (stolt && stolt.fitParams) {
                const source_slope_m = stolt.fitParams.m;
                const beam_ratio = 22.8 / 17.5;
                const somtrans_slope = source_slope_m * beam_ratio;
                const somtrans_intercept = 12652 - (somtrans_slope * 5.5);
                const somtrans_lng_ship = {
                    id: 'somtrans_lng', name: '135x22.8m, Somtrans LNG (est.)', length: 135, width: 22.8,
                    draft: [5.5], tonnage: [12652], min_draft: 1.2, max_draft: 5.5, category: 'tanker',
                    min_crew_required: CREW_GMS_STUFE3,
                    fitParams: { m: somtrans_slope, c: somtrans_intercept },
                    fitFunc: (draft) => somtrans_slope * draft + somtrans_intercept,
                    max_tonnage: 12652
                };
                baseShips.push(somtrans_lng_ship);
                baseShipsDict.set('somtrans_lng', somtrans_lng_ship);
            }

            const combos = [
                createCombination('kvb_donau_1', t('comboNamePushedDanube1'), [['tr27_pusher', 1], ['danube_barge', 1]], baseShipsDict, { length: 103.5, width: 11, crew: CREW_KVB_STUFE3, category: 'dry_cargo' }), // Max 2 for TR27
                createCombination('kvb_donau_2', t('comboNamePushedDanube2'), [['tr27_pusher', 1], ['danube_barge', 2]], baseShipsDict, { length: 180, width: 11, crew: CREW_KVB_STUFE4, category: 'dry_cargo' }), // Max 2 for TR27
                createCombination('kvb_donau_4', t('comboNamePushedDanube4'), [['donau_tankbarge_pusher', 1], ['danube_barge', 4]], baseShipsDict, { length: 180, width: 22, crew: CREW_KVB_STUFE5, category: 'dry_cargo' }),
                createCombination('kvb_donau_6', t('comboNamePushedDanube6'), [['donau_tankbarge_pusher', 1], ['danube_barge', 6]], baseShipsDict, { length: 229, width: 22, crew: CREW_KVB_STUFE5, category: 'dry_cargo' }),
                createCombination('kvb_rijn_4', t('comboNamePushedRhine4'), [['veerhaven_pusher', 1], ['rhine_barge', 4]], baseShipsDict, { length: 193, width: 22.9, crew: CREW_KVB_STUFE5, category: 'dry_cargo' }),
                createCombination('kvb_rijn_6', t('comboNamePushedRhine6'), [['veerhaven_pusher', 1], ['rhine_barge', 6]], baseShipsDict, { length: 270, width: 22.9, crew: CREW_KVB_STUFE5, category: 'dry_cargo' }), //or 193x34.35 in downstream formation
                createCombination('johanna_plus_2', t('comboNameJohannaPlus2'), [['johanna', 1], ['rhine_barge', 2]], baseShipsDict, { length: 186, width: 22.9, crew: CREW_KVB_STUFE5, category: 'dry_cargo' }),
                createCombination('animo_plus_2', t('comboNameAnimoPlus2'), [['animo', 1], ['rhine_barge', 2]], baseShipsDict, { length: 153, width: 22.9, crew: CREW_KVB_STUFE5, category: 'dry_cargo' }),
                createCombination('kvb_tanker_1', t('comboNameTanker1'), [['tr27_pusher', 1], ['danube_tank_barge', 1]], baseShipsDict, { length: 111.5, width: 11, crew: CREW_KVB_STUFE3, category: 'tanker' }),
                createCombination('kvb_tanker_2', t('comboNameTanker2'), [['tr27_pusher', 1], ['danube_tank_barge', 2]], baseShipsDict, { length: 188, width: 11, crew: CREW_KVB_STUFE4, category: 'tanker' }),
                createCombination('kvb_tanker_4', t('comboNameTanker4'), [['donau_tankbarge_pusher', 1], ['danube_tank_barge', 4]], baseShipsDict, { length: 188, width: 22, crew: CREW_KVB_STUFE5, category: 'tanker' }),
                createCombination('kvb_tanker_6', t('comboNameTanker6'), [['donau_tankbarge_pusher', 1], ['danube_tank_barge', 6]], baseShipsDict, { length: 264.5, width: 22, crew: CREW_KVB_STUFE5, category: 'tanker' }),

            ].filter(Boolean);

            return [...baseShips.filter(s => s.category !== 'component'), ...combos];
        }, [customShips]);


        // --- Effects ---
        useEffect(() => {
            if (!journey[selectedRiver]?.start || !journey[selectedRiver]?.end) {
                setGaugesOnRoute([]);
                return;
            }
            const path = findRoutePath( journey[selectedRiver].start, journey[selectedRiver].end, allGaugeStaticData, { downstream: 20, upstream: 9 } );
            setGaugesOnRoute(path || []);
        }, [journey, selectedRiver, allGaugeStaticData]);

        useEffect(() => {
            setDataStatus({status: 'pending', message: t('loadingStatic')});
            const CANAL_AVG_SPEED = 7.1;
            const CANAL_DISTANCE = 555;
            const combinedStaticList = [
                // --- Donau (Danube) Gauges ---
                { name: 'Ingolstadt', apiDataName: 'Ingolstadt Luitpoldstrasse', km: 2458, river: 'Donau', streckenAbschnitt: '2458-XXXX', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 0 },
                { name: 'Kelheim', apiDataName: 'Kelheim Donau', km: 2410, river: 'Donau', streckenAbschnitt: '2415-2399', giw: 250, depthAtGiw: 290, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0, connections: [{ targetGaugeName: 'Mainz', distance: CANAL_DISTANCE, speed: CANAL_AVG_SPEED, isCanal: true }] },
                { name: 'Oberndorf', km: 2397, river: 'Donau', streckenAbschnitt: '2397-2380', giw: 170, depthAtGiw: 290, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Schwabelweis', km: 2377, river: 'Donau', streckenAbschnitt: '2380-2355', giw: 292, depthAtGiw: 290, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Pfatter', km: 2351, river: 'Donau', streckenAbschnitt: '2354-2330', giw: 310, depthAtGiw: 290, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Pfelling', km: 2306, river: 'Donau', streckenAbschnitt: '2322-2290', giw: 290, depthAtGiw: 200, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Deggendorf', km: 2284, river: 'Donau', streckenAbschnitt: '2290-2282', giw: 210, depthAtGiw: 200, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Hofkirchen', km: 2257, river: 'Donau', streckenAbschnitt: '2282-2231', giw: 207, depthAtGiw: 200, officialSafetyMargin: 30, correctionOp: -8, correctionAf: -3, constraints: { convoyRule: { type: '4-barge-upstream', minLevel: 350, id: 'hofkirchen_4barge' } } },
                { name: 'Passau Donau', km: 2227, river: 'Donau', streckenAbschnitt: '2231-2204', giw: 415, depthAtGiw: 270, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                // --- Rhine and other gauges ---
                { name: 'Konstanz', km: 0, river: 'Rijn', streckenAbschnitt: '0-1', giw: 0, depthAtGiw: 0, officialSafetyMargin: 0, correctionOp: 0, correctionAf: 0 },
                { name: 'Iffezheim', km: 334, river: 'Rijn', streckenAbschnitt: '334-384', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 10, correctionAf: 20, customVuistregel: 80 },
                { name: 'Maxau', km: 362, river: 'Rijn', streckenAbschnitt: '335-384', giw: 372, depthAtGiw: 210, officialSafetyMargin: 30, correctionOp: 12, correctionAf: 12 },
                { name: 'Speyer', km: 400, river: 'Rijn', streckenAbschnitt: '384-410.5', giw: 237, depthAtGiw: 210, officialSafetyMargin: 30, correctionOp: 27, correctionAf: 27 },
                { name: 'Mannheim', km: 424, river: 'Rijn', streckenAbschnitt: '410.5-431.5', giw: 155, depthAtGiw: 210, officialSafetyMargin: 30, correctionOp: 30, correctionAf: 30 },
                { name: 'Worms', km: 443, river: 'Rijn', streckenAbschnitt: '431.5-462', giw: 68, depthAtGiw: 210, officialSafetyMargin: 30, correctionOp: 33, correctionAf: 33 },
                { name: 'Mainz', km: 498, river: 'Rijn', streckenAbschnitt: '462-508', giw: 171, depthAtGiw: 210, officialSafetyMargin: 30, correctionOp: 11, correctionAf: 11, connections: [{ targetGaugeName: 'Kelheim', distance: CANAL_DISTANCE, speed: CANAL_AVG_SPEED, isCanal: true }] },
                { name: 'Oestrich', km: 518, river: 'Rijn', streckenAbschnitt: '508-528', giw: 92, depthAtGiw: 190, officialSafetyMargin: 30, correctionOp: 42, correctionAf: 42 },
                { name: 'Bingen', km: 528, river: 'Rijn', streckenAbschnitt: '528-540', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 0, customVuistregel: 100 },
                { name: 'Kaub', km: 546, river: 'Rijn', streckenAbschnitt: '541-566', giw: 77, depthAtGiw: 190, officialSafetyMargin: 30, correctionOp: 17, correctionAf: 17, constraints: { maxWidth: 22.9, id: 'kaub_width'} },
                { name: 'Koblenz', km: 591, river: 'Rijn', streckenAbschnitt: '566-592', giw: 77, depthAtGiw: 210, officialSafetyMargin: 30, correctionOp: 27, correctionAf: 27 },
                { name: 'Koblenz (Mosel)', apiDataName: 'Koblenz', km: 592, river: 'Rijn', streckenAbschnitt: '592-601', giw: 77, depthAtGiw: 250, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Andernach', km: 613, river: 'Rijn', streckenAbschnitt: '601-624', giw: 91, depthAtGiw: 250, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Bonn', km: 655, river: 'Rijn', streckenAbschnitt: '624-660', giw: 142, depthAtGiw: 250, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Köln', km: 688, river: 'Rijn', streckenAbschnitt: '660-710', giw: 139, depthAtGiw: 250, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 9 },
                { name: 'Düsseldorf', km: 744, river: 'Rijn', streckenAbschnitt: '710-763', giw: 91, depthAtGiw: 250, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Duisburg-Ruhrort', km: 780, river: 'Rijn', streckenAbschnitt: '763-794', giw: 227, depthAtGiw: 280, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Wesel', km: 814, river: 'Rijn', streckenAbschnitt: '794-837', giw: 174, depthAtGiw: 280, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Emmerich', km: 852, river: 'Rijn', streckenAbschnitt: '837-857', giw: 74, depthAtGiw: 280, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Lobith', km: 862, river: 'Rijn', streckenAbschnitt: '857-867.5', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 0, customVuistregel: -478, connections: [{ targetGaugeName: 'Pannerdense kop' }, { targetGaugeName: 'Nijmegen' }], constraints: { convoyRule: { type: '6-barge', minLevel: 750, id: 'lobith_6barge' } } },
                { name: 'Nijmegen', km: 883, river: 'Waal', streckenAbschnitt: '867.5-893', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 0, customVuistregel: -260, connections: [{ targetGaugeName: 'Pannerdense kop' }, { targetGaugeName: 'Lobith' }] },
                { name: 'Tiel', km: 914, river: 'Waal', streckenAbschnitt: '893-930', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 0, customVuistregel: 10 },
                { name: 'Pannerdense kop', km: 867, river: 'Pannerdens Kanaal', streckenAbschnitt: 'PK 867.5-878.6', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 0, customVuistregel: -485, connections: [{ targetGaugeName: 'Lobith' }, { targetGaugeName: 'Nijmegen' }, { targetGaugeName: 'IJsselkop' }] },
                { name: 'IJsselkop', km: 878, river: 'IJssel', streckenAbschnitt: 'IJ 867-903', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 10, correctionAf: 20, customVuistregel: -480, connections: [{ targetGaugeName: 'Pannerdense kop' }] },
                { name: 'Doesburg', km: 903, river: 'IJssel', streckenAbschnitt: 'IJ 903-931', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 10, correctionAf: 20, customVuistregel: -200 },
                { name: 'Deventer', km: 931, river: 'IJssel', streckenAbschnitt: 'IJ 931-981', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 10, customVuistregel: 90 },
                { name: 'Katerveer', km: 981, river: 'IJssel', streckenAbschnitt: 'IJ 981-1005', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 10, customVuistregel: 270 },
                { name: 'Spijk - Woudrichem', km: 905, river: 'MGD', streckenAbschnitt: 'Waal km 857.7-952.5', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0, isMGDTarget: true, mgdKmRange: '857.7-952.5', alternativeNames: ['Spijk - Loevestein', 'Millingen - Woudrichem', 'Millingen - Loevestein'] },
                { name: 'Millingen tot Maas-Waalkanaal', km: 872, river: 'MGD', streckenAbschnitt: 'Waal km 857.7-887.0', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0, isMGDTarget: true, mgdKmRange: '857.7-887.0', alternativeNames: ['Spijk - Maas-WaalKanaal', 'Millingen - Maas-Waalkanaal'] },
                { name: 'Maas-Waalkanaal tot Amsterdam-Rijnkanaal', km: 900, river: 'MGD', streckenAbschnitt: 'Waal km 887.0-913.3', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0, isMGDTarget: true, mgdKmRange: '887.0-913.3', alternativeNames: ['Maas-Waalkan tot A\'dam-Rijnkanaal', 'Maas-Waalkanaal tot A\'dam-Rijnkanaal', 'Maas-Waalkanaal - A\'dam-Rijnkanaal', 'Maas-Waalkanaal - Amsterdam-Rijnkanaal'] },
                { name: 'Amsterdam-Rijnkanaal tot Loevestein', km: 933, river: 'MGD', streckenAbschnitt: 'Waal km 913.3-952.5', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0, isMGDTarget: true, mgdKmRange: '913.3-952.5', alternativeNames: ['A\'dam-Rijnkanaal tot Loevestein', 'A\'dam-Rijnkanaal tot Woudrichem', 'A\'dam-Rijnkanaal - Woudrichem', 'Amsterdam-Rijnkanaal - Loevestein'] },
                { name: 'Pannerdensche Kop - IJsselkop', km: 872, river: 'MGD', streckenAbschnitt: 'Pannerdensch Kanaal km 867.5-878.6', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0, alternativeNames: ['Pannerdens Kop - IJsselkop'] },
                { name: 'IJsselkop - Driel', km: 881, river: 'MGD', streckenAbschnitt: 'Nederrijn km 878.6-891.0', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'Driel - Heteren', km: 893, river: 'MGD', streckenAbschnitt: 'Nederrijn km 891.0-895.0', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'Heteren - Amsterdam-Rijnkanaal', km: 913, river: 'MGD', streckenAbschnitt: 'Nederrijn km 895.0-929.0', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0, alternativeNames: ['Heteren - A\'dam-Rijnkanaal'] },
                { name: 'Amsterdam-Rijnkanaal - Hagestein', km: 938, river: 'MGD', streckenAbschnitt: 'Lek km 929.0-947.0', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0, alternativeNames: ['A\'dam-Rijnkanaal - Hagestein'] },
                { name: 'IJsselkop - Twenthekanaal', km: 900, river: 'MGD', streckenAbschnitt: 'IJssel km 878.6-931.0', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0, },
                { name: 'Twenthekanaal - Zwolle-IJsselkanaal', km: 956, river: 'MGD', streckenAbschnitt: 'IJssel km 931.0-981.0', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0, },
                { name: 'Uitvaartdiepte Oostsluis Weurt', km: 887, river: 'MGD', streckenAbschnitt: 'Oostsluis Weurt', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'Uitvaartdiepte Westsluis Weurt', km: 887.1, river: 'MGD', streckenAbschnitt: 'Westsluis Weurt', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 }
            ];

            const processedStaticData = combinedStaticList.map(g => ({
                ...g,
                giw: g.giw ?? 'N/A',
                depthAtGiw: g.depthAtGiw ?? 'N/A',
                officialSafetyMargin: g.officialSafetyMargin === undefined ? 'N/A' : g.officialSafetyMargin,
                isMainRoute: MAIN_ROUTE_RIVERS.includes(g.river)
            })).sort((a, b) => {
                const riverOrder = { 'Rijn': 1, 'Pannerdens Kanaal': 2, 'Waal': 3, 'Nederrijn': 4, 'Lek': 5, 'IJssel': 6, 'MGD': 7, 'Unknown': 99 };
                const riverA = a.river || 'Unknown';
                const riverB = b.river || 'Unknown';
                const orderA = riverOrder[riverA] || 99;
                const orderB = riverOrder[riverB] || 99;
                if (orderA !== orderB) return orderA - orderB;
                const kmA = a.km === undefined || a.km === null ? Infinity : a.km;
                const kmB = b.km === undefined || b.km === null ? Infinity : b.km;
                return kmA - kmB;
            });
            setAllGaugeStaticData(processedStaticData);
            const savedCorrections = getCookie('rhineDraftCorrections');
            const defaultCorrections = {upstream: {}, downstream: {}};
            processedStaticData.forEach(gauge => {
                defaultCorrections.upstream[gauge.name] = gauge.correctionOp === undefined ? 0 : gauge.correctionOp;
                defaultCorrections.downstream[gauge.name] = gauge.correctionAf === undefined ? 0 : gauge.correctionAf;
            });
            const mergedCorrections = {
                upstream: {...defaultCorrections.upstream, ...(savedCorrections?.upstream || {})},
                downstream: {...defaultCorrections.downstream, ...(savedCorrections?.downstream || {})}
            };
            setCustomCorrections(mergedCorrections);
            setDataStatus({status: 'success', message: t('staticLoaded')});
        }, [t]);

        const loadGaugeApiData = useCallback(async (force = false) => {
            setDataStatus({status: 'pending', message: t('fetchingData')});
            if (refreshButtonRef.current) refreshButtonRef.current.disabled = true;
            try {
                const apiResponse = await fetchConsolidatedData(force);
                const newApiData = {};
                let successfulUpdates = 0;
                let apiGaugeCount = 0;
                let warningMessages = [];
                let errorMessages = [];
                let overallStatus = 'success';
                let latestApiTimestamp = 0;
                const todayDate = new Date();
                const nlYear = todayDate.toLocaleDateString('en-CA', {year: 'numeric', timeZone: 'Europe/Amsterdam'});
                const nlMonth = todayDate.toLocaleDateString('en-CA', {month: '2-digit', timeZone: 'Europe/Amsterdam'});
                const nlDay = todayDate.toLocaleDateString('en-CA', {day: '2-digit', timeZone: 'Europe/Amsterdam'});
                const todayStr = `${nlYear}-${nlMonth}-${nlDay}`;
                apiGaugeCount = Object.keys(apiResponse).length;
                Object.entries(apiResponse).forEach(([apiGaugeName, data]) => {
                    if (data.status === 'OK' || data.status === 'WARNING') successfulUpdates++; else if (data.status?.startsWith('CACHED')) {
                        successfulUpdates++;
                        if (data.status !== 'CACHED' && data.status !== 'CACHED_UNCHANGED') {
                            warningMessages.push(`${apiGaugeName}: ${data.status} (${data.error || 'stale/partial'})`);
                            if (overallStatus !== 'error') overallStatus = 'warning';
                        }
                    } else {
                        errorMessages.push(`${apiGaugeName}: ${data.error || data.status || 'Unknown error'}`);
                        overallStatus = 'error';
                    }
                    if (data.error && data.status !== 'ERROR' && !data.status?.startsWith('CACHED')) {
                        warningMessages.push(`${apiGaugeName}: ${data.error}`);
                        if (overallStatus !== 'error') overallStatus = 'warning';
                    }
                    if (data.lastUpdated) {
                        try {
                            const t = new Date(data.lastUpdated).getTime();
                            if (!isNaN(t) && t > latestApiTimestamp) latestApiTimestamp = t;
                        } catch (e) {}
                    }
                });
                allGaugeStaticData.forEach(staticGauge => {
                    const apiLookupKey = staticGauge.apiDataName || staticGauge.name;
                    const rawData = apiResponse[apiLookupKey];
                    const displayKey = staticGauge.name;
                    if (rawData) {
                        const processedForecasts = {};
                        if (rawData.forecasts) {
                            Object.entries(rawData.forecasts).forEach(([dateStr, timeEntries]) => {
                                if (dateStr >= todayStr) {
                                    const validTimeEntries = {};
                                    Object.entries(timeEntries).forEach(([timeStr, forecastData]) => {
                                        if (timeStr.match(/^\d{2}:\d{2}$/) && forecastData && forecastData.value !== undefined && forecastData.value !== null) {
                                            validTimeEntries[timeStr] = {
                                                value: forecastData.value,
                                                low_80: forecastData.low_80 ?? null,
                                                high_80: forecastData.high_80 ?? null
                                            };
                                        }
                                    });
                                    if (Object.keys(validTimeEntries).length > 0) {
                                        processedForecasts[dateStr] = validTimeEntries;
                                    }
                                }
                            });
                        }
                        newApiData[displayKey] = {
                            apiName: apiLookupKey,
                            currentLevel: rawData.currentLevel ?? null,
                            currentTime: formatTimeDisplay(rawData.currentTime || rawData.lastUpdated, locale),
                            currentTrend: rawData.currentTrend ?? null,
                            forecasts: processedForecasts,
                            weeklyForecasts: rawData.weeklyForecasts ?? null,
                            status: rawData.status || 'ERROR',
                            error: rawData.error || null,
                            river: staticGauge.river || rawData.river || 'Unknown',
                            region: staticGauge.region || rawData.region || 'unknown',
                            source: rawData.source || {measurement: null, forecast: null},
                            lastUpdated: rawData.lastUpdated || null,
                            giw: staticGauge.giw,
                            depthAtGiw: staticGauge.depthAtGiw,
                            officialSafetyMargin: staticGauge.officialSafetyMargin,
                            customVuistregel: staticGauge.customVuistregel,
                            isMGDTarget: staticGauge.isMGDTarget
                        };
                    }
                });
                                setGaugeApiData(newApiData);
                let earliestForecastDateTime = null;
                Object.values(newApiData).forEach(gaugeData => {
                    if (gaugeData.forecasts) {
                        Object.entries(gaugeData.forecasts).forEach(([dateStr, timeEntries]) => {
                            if (dateStr >= todayStr) { // Only consider today or future forecasts
                                Object.keys(timeEntries).forEach(timeStr => {
                                    try {
                                        // Create a date object assuming local time, consistent with browser behavior
                                        const forecastDateTime = new Date(`${dateStr}T${timeStr}:00`);
                                        if (!isNaN(forecastDateTime.getTime())) {
                                            if (earliestForecastDateTime === null || forecastDateTime < earliestForecastDateTime) {
                                                earliestForecastDateTime = forecastDateTime;
                                            }
                                        }
                                    } catch(e) {/* ignore parsing errors */}
                                });
                            }
                        });
                    }
                });

                const futureDates = [];
                if (earliestForecastDateTime) {
                    const hours = String(earliestForecastDateTime.getHours()).padStart(2, '0');
                    const minutes = String(earliestForecastDateTime.getMinutes()).padStart(2, '0');
                    // // setForecastBaseTime(`${hours}:${minutes}`); // Removed for gauge-specific logic // Removed for gauge-specific logic

                    let currentDate = new Date(earliestForecastDateTime.getTime());
                    // Loop to generate forecast dates, starting with the date of the earliest forecast.
                    // A safety break (i < MAX_FORECAST_DAYS + 5) prevents infinite loops e.g. from DST issues.
                    for (let i = 0; futureDates.length < MAX_FORECAST_DAYS && i < (MAX_FORECAST_DAYS + 5); i++) {
                        const year = currentDate.getFullYear();
                        const month = String(currentDate.getMonth() + 1).padStart(2, '0');
                        const day = String(currentDate.getDate()).padStart(2, '0');
                        const dateStr = `${year}-${month}-${day}`;

                        if (!futureDates.includes(dateStr)) {
                            futureDates.push(dateStr);
                        }

                        // Increment date by 24 hours for the next iteration
                        currentDate.setHours(currentDate.getHours() + 24);
                    }
                }
                setForecastDates(futureDates);
                setLastUpdated(latestApiTimestamp > 0 ? new Date(latestApiTimestamp) : new Date());
                let finalMessage;
                if (overallStatus === 'error') {
                    finalMessage = t('updateError', { errorCount: errorMessages.length, firstError: errorMessages[0] || '' });
                } else if (overallStatus === 'warning') {
                    finalMessage = t('updateWarning', { warningCount: warningMessages.length, firstWarning: warningMessages[0] || '' });
                } else {
                    finalMessage = t('dataUpdated', { successfulUpdates, apiGaugeCount });
                }
                setDataStatus({status: overallStatus, message: finalMessage});
            } catch (error) {
                console.error("Failed to load or process API data:", error);
                setDataStatus({status: 'error', message: t('loadError', { errorMessage: error.message })});
                setLastUpdated(new Date());
            } finally {
                if (refreshButtonRef.current) refreshButtonRef.current.disabled = false;
                if (autoRefresh) {
                    const nextTime = new Date(Date.now() + REFRESH_INTERVAL_MS);
                    setNextRefreshTime(nextTime);
                } else {
                    setNextRefreshTime(null);
                }
            }
        }, [allGaugeStaticData, autoRefresh, t, locale]);

        useEffect(() => {
            if (allGaugeStaticData.length > 0) loadGaugeApiData(false);
        }, [allGaugeStaticData, loadGaugeApiData]);

        useEffect(() => {
            if (!autoRefresh) {
                setNextRefreshTime(null);
                return () => {};
            }
            let timerId;
            const setTimer = () => {
                const nextTime = new Date(Date.now() + REFRESH_INTERVAL_MS);
                setNextRefreshTime(nextTime);
                timerId = setTimeout(() => {
                    if (refreshHandlerRef.current && !refreshButtonRef.current?.disabled) {
                        refreshHandlerRef.current?.(false);
                    } else {
                        setTimer();
                    }
                }, REFRESH_INTERVAL_MS);
            };
            setTimer();
            return () => clearTimeout(timerId);
        }, [autoRefresh]);

        useEffect(() => {
            if (activeTab === 'planner' || activeTab === 'cargo') {
                if (fixedHeaderContainerRef.current) fixedHeaderContainerRef.current.classList.remove('visible');
                if (originalTheadRef.current) originalTheadRef.current.classList.remove('hidden');
                isHeaderFixedRef.current = false;
                return () => {};
            }
            const sentinel = sentinelRef.current;
            const scrollWrapper = scrollWrapperRef.current;
            const originalTable = originalTableRef.current;
            const originalThead = originalTheadRef.current;
            const fixedHeaderContainer = fixedHeaderContainerRef.current;
            const fixedHeaderTable = fixedHeaderTableRef.current;
            if (!sentinel || !scrollWrapper || !originalTable || !originalThead || !fixedHeaderContainer || !fixedHeaderTable) {
                return;
            }
            let clonedThead = null;
            const cloneHeader = () => {
                while (fixedHeaderTable.firstChild) {
                    fixedHeaderTable.removeChild(fixedHeaderTable.firstChild);
                }
                if (originalThead) {
                    clonedThead = originalThead.cloneNode(true);
                    fixedHeaderTable.appendChild(clonedThead);
                    if (isHeaderFixedRef.current) {
                        syncHeaderGeometry();
                        syncHeaderScroll(scrollWrapper.scrollLeft);
                    }
                }
            };
            cloneHeader();
            const syncHeaderGeometry = () => {
                if (!isHeaderFixedRef.current || !scrollWrapper || !originalTable || !fixedHeaderContainer || !fixedHeaderTable) return;
                requestAnimationFrame(() => {
                    const scrollWrapperRect = scrollWrapper.getBoundingClientRect();
                    const originalTableWidth = Math.max(originalTable.offsetWidth, originalTable.scrollWidth);
                    fixedHeaderContainer.style.left = `${scrollWrapperRect.left}px`;
                    fixedHeaderContainer.style.width = `${scrollWrapper.clientWidth}px`;
                    fixedHeaderTable.style.width = `${originalTableWidth}px`;
                });
            };
            const syncHeaderScroll = (scrollLeft) => {
                if (!fixedHeaderContainer) return;
                requestAnimationFrame(() => {
                    fixedHeaderContainer.scrollLeft = scrollLeft;
                });
            };
            const observer = new IntersectionObserver(([entry]) => {
                const shouldBeFixed = !entry.isIntersecting && entry.boundingClientRect.top < 0;
                if (shouldBeFixed && !isHeaderFixedRef.current) {
                    isHeaderFixedRef.current = true;
                    originalThead?.classList.add('hidden');
                    syncHeaderGeometry();
                    syncHeaderScroll(scrollWrapper.scrollLeft);
                    fixedHeaderContainer?.classList.add('visible');
                } else if (!shouldBeFixed && isHeaderFixedRef.current) {
                    isHeaderFixedRef.current = false;
                    originalThead?.classList.remove('hidden');
                    fixedHeaderContainer?.classList.remove('visible');
                }
            }, {threshold: [0], rootMargin: "0px"});
            observer.observe(sentinel);
            const handleScroll = () => {
                if (isHeaderFixedRef.current) {
                    syncHeaderScroll(scrollWrapper.scrollLeft);
                }
            };
            const handleResize = () => {
                cloneHeader();
                if (isHeaderFixedRef.current) {
                    syncHeaderGeometry();
                    syncHeaderScroll(scrollWrapper.scrollLeft);
                }
            };
            scrollWrapper.addEventListener('scroll', handleScroll, {passive: true});
            window.addEventListener('resize', handleResize);
            window.addEventListener('scroll', handleResize, {passive: true});
            const initialCheckTimeout = setTimeout(() => {
                if (!sentinelRef.current || !scrollWrapperRef.current || !originalTheadRef.current) return;
                const sentinelRect = sentinelRef.current.getBoundingClientRect();
                const shouldBeFixedInitially = sentinelRect.top < 0;
                if (shouldBeFixedInitially && !isHeaderFixedRef.current) {
                    isHeaderFixedRef.current = true;
                    originalTheadRef.current?.classList.add('hidden');
                    syncHeaderGeometry();
                    syncHeaderScroll(scrollWrapperRef.current.scrollLeft);
                    fixedHeaderContainerRef.current?.classList.add('visible');
                } else if (!shouldBeFixedInitially && isHeaderFixedRef.current) {
                    isHeaderFixedRef.current = false;
                    originalTheadRef.current?.classList.remove('hidden');
                    fixedHeaderContainerRef.current?.classList.remove('visible');
                }
            }, 150);
            return () => {
                clearTimeout(initialCheckTimeout);
                observer.disconnect();
                const currentScrollWrapper = scrollWrapperRef.current;
                currentScrollWrapper?.removeEventListener('scroll', handleScroll);
                window.removeEventListener('resize', handleResize);
                window.removeEventListener('scroll', handleResize);
                if (fixedHeaderContainerRef.current) fixedHeaderContainerRef.current.classList.remove('visible');
                if (originalTheadRef.current) originalTheadRef.current.classList.remove('hidden');
                isHeaderFixedRef.current = false;
            };
        }, [activeTab, forecastDates.length, displayMode, tonnageReferenceShipId]); // Re-run when display mode changes to recl-one header

        useEffect(() => { setCookie('rhinePlannerSettings', plannerSettings); }, [plannerSettings]);
        useEffect(() => { setCookie('rhineShowUncertainty', showUncertainty); }, [showUncertainty]);
        useEffect(() => { setCookie('rhineDraftCorrections', customCorrections); }, [customCorrections]);
        useEffect(() => { setCookie('selectedRiverContext', selectedRiver); }, [selectedRiver]);
        useEffect(() => { setCookie('customShips', customShips); }, [customShips]);
        useEffect(() => { setCookie('rhineDisplayMode', displayMode); }, [displayMode]);
        useEffect(() => { setCookie('tonnageRefShip', tonnageReferenceShipId); }, [tonnageReferenceShipId]);
        useEffect(() => {
            const selectedShip = shipsForDropdown.find(s => s.id === tonnageReferenceShipId);
            if (selectedShip && !selectedShip.isAllowed) {
                // Find the first available ship of the same category, or the absolute first available one
                const firstAllowedOfCategory = shipsForDropdown.find(s => s.isAllowed && s.category === selectedShip.category);
                const firstAllowedOverall = shipsForDropdown.find(s => s.isAllowed);

                if (firstAllowedOfCategory) {
                    setTonnageReferenceShipId(firstAllowedOfCategory.id);
                } else if (firstAllowedOverall) {
                    setTonnageReferenceShipId(firstAllowedOverall.id);
                }
                // If no ship is allowed, it will just stay on the disabled one, which is acceptable.
            }
        }, [tonnageReferenceShipId, shipsForDropdown]);



        // --- Event Handlers ---
        const handleCorrectionChange = (direction, gaugeName, value) => {
            const parsedValue = parseInt(value, 10);
            const newValue = value === '' ? 0 : (isNaN(parsedValue) ? (customCorrections[direction][gaugeName] || 0) : parsedValue);
            setCustomCorrections({ ...customCorrections, [direction]: {...customCorrections[direction], [gaugeName]: newValue} });
        };

        const handleJourneyChange = (type, value) => {
            const newJourneyForRiver = { ...(journey[selectedRiver] || {}), [type]: value || null };
            const newJourneys = {...journey, [selectedRiver]: newJourneyForRiver};
            setJourney(newJourneys);
            setCookie('riverJourneys', newJourneys);
        };
        const handleRefresh = useCallback((force = true) => { loadGaugeApiData(force); }, [loadGaugeApiData]);
        const refreshHandlerRef = useRef();
        useEffect(() => { refreshHandlerRef.current = handleRefresh; }, [handleRefresh]);
        const handleTabChange = (tab) => { setActiveTab(tab); };
        const handleDisplayModeChange = (event) => { setDisplayMode(event.target.value); };
        const handleUncertaintyToggle = (event) => { setShowUncertainty(event.target.checked); };
        const handlePlannerSettingChange = (key, value) => { setPlannerSettings(prev => ({...prev, [key]: value})); };
        const handleExcludedDayChange = (dayIndex, isChecked) => {
            setPlannerSettings(prev => {
                const currentExcluded = prev.excludedDays || [];
                if (isChecked) { return {...prev, excludedDays: [...new Set([...currentExcluded, dayIndex])]}; }
                else { return {...prev, excludedDays: currentExcluded.filter(d => d !== dayIndex)}; }
            });
        };
        const handleOperationalModeChange = (e) => {
            const mode = e.target.value;
            let hours = plannerSettings.customOperationalHours;
            if (mode === 'A1') hours = 14; else if (mode === 'A2') hours = 18; else if (mode === 'B') hours = 24;
            setPlannerSettings(prev => ({ ...prev, operationalMode: mode, customOperationalHours: (mode !== 'Custom') ? hours : prev.customOperationalHours }));
        };
        const handleSetNow = () => {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            handlePlannerSettingChange('startDate', `${year}-${month}-${day}T${hours}:${minutes}`);
        };

        const handleAddCustomShip = (ship) => {
            setCustomShips(prev => [...prev, { ...ship, id: `custom_${Date.now()}` }]);
            setIsCustomShipModalOpen(false);
        };

        const handleDeleteCustomShip = (shipId, shipName) => {
            if (window.confirm(`Are you sure you want to delete ${shipName}?`)) {
                setCustomShips(prev => prev.filter(s => s.id !== shipId));
                 if (tonnageReferenceShipId === shipId) {
                    setTonnageReferenceShipId('elan'); // Reset to a default
                }
            }
        };


        useEffect(() => {
            const currentJourneySettings = journey[selectedRiver];
            if (!currentJourneySettings || !currentJourneySettings.start || !currentJourneySettings.end || allGaugeStaticData.length === 0) return;
            const startGauge = allGaugeStaticData.find(g => g.name === currentJourneySettings.start);
            const endGauge = allGaugeStaticData.find(g => g.name === currentJourneySettings.end);
            if (startGauge && endGauge && startGauge.river === endGauge.river) {
                 if (startGauge.river === 'Donau') { setTravelDirection(startGauge.km > endGauge.km ? 'downstream' : 'upstream'); }
                 else { setTravelDirection(startGauge.km < endGauge.km ? 'downstream' : 'upstream'); }
            } else { setTravelDirection('downstream'); }
        }, [journey, selectedRiver, allGaugeStaticData]);

        const journeyGaugeData = useMemo(() => {
            const routeWithApiData = gaugesOnRoute
                .map(routeGauge => {
                    const apiData = gaugeApiData[routeGauge.name];
                    if (apiData && (apiData.status === 'OK' || apiData.status?.startsWith('CACHED') || apiData.status === 'WARNING')) {
                        return { ...routeGauge, apiData: apiData };
                    }
                    return null;
                })
                .filter(Boolean);

            return routeWithApiData.map((gauge, index) => {
                let segmentDirection = travelDirection;
                const nextGauge = index < routeWithApiData.length - 1 ? routeWithApiData[index + 1] : null;
                const prevGauge = index > 0 ? routeWithApiData[index - 1] : null;

                if (nextGauge && nextGauge.river === gauge.river) {
                    if (gauge.river === 'Donau') {
                        segmentDirection = nextGauge.km < gauge.km ? 'downstream' : 'upstream';
                    } else {
                        segmentDirection = nextGauge.km > gauge.km ? 'downstream' : 'upstream';
                    }
                } else if (prevGauge && prevGauge.river === gauge.river) {
                     if (gauge.river === 'Donau') {
                        segmentDirection = gauge.km < prevGauge.km ? 'downstream' : 'upstream';
                    } else {
                        segmentDirection = gauge.km > prevGauge.km ? 'downstream' : 'upstream';
                    }
                }
                return { ...gauge, segmentDirection };
            });
        }, [gaugesOnRoute, gaugeApiData, travelDirection]);

        const displayedGaugeDataMaxDraft = useMemo(() => {
            if (activeTab === 'route') {
                return journeyGaugeData;
            }
            if (activeTab === 'all') {
                return allGaugeStaticData.filter(staticGauge => {
                    const apiData = gaugeApiData[staticGauge.name];
                    const hasApiData = !!apiData && (apiData.status === 'OK' || apiData.status?.startsWith('CACHED') || apiData.status === 'WARNING');
                    if (!hasApiData) return false;
                    if (selectedRiver === 'all') return true;
                    if (selectedRiver === 'Rijn/Waal') { return staticGauge.river === 'Rijn' || staticGauge.river === 'Waal' || staticGauge.name === 'Spijk - Woudrichem'; }
                    if (selectedRiver === 'IJssel') { return staticGauge.river === 'IJssel' || staticGauge.name === 'IJsselkop - Twenthekanaal' || staticGauge.name === 'Twenthekanaal - Zwolle-IJsselkanaal'; }
                    return staticGauge.river === selectedRiver;
                }).map(staticGauge => ({ ...staticGauge, apiData: gaugeApiData[staticGauge.name], segmentDirection: travelDirection }));
            }
            return [];
        }, [activeTab, journeyGaugeData, allGaugeStaticData, gaugeApiData, selectedRiver, travelDirection]);

        const displayedGaugeData = (activeTab === 'planner' || activeTab === 'cargo') ? [] : displayedGaugeDataMaxDraft;

        const calculateDraft = useCallback((gauge, waterLevel, direction) => {
            if (!gauge || waterLevel === null || waterLevel === undefined || isNaN(Number(waterLevel))) return null;
            if (gauge.name === "Konstanz") return null;
            let calculatedDraft = null;
            const numericLevel = Number(waterLevel);
            const effectiveDirection = direction || travelDirection;
            const correction = customCorrections[effectiveDirection]?.[gauge.name] || 0;
            if (gauge.river === 'MGD') {
                const safetyMargin = gauge.officialSafetyMargin !== 'N/A' ? Number(gauge.officialSafetyMargin) : DEFAULT_DEPTH_SAFETY_MARGIN;
                if (!isNaN(safetyMargin)) { calculatedDraft = (numericLevel - safetyMargin + correction); }
            } else if (gauge.customVuistregel !== undefined && gauge.customVuistregel !== null && !isNaN(Number(gauge.customVuistregel))) {
                calculatedDraft = (numericLevel + Number(gauge.customVuistregel) + correction);
            } else if (['Rijn', 'IJssel', 'Donau'].includes(gauge.river) && gauge.giw !== 'N/A' && gauge.depthAtGiw !== 'N/A' && gauge.officialSafetyMargin !== 'N/A') {
                const giw = Number(gauge.giw);
                const depth = Number(gauge.depthAtGiw);
                const safety = Number(gauge.officialSafetyMargin);
                if (!isNaN(giw) && !isNaN(depth) && !isNaN(safety)) { calculatedDraft = (numericLevel - giw + depth - safety + correction); }
            }
            if (calculatedDraft !== null) { if (gauge.river === 'Donau') { return Math.min(calculatedDraft, 270); } }
            return calculatedDraft;
        }, [customCorrections, travelDirection]);

        const calculateOfficialRuleOfThumb = useCallback((gauge) => {
            if (gauge.river === 'MGD' || gauge.giw === 'N/A' || gauge.depthAtGiw === 'N/A' || gauge.officialSafetyMargin === 'N/A') return "N/A";
            const giw = Number(gauge.giw);
            const depth = Number(gauge.depthAtGiw);
            const safety = Number(gauge.officialSafetyMargin);
            if (isNaN(giw) || isNaN(depth) || isNaN(safety)) return "N/A";
            if (["Nijmegen", "Tiel", "Bingen", "Iffezheim", "Konstanz", "Lobith", "Pannerdense kop", "IJsselkop", "Doesburg", "Deventer", "Katerveer"].includes(gauge.name)) return "N/A";
            return (depth - safety - giw).toFixed(0);
        }, []);

        const calculateCustomRuleOfThumbDisplay = useCallback((gauge, direction) => {
            if (!gauge || gauge.name === "Konstanz") return "N/A";
            const effectiveDirection = direction || travelDirection;
            const correction = customCorrections[effectiveDirection]?.[gauge.name] || 0;
            if (gauge.river === 'MGD') { return correction.toFixed(0); }
            let baseRule = null;
            if (gauge.customVuistregel !== undefined && gauge.customVuistregel !== null && !isNaN(Number(gauge.customVuistregel))) {
                baseRule = Number(gauge.customVuistregel);
            } else {
                const officialRule = calculateOfficialRuleOfThumb(gauge);
                if (officialRule !== "N/A") { baseRule = Number(officialRule); }
            }
            if (baseRule !== null) { return (baseRule + correction).toFixed(0); }
            return "N/A";
        }, [customCorrections, travelDirection, calculateOfficialRuleOfThumb]);

        const findCriticalGaugeMaxDraft = useCallback(() => {
            if (journeyGaugeData.length === 0) return { name: null, draft: null, apiData: null };
            let criticalGaugeName = null;
            let minDraft = Infinity;
            let criticalApiData = null;
            journeyGaugeData.forEach(gauge => {
                const apiData = gauge.apiData;
                if (apiData && apiData.currentLevel !== null) {
                    const draft = calculateDraft(gauge, apiData.currentLevel, gauge.segmentDirection);
                    if (draft !== null && !isNaN(Number(draft))) {
                        const numericDraft = Number(draft);
                        if (numericDraft < minDraft) {
                            minDraft = numericDraft;
                            criticalGaugeName = gauge.name;
                            criticalApiData = apiData;
                        }
                    }
                }
            });
            return {name: criticalGaugeName, draft: minDraft === Infinity ? null : minDraft, apiData: criticalApiData};
        }, [journeyGaugeData, calculateDraft]);

        const isMixedDirectionRoute = useMemo(() => {
            if (activeTab !== 'route' || gaugesOnRoute.length < 2) return false;
            const directions = new Set();
            for (let i = 0; i < gaugesOnRoute.length - 1; i++) {
                const currentGauge = gaugesOnRoute[i];
                const nextGauge = gaugesOnRoute[i + 1];
                if (currentGauge.river === nextGauge.river) {
                    let direction;
                    if (currentGauge.river === 'Donau') { direction = nextGauge.km < currentGauge.km ? 'downstream' : 'upstream'; }
                    else { direction = nextGauge.km > currentGauge.km ? 'downstream' : 'upstream'; }
                    directions.add(direction);
                }
            }
            return directions.size > 1;
        }, [activeTab, gaugesOnRoute]);

                const { name: criticalGaugeName, draft: criticalDraftValue, apiData: criticalApiDataForHighlight } = findCriticalGaugeMaxDraft();

        const shipsForDropdown = useMemo(() => {
            return processedShipData
                .filter(s => s.category !== 'component')
                .map(ship => {
                    const { allowed, warnings } = isShipAllowed(ship, gaugesOnRoute, travelDirection, gaugeApiData, t);
                    return { ...ship, isAllowed: allowed, constraintWarnings: warnings };
                })
                .sort((a, b) => a.name.localeCompare(b.name));
        }, [processedShipData, gaugesOnRoute, travelDirection, gaugeApiData, t]);

        const dryCargoShipsForDropdown = useMemo(() => shipsForDropdown.filter(s => s.category === 'dry_cargo'), [shipsForDropdown]);
        const tankerShipsForDropdown = useMemo(() => shipsForDropdown.filter(s => s.category === 'tanker'), [shipsForDropdown]);


        const todayStr = useMemo(() => {
            const todayDate = new Date();
            const nlYear = todayDate.toLocaleDateString('en-CA', {year: 'numeric', timeZone: 'Europe/Amsterdam'});
            const nlMonth = todayDate.toLocaleDateString('en-CA', {month: '2-digit', timeZone: 'Europe/Amsterdam'});
            const nlDay = todayDate.toLocaleDateString('en-CA', {day: '2-digit', timeZone: 'Europe/Amsterdam'});
            return `${nlYear}-${nlMonth}-${nlDay}`;
        }, []);

        function getBestForecastTime(forecastsForDate, currentTime) {
            if (!forecastsForDate || typeof forecastsForDate !== 'object') return null;
            const availableTimes = Object.keys(forecastsForDate).filter(t => t.match(/^\d{2}:\d{2}$/));
            if (availableTimes.length === 0) return null;
            if (availableTimes.length === 1) return availableTimes[0];
            availableTimes.sort();
            if (!currentTime) return availableTimes[availableTimes.length - 1];
            let currentMinutes = 0;
            try {
                const [hours, minutes] = currentTime.split(':').map(Number);
                currentMinutes = hours * 60 + minutes;
            } catch (e) { return availableTimes[availableTimes.length - 1]; }
            let bestTime = availableTimes[0];
            let minDiff = Infinity;
            for (const time of availableTimes) {
                const [hours, minutes] = time.split(':').map(Number);
                const timeMinutes = hours * 60 + minutes;
                const diff = Math.abs(timeMinutes - currentMinutes);
                if (diff < minDiff) { minDiff = diff; bestTime = time; }
            }
            return bestTime;
        }


const getGaugeBaseTime = (apiData) => {
    if (!apiData || !apiData.forecasts) return null;
    const sortedDates = Object.keys(apiData.forecasts).sort();
    if (sortedDates.length === 0) return null;
    // Find the first day that has valid time entries
    for (const dateStr of sortedDates) {
        const forecastsForDay = apiData.forecasts[dateStr];
        if (forecastsForDay) {
            const sortedTimes = Object.keys(forecastsForDay)
                .filter(t => t.match(/^\d{2}:\d{2}$/))
                .sort();
            if (sortedTimes.length > 0) {
                return sortedTimes[0]; // Return the earliest time of the earliest day
            }
        }
    }
    return null;
};

const forecastBottlenecks = useMemo(() => {

            if (activeTab !== 'route' || forecastDates.length === 0 || displayedGaugeDataMaxDraft.length === 0) return [];
            return forecastDates.map(dateStr => {
                let criticalGauge = null;
                let minDraft = Infinity;
                let forecastTime = null;
                let forecastLevelForCrit = null;
                let forecastSlotForCrit = null;
                let weeklyForecastSlotForCrit = null;
                let valueSource = null;
                let uncertaintyText = '';
                displayedGaugeDataMaxDraft.forEach(gauge => {
                    const apiData = gauge.apiData;
                    let potentialDraft = null;
                    let currentForecastLevel = null;
                    let currentForecastTime = null;
                    let currentForecastSlot = null;
                    let currentWeeklyForecastSlot = null;
                    let currentValueSource = null;
                    const forecastsForDate = apiData?.forecasts?.[dateStr];
                    if (forecastsForDate && Object.keys(forecastsForDate).length > 0) {
                        const gaugeBaseTime = getGaugeBaseTime(apiData);
const selectedTime = getBestForecastTime(forecastsForDate, gaugeBaseTime);
                        const dailySlot = selectedTime ? forecastsForDate[selectedTime] : null;
                        if (dailySlot && dailySlot.value !== undefined && dailySlot.value !== null) {
                            currentForecastLevel = dailySlot.value;
                            currentForecastTime = selectedTime;
                            currentForecastSlot = dailySlot;
                            currentValueSource = 'daily';
                            potentialDraft = calculateDraft(gauge, currentForecastLevel, gauge.segmentDirection);
                        }
                    }
                    if (potentialDraft === null && Array.isArray(apiData?.weeklyForecasts) && apiData.weeklyForecasts.length > 0) {
                        const targetDate = new Date(dateStr + 'T12:00:00Z');
                        for (const weeklyForecast of apiData.weeklyForecasts) {
                            if (weeklyForecast.weekRange && weeklyForecast.median !== null) {
                                try {
                                    const [startStr, endStr] = weeklyForecast.weekRange.split('-');
                                    const [startDay, startMonth, startYear] = startStr.split('.');
                                    const [endDay, endMonth, endYear] = endStr.split('.');
                                    const startDate = new Date(Date.UTC(startYear, startMonth - 1, startDay, 0, 0, 0));
                                    const endDate = new Date(Date.UTC(endYear, endMonth - 1, endDay, 23, 59, 59));
                                    if (!isNaN(startDate.getTime()) && !isNaN(endDate.getTime()) && targetDate >= startDate && targetDate <= endDate) {
                                        currentForecastLevel = weeklyForecast.median;
                                        currentForecastTime = "(BfG6W)";
                                        currentForecastSlot = null;
                                        currentWeeklyForecastSlot = weeklyForecast;
                                        currentValueSource = 'weekly';
                                        potentialDraft = calculateDraft(gauge, currentForecastLevel, gauge.segmentDirection);
                                        break;
                                    }
                                } catch (e) { }
                            }
                        }
                    }
                    if (potentialDraft !== null && !isNaN(Number(potentialDraft))) {
                        const numericDraft = Number(potentialDraft);
                        if (numericDraft < minDraft) {
                            minDraft = numericDraft;
                            criticalGauge = gauge;
                            forecastTime = currentForecastTime;
                            forecastLevelForCrit = currentForecastLevel;
                            forecastSlotForCrit = currentForecastSlot;
                            weeklyForecastSlotForCrit = currentWeeklyForecastSlot;
                            valueSource = currentValueSource;
                        }
                    }
                });
                if (criticalGauge && showUncertainty) {
                    if (valueSource === 'daily' && forecastSlotForCrit) {
                        if (forecastSlotForCrit.low_80 !== null && forecastSlotForCrit.high_80 !== null) {
                            const draftLow = calculateDraft(criticalGauge, forecastSlotForCrit.low_80, criticalGauge.segmentDirection);
                            const draftHigh = calculateDraft(criticalGauge, forecastSlotForCrit.high_80, criticalGauge.segmentDirection);
                            if (draftLow !== null && draftHigh !== null && !isNaN(draftLow) && !isNaN(draftHigh)) {
                                uncertaintyText = `(${Math.min(draftLow, draftHigh).toFixed(0)}–${Math.max(draftLow, draftHigh).toFixed(0)} cm)`;
                            } else {
                                uncertaintyText = '(Bereik N/A)';
                            }
                        } else if (forecastLevelForCrit !== null) {
                            const now = new Date();
                            const uncertaintyCm = calculateForecastUncertainty(criticalGauge, dateStr, now);
                            if (uncertaintyCm !== null) {
                                const draftLow = calculateDraft(criticalGauge, forecastLevelForCrit - uncertaintyCm, criticalGauge.segmentDirection);
                                const draftHigh = calculateDraft(criticalGauge, forecastLevelForCrit + uncertaintyCm, criticalGauge.segmentDirection);
                                if (draftLow !== null && draftHigh !== null && !isNaN(draftLow) && !isNaN(draftHigh)) {
                                    uncertaintyText = `(${Math.min(draftLow, draftHigh).toFixed(0)}–${Math.max(draftLow, draftHigh).toFixed(0)} cm*)`;
                                } else {
                                    uncertaintyText = `(±${uncertaintyCm} cm*)`;
                                }
                            }
                        }
                    } else if (valueSource === 'weekly' && weeklyForecastSlotForCrit) {
                        if (weeklyForecastSlotForCrit.low_90 !== null && weeklyForecastSlotForCrit.high_90 !== null) {
                            const draftLow = calculateDraft(criticalGauge, weeklyForecastSlotForCrit.low_90, criticalGauge.segmentDirection);
                            const draftHigh = calculateDraft(criticalGauge, weeklyForecastSlotForCrit.high_90, criticalGauge.segmentDirection);
                            if (draftLow !== null && draftHigh !== null && !isNaN(draftLow) && !isNaN(draftHigh)) {
                                uncertaintyText = `(${Math.min(draftLow, draftHigh).toFixed(0)}–${Math.max(draftLow, draftHigh).toFixed(0)} cm)`;
                            } else {
                                uncertaintyText = '(Bereik N/A)';
                            }
                        }
                    }
                }
                return {
                    date: dateStr,
                    gauge: criticalGauge?.name || null,
                    draft: criticalGauge && minDraft !== Infinity ? minDraft.toFixed(0) : 'N/A',
                    time: forecastTime,
                    uncertainty: uncertaintyText
                };
            });
        }, [activeTab, forecastDates, displayedGaugeDataMaxDraft, calculateDraft, showUncertainty, todayStr, getBestForecastTime, diffDays]);


        const calculateRoutePlan = useCallback(() => {
            setRoutePlanStatus('calculating');
            setRoutePlanResult(null);
            try {
                const startDateTime = new Date(plannerSettings.startDate);
                if (isNaN(startDateTime.getTime())) throw new Error(t('errorInvalidDate'));
                const startGaugeName = journey[selectedRiver]?.start;
                const endGaugeName = journey[selectedRiver]?.end;
                if (!startGaugeName || !endGaugeName) throw new Error(t('errorNoRoute'));
                if (!plannerSettings.speedDownstream || plannerSettings.speedDownstream <= 0 || !plannerSettings.speedUpstream || plannerSettings.speedUpstream <= 0) throw new Error(t('errorInvalidSpeed'));
                let operationalHours;
                switch (plannerSettings.operationalMode) {
                    case 'A1': operationalHours = 14; break;
                    case 'A2': operationalHours = 18; break;
                    case 'B': operationalHours = 24; break;
                    case 'Custom':
                        operationalHours = Number(plannerSettings.customOperationalHours);
                        if (!operationalHours || operationalHours <= 0 || operationalHours > 24) throw new Error(t('errorInvalidHours'));
                        break;
                    default: throw new Error(t('system'));
                }
                if (plannerSettings.customSegmentKm > 0 && (!plannerSettings.customSegmentSpeed || plannerSettings.customSegmentSpeed <= 0)) {
                    throw new Error(t('errorCustomSegmentSpeed'));
                }
                const routeGauges = findRoutePath(startGaugeName, endGaugeName, allGaugeStaticData, {
                    downstream: plannerSettings.speedDownstream,
                    upstream: plannerSettings.speedUpstream,
                });
                if (!routeGauges || routeGauges.length === 0) {
                     throw new Error(t('errorNoPath', { start: startGaugeName, end: endGaugeName }));
                }
                const intermediatePoints = [];
                let currentTime = new Date(startDateTime.getTime());
                let overallMinDraft = Infinity;
                let criticalPointInfo = null;
                const now = new Date();
                if (plannerSettings.customSegmentPosition === 'start' && plannerSettings.customSegmentKm > 0 && plannerSettings.customSegmentSpeed > 0) {
                    const segmentHours = plannerSettings.customSegmentKm / plannerSettings.customSegmentSpeed;
                    currentTime = addOperationalTime(currentTime, segmentHours, operationalHours, plannerSettings.excludedDays);
                }
                for (let i = 0; i < routeGauges.length; i++) {
                    const currentGauge = routeGauges[i];
                    const currentApiData = gaugeApiData[currentGauge.name];
                    let eta = new Date(currentTime.getTime());
                    let planDirection = 'downstream';
                    if (i > 0) {
                        const prevGauge = routeGauges[i - 1];
                        const specialConnection = (prevGauge.connections || []).find(c => c.targetGaugeName === currentGauge.name && c.isCanal);
                        let travelHours = 0;
                        if (specialConnection) {
                             if (plannerSettings.speedCanal > 0) { travelHours = specialConnection.distance / plannerSettings.speedCanal; }
                        } else {
                            const distance = Math.abs(currentGauge.km - prevGauge.km);
                            if (currentGauge.river === 'Donau') { planDirection = currentGauge.km < prevGauge.km ? 'downstream' : 'upstream'; }
                            else { planDirection = currentGauge.km > prevGauge.km ? 'downstream' : 'upstream'; }
                            const speed = planDirection === 'downstream' ? plannerSettings.speedDownstream : plannerSettings.speedUpstream;
                            if (speed > 0) travelHours = distance / speed;
                        }
                        eta = addOperationalTime(currentTime, travelHours, operationalHours, plannerSettings.excludedDays);
                    } else {
                         eta = addOperationalTime(currentTime, 0, operationalHours, plannerSettings.excludedDays);
                    }
                    currentTime = new Date(eta.getTime());
                    let forecastLevel = null, forecastTimeStr = 'N/A', forecastUncertainty = null, forecastSource = '', isCurrentLevelUsed = false;
                    if (i === 0 && startDateTime <= now && currentApiData?.currentLevel !== null) {
                        forecastLevel = currentApiData.currentLevel;
                        forecastTimeStr = currentApiData.currentTime || t('now');
                        forecastSource = 'current';
                        isCurrentLevelUsed = true;
                    } else {
                        const forecast = getForecastForDateTime(currentApiData, eta);
                        if (forecast) {
                            forecastLevel = forecast.value;
                            forecastTimeStr = forecast.time;
                            forecastSource = forecast.source;
                            forecastUncertainty = forecast.uncertainty;
                        }
                    }
                    const draftAtEta = calculateDraft(currentGauge, forecastLevel, planDirection);
                    const correctedRule = calculateCustomRuleOfThumbDisplay(currentGauge, planDirection);
                    if (draftAtEta !== null && draftAtEta < overallMinDraft) {
                        overallMinDraft = draftAtEta;
                        criticalPointInfo = { name: currentGauge.name, km: currentGauge.km, draft: draftAtEta, eta: eta };
                    }
                    let draftUncertaintyText = '';
                     if (showUncertainty && draftAtEta !== null && !isCurrentLevelUsed) {
                        if (forecastUncertainty) {
                            const draftLow = calculateDraft(currentGauge, forecastUncertainty.low, planDirection);
                            const draftHigh = calculateDraft(currentGauge, forecastUncertainty.high, planDirection);
                            if (draftLow !== null && draftHigh !== null && !isNaN(draftLow) && !isNaN(draftHigh)) {
                                draftUncertaintyText = `(${Math.min(draftLow, draftHigh).toFixed(0)}–${Math.max(draftLow, draftHigh).toFixed(0)} cm)`;
                            }
                        } else if (forecastSource === 'daily' && forecastLevel !== null) {
                            const etaDateStr = eta.toISOString().split('T')[0];
                            const uncertaintyCm = calculateForecastUncertainty(currentGauge, etaDateStr, now);
                            if (uncertaintyCm !== null) {
                                const draftLow = calculateDraft(currentGauge, forecastLevel - uncertaintyCm, planDirection);
                                const draftHigh = calculateDraft(currentGauge, forecastLevel + uncertaintyCm, planDirection);
                                if (draftLow !== null && draftHigh !== null && !isNaN(draftLow) && !isNaN(draftHigh)) {
                                    draftUncertaintyText = `(${Math.min(draftLow, draftHigh).toFixed(0)}–${Math.max(draftLow, draftHigh).toFixed(0)} cm*)`;
                                }
                            }
                        }
                    }
                    intermediatePoints.push({
                        name: currentGauge.name, km: currentGauge.km, eta: eta, forecastLevel: forecastLevel,
                        forecastTime: forecastTimeStr, forecastSource: forecastSource, draftAtEta: draftAtEta,
                        correctedRule: correctedRule, offset: '-', draftUncertaintyText: draftUncertaintyText,
                        notes: forecastLevel === null ? t('notesNoDataForEta') : (forecastSource === 'weekly' ? t('notesWeeklyForecast') : (forecastSource === 'current' ? t('notesCurrentLevel') : '')),
                        isCritical: false, gaugeRef: currentGauge
                    });
                }
                if (plannerSettings.customSegmentPosition === 'end' && plannerSettings.customSegmentKm > 0 && plannerSettings.customSegmentSpeed > 0 && intermediatePoints.length > 0) {
                    const segmentHours = plannerSettings.customSegmentKm / plannerSettings.customSegmentSpeed;
                    const lastPoint = intermediatePoints[intermediatePoints.length - 1];
                    const finalEtaWithSegment = addOperationalTime(lastPoint.eta, segmentHours, operationalHours, plannerSettings.excludedDays);
                    lastPoint.eta = finalEtaWithSegment;
                    lastPoint.notes = (lastPoint.notes ? lastPoint.notes + '; ' : '') + `+${plannerSettings.customSegmentKm}km`;
                    if (criticalPointInfo && criticalPointInfo.name === lastPoint.name && criticalPointInfo.km === lastPoint.km) {
                        criticalPointInfo.eta = finalEtaWithSegment;
                    }
                }
                let finalOverallMinDraft = overallMinDraft;
                let limitReason = null;
                const routeContainsCanal = routeGauges.some((gauge, index) => {
                    if (index > 0) {
                        const prevGauge = routeGauges[index - 1];
                        return (prevGauge.name === 'Mainz' && gauge.name === 'Kelheim') || (prevGauge.name === 'Kelheim' && gauge.name === 'Mainz');
                    } return false;
                });
                if (routeContainsCanal && finalOverallMinDraft > 250) {
                    finalOverallMinDraft = 250;
                    limitReason = { message: t('canalLimitReason') };
                }
                const finalRoutePoints = intermediatePoints.map(point => {
                    let finalOffset = '-';
                    if (point.forecastLevel !== null && !isNaN(Number(point.forecastLevel)) && finalOverallMinDraft !== Infinity) {
                        const offsetCalc = -point.forecastLevel + finalOverallMinDraft;
                        if (!isNaN(offsetCalc)) { finalOffset = (offsetCalc >= 0 ? '+' : '') + offsetCalc.toFixed(0); }
                    }
                    const isThisCritical = criticalPointInfo && point.name === criticalPointInfo.name && point.km === criticalPointInfo.km;
                     if (isThisCritical && criticalPointInfo) {
                        criticalPointInfo.uncertaintyText = point.draftUncertaintyText;
                        criticalPointInfo.draft = finalOverallMinDraft;
                    }
                    return { ...point, offset: finalOffset, isCritical: isThisCritical };
                });
                let mgdWarning = null;
                const warnings = [];
                const routeContainsRiver = (riverName) => routeGauges.some(g => g.river === riverName);
                if (routeContainsRiver('Waal') && finalOverallMinDraft !== Infinity) {
                    const mgdStaticGauge = allGaugeStaticData.find(g => g.name === 'Spijk - Woudrichem');
                    const mgdApiData = gaugeApiData['Spijk - Woudrichem'];
                    if (mgdStaticGauge && mgdApiData && mgdApiData.currentLevel !== null) {
                        const allowableMgdDraft = calculateDraft(mgdStaticGauge, mgdApiData.currentLevel, 'downstream');
                        if (allowableMgdDraft !== null && finalOverallMinDraft > allowableMgdDraft) {
                            warnings.push(t('mgdWarningText', { calculatedDraft: finalOverallMinDraft.toFixed(0), mgdName: 'Spijk-Woudrichem', mgdDraft: allowableMgdDraft.toFixed(0) }));
                        }
                    }
                }
                 if (routeContainsRiver('IJssel') && finalOverallMinDraft !== Infinity) {
                     const relevantIJsselMgdNames = ['IJsselkop - Twenthekanaal', 'Twenthekanaal - Zwolle-IJsselkanaal'];
                     relevantIJsselMgdNames.forEach(mgdName => {
                         const mgdApiData = gaugeApiData[mgdName];
                         const mgdStaticGauge = allGaugeStaticData.find(g => g.name === mgdName);
                         if (mgdApiData && mgdApiData.currentLevel !== null && mgdStaticGauge) {
                             const allowableMgdDraft = calculateDraft(mgdStaticGauge, mgdApiData.currentLevel, 'downstream');
                             if (allowableMgdDraft !== null && finalOverallMinDraft > allowableMgdDraft) {
                                 warnings.push(t('mgdWarningText', { calculatedDraft: finalOverallMinDraft.toFixed(0), mgdName: mgdName, mgdDraft: allowableMgdDraft.toFixed(0) }));
                             }
                         }
                     });
                 }
                if (warnings.length > 0) { mgdWarning = warnings.join(' '); }
                setRoutePlanResult({ points: finalRoutePoints, overallMaxDraft: finalOverallMinDraft === Infinity ? null : finalOverallMinDraft, criticalPoint: criticalPointInfo, mgdWarning: mgdWarning, limitReason: limitReason });
                setRoutePlanStatus('calculated');
            } catch (error) {
                console.error("Error calculating route plan:", error);
                setRoutePlanResult({ points: [], overallMaxDraft: null, criticalPoint: null, mgdWarning: null, error: error.message });
                setRoutePlanStatus('error');
            }
                }, [plannerSettings, journey, selectedRiver, allGaugeStaticData, gaugeApiData, calculateDraft, showUncertainty, customCorrections, calculateCustomRuleOfThumbDisplay, t]);

        useEffect(() => {
            // Automatically calculate the route plan when the tab is active or dependencies change.
            if (activeTab === 'planner' && journey[selectedRiver]?.start && journey[selectedRiver]?.end) {
                calculateRoutePlan();
            }
        }, [calculateRoutePlan, activeTab]);




        const shipsForCargoTab = useMemo(() => {
            if (activeTab !== 'cargo') return [];

            const effectiveDraft = isOnMDK ? Math.min(cargoDraft, 2.50) : cargoDraft;

            return processedShipData
                .map(ship => {
                    const { allowed, warnings } = isShipAllowed(ship, gaugesOnRoute, travelDirection, gaugeApiData, t);
                    const calculatedTonnage = ship.fitFunc ? ship.fitFunc(effectiveDraft) : 0;

                    // The value for display remains uncapped (but positive and respects 'allowed' status)
                    const displayTonnage = allowed ? Math.max(0, calculatedTonnage) : 0;

                    // The value for sorting is capped at the ship's maximum tonnage
                    const sortingTonnage = ship.max_tonnage ? Math.min(displayTonnage, ship.max_tonnage) : displayTonnage;

                    return {
                        ...ship,
                        isAllowed: allowed,
                        constraintWarnings: warnings,
                        currentTonnage: displayTonnage, // for display in the card
                        sortingTonnage: sortingTonnage  // for sorting the list
                    };
                })
                .sort((a, b) => {
                    // Group by allowed status (suitable ships first)
                    if (a.isAllowed !== b.isAllowed) {
                        return a.isAllowed ? -1 : 1;
                    }

                    // Within each group, sort by the capped sorting tonnage, ascending.
                    const tonnageA = a.sortingTonnage || 0;
                    const tonnageB = b.sortingTonnage || 0;
                    if (Math.abs(tonnageA - tonnageB) > 1e-6) {
                        return tonnageA - tonnageB;
                    }

                    // Fallback for identical sorting tonnage: sort by max tonnage
                    const maxTonnageA = a.max_tonnage || 0;
                    const maxTonnageB = b.max_tonnage || 0;
                    if (maxTonnageA !== maxTonnageB) {
                        return maxTonnageA - maxTonnageB;
                    }

                    // Final fallback on name
                    return a.name.localeCompare(b.name);
                });
        }, [activeTab, processedShipData, gaugesOnRoute, travelDirection, gaugeApiData, t, cargoDraft, isOnMDK]);

        const filteredShipsForCargoTab = useMemo(() => {
            return shipsForCargoTab.filter(ship => shipFilter === 'all' || ship.category === shipFilter);
        }, [shipsForCargoTab, shipFilter]);

        const isOnMDK = useMemo(() => {
            if(!gaugesOnRoute || gaugesOnRoute.length < 2) return false;
            const gaugeNames = gaugesOnRoute.map(g => g.name);
            const rivers = [...new Set(gaugesOnRoute.map(g => g.river))];
            return gaugeNames.includes('Kelheim') && (gaugeNames.includes('Mainz') || rivers.includes('Rijn'));
        }, [gaugesOnRoute]);

        // --- Render ---
        const giwLabel = selectedRiver === 'Donau' ? 'RNW' : 'GIW';
        const tuGiwLabel = selectedRiver === 'Donau' ? 'TuRNW' : 'TuGIW';


        const handleSetCargoDraftFromCritical = () => {
             if (criticalDraftValue !== null && criticalDraftValue !== Infinity) {
                setCargoDraft(criticalDraftValue / 100);
             }
        };

        const handleSetCargoDraftFromPlanner = () => {
             if (routePlanResult?.overallMaxDraft !== null && routePlanResult.overallMaxDraft !== Infinity) {
                setCargoDraft(routePlanResult.overallMaxDraft / 100);
             }
        };

        const tonnageRefShip = useMemo(() => {
            return processedShipData.find(s => s.id === tonnageReferenceShipId) || processedShipData[0];
        }, [processedShipData, tonnageReferenceShipId]);

        return (
            <div className="container">
                {isCustomShipModalOpen && (
                    <CustomShipModal
                        onClose={() => setIsCustomShipModalOpen(false)}
                        onSave={handleAddCustomShip}
                        baseShips={processedShipData.filter(s => s.category !== 'component' && !s.is_combo)}
                    />
                )}

                {(activeTab !== 'planner' && activeTab !== 'cargo') && (
                    <div className="fixed-header-container" ref={fixedHeaderContainerRef}>
                        <table ref={fixedHeaderTableRef}></table>
                    </div>
                )}

                <header className="controls-area">
                    <div className="controls-left">
                        <h1 style={{margin: '0 0 0.5rem 0', fontSize: '1.5rem'}}>{t('appTitle')}</h1>

                        <div className="control-group">
                            <label>{t('language_multilingual')}:</label>
                            <select value={language} onChange={(e) => setLanguage(e.target.value)}>
                                <option value="nl">🇳🇱 Nederlands</option>
                                <option value="en">🇬🇧 English</option>
                                <option value="de">🇩🇪 Deutsch</option>
                                <option value="fr">🇫🇷 Français</option>
                                <option value="ru">🇷🇺 Русский</option>
                            </select>
                        </div>
                        <div className="control-group"><label><input type="checkbox" checked={autoRefresh} onChange={(e) => setAutoRefresh(e.target.checked)}/>{t('autoRefresh')}</label> {autoRefresh && nextRefreshTime && <span style={{ marginLeft: '8px', fontSize: '0.8em', color: '#aaa' }}>{t('nextRefresh')}: {nextRefreshTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>} </div>
                        <div className="control-group">
                            <label>{t('contextRiver')}:</label>
                            <select value={selectedRiver} onChange={(e) => setSelectedRiver(e.target.value)}>
                                <option value="all">{t('allRivers')}</option>
                                <option value="Rijn/Waal">Rijn/Waal</option>
                                <option value="Donau">Donau</option>
                                <option value="IJssel">IJssel</option>
                            </select>
                        </div>
                        <div className="control-group">
                            <label>{t('journey')}:</label>
                            <select value={journey[selectedRiver]?.start ?? ''} onChange={(e) => handleJourneyChange('start', e.target.value)}>
                                <option value="">{t('selectStart')}</option>
                                {allGaugeStaticData
                                    .filter(g => g.river !== 'MGD' && g.name !== 'Konstanz' && g.name !== 'Ingolstadt')
                                    .filter(g => { if (selectedRiver === 'Rijn/Waal') return g.isMainRoute; if (selectedRiver === 'all') return true; return g.river === selectedRiver; })
                                    .sort((a, b) => { if (selectedRiver === 'all') { const riverOrder = { 'Rijn': 1, 'Pannerdens Kanaal': 2, 'Waal': 3, 'IJssel': 4, 'Donau': 5, 'Nederrijn': 6, 'Lek': 7, 'Unknown': 99 }; const orderA = riverOrder[a.river || 'Unknown'] || 99; const orderB = riverOrder[b.river || 'Unknown'] || 99; if (orderA !== orderB) return orderA - orderB; if (a.river === 'Donau') return b.km - a.km; return a.km - b.km; } if (selectedRiver === 'Donau') return b.km - a.km; return a.km - b.km; })
                                    .map(gauge => <option key={`start-${gauge.name}`} value={gauge.name}>{`${selectedRiver === 'all' ? gauge.river + ': ' : ''}${gauge.name} (${gauge.km})`}</option>)}
                            </select>
                            <span>{t('to')}</span>
                            <select value={journey[selectedRiver]?.end ?? ''} onChange={(e) => handleJourneyChange('end', e.target.value)}>
                                <option value="">{t('selectEnd')}</option>
                                {allGaugeStaticData
                                     .filter(g => g.river !== 'MGD' && g.name !== 'Konstanz' && g.name !== 'Ingolstadt')
                                     .filter(g => { if (selectedRiver === 'Rijn/Waal') return g.isMainRoute; if (selectedRiver === 'all') return true; return g.river === selectedRiver; })
                                     .sort((a, b) => { if (selectedRiver === 'all') { const riverOrder = { 'Rijn': 1, 'Pannerdens Kanaal': 2, 'Waal': 3, 'IJssel': 4, 'Donau': 5, 'Nederrijn': 6, 'Lek': 7, 'Unknown': 99 }; const orderA = riverOrder[a.river || 'Unknown'] || 99; const orderB = riverOrder[b.river || 'Unknown'] || 99; if (orderA !== orderB) return orderA - orderB; if (a.river === 'Donau') return b.km - a.km; return a.km - b.km; } if (selectedRiver === 'Donau') return b.km - a.km; return a.km - b.km; })
                                    .map(gauge => <option key={`end-${gauge.name}`} value={gauge.name}>{`${selectedRiver === 'all' ? gauge.river + ': ' : ''}${gauge.name} (${gauge.km})`}</option>)}
                            </select>
                        </div>
                        {(activeTab === 'route' || activeTab === 'all') && (
                            <>
                                <div className="control-group">
                                    <label>{t('displayMode')}:</label>
                                    <div className="view-toggle-group">
                                        <label className="toggle-label"><input type="radio" value="draft" checked={displayMode === 'draft'} onChange={handleDisplayModeChange}/> {t('displayModeDraft')}</label>
                                        <label className="toggle-label"><input type="radio" value="level" checked={displayMode === 'level'} onChange={handleDisplayModeChange}/> {t('displayModeLevel')}</label>
                                        <label className="toggle-label"><input type="radio" value="tonnage" checked={displayMode === 'tonnage'} onChange={handleDisplayModeChange}/> {t('displayModeTonnage')}</label>
                                    </div>
                                </div>
                                {displayMode === 'tonnage' && (
                                    <div className="control-group">
                                        <label>{t('selectRefShip')}:</label>
                                        <select value={tonnageReferenceShipId} onChange={(e) => setTonnageReferenceShipId(e.target.value)}>
                                            <optgroup label={`--- ${t('categoryDryCargo')} ---`}>
                                                {dryCargoShipsForDropdown.map(ship => (
                                                    <option
                                                        key={ship.id}
                                                        value={ship.id}
                                                        disabled={!ship.isAllowed}
                                                        title={!ship.isAllowed ? ship.constraintWarnings.join('\n') : ''}
                                                        style={!ship.isAllowed ? { color: '#999' } : {}}
                                                    >
                                                        {ship.name}
                                                    </option>
                                                ))}
                                            </optgroup>
                                            <optgroup label={`--- ${t('categoryTanker')} ---`}>
                                                {tankerShipsForDropdown.map(ship => (
                                                    <option
                                                        key={ship.id}
                                                        value={ship.id}
                                                        disabled={!ship.isAllowed}
                                                        title={!ship.isAllowed ? ship.constraintWarnings.join('\n') : ''}
                                                        style={!ship.isAllowed ? { color: '#999' } : {}}
                                                    >
                                                        {ship.name}
                                                    </option>
                                                ))}
                                            </optgroup>
                                        </select>
                                    </div>
                                )}
                                <div className="control-group"><label className="toggle-label"> <input type="checkbox" checked={showUncertainty} onChange={handleUncertaintyToggle}/> {t('showUncertainty')} </label></div>
                            </>
                        )}
                        <div className="control-group">
                            <button className="refresh-btn" onClick={() => handleRefresh(true)} ref={refreshButtonRef} disabled={dataStatus.status === 'pending'}> {dataStatus.status === 'pending' ? t('loading') : t('reloadData')} </button>
                            <div className={`data-status ${dataStatus.status}`}> {dataStatus.message} {dataStatus.status !== 'pending' && lastUpdated ? `(${t('apiTime')}: ${lastUpdated.toLocaleTimeString(locale, { hour: '2-digit', minute: '2-digit' })})` : ''} </div>
                        </div>
                    </div>

                    {activeTab === 'route' && (<div className="controls-right highlight-box">
                        <div style={{marginBottom: '6px', fontWeight: 'bold'}}>{t('criticalDraftTitle', { direction: isMixedDirectionRoute ? t('directionMixed') : (travelDirection === 'downstream' ? t('directionDown') : t('directionUp')) })}:</div>
                        <div><span className="label">{t('now')}:</span> <span className="value">{criticalDraftValue !== null ? `${criticalDraftValue.toFixed(0)} cm` : 'N/A'}</span><span className="gauge">({criticalGaugeName || 'N/A'})</span> <span className="time">({criticalApiDataForHighlight?.currentTime || 'N/A'})</span></div>
                        {forecastBottlenecks.slice(1).map((forecast) => (
                            <div key={`forecast-bottleneck-${forecast.date}`}>
                                <span className="label">{new Date(forecast.date + 'T12:00:00Z').toLocaleDateString(locale, { weekday: 'short', day: 'numeric' })}:</span>
                                <span className="value">{forecast.draft !== 'N/A' ? `${forecast.draft} cm` : 'N/A'}</span>
                                {showUncertainty && forecast.uncertainty && (<span className="forecast-uncertainty">{forecast.uncertainty}</span>)}
                                <span className="gauge">({forecast.gauge || 'N/A'})</span>
                                <span className="time">({forecast.time || 'N/A'})</span>
                            </div>
                        ))}
                        {forecastDates.length > 0 && forecastBottlenecks.every(f => f.gauge === null) && dataStatus.status !== 'pending' && <div style={{fontSize: '0.85em', color: '#333', marginTop: '4px'}}>{t('noCriticalForecast')}</div>}
                        {forecastDates.length === 0 && dataStatus.status !== 'pending' && <div style={{fontSize: '0.85em', color: '#333', marginTop: '4px'}}>{t('noForecastsAvailable')}</div>}
                        {dataStatus.status === 'pending' && <div style={{fontSize: '0.85em', color: '#333', marginTop: '4px'}}>{t('loadingForecasts')}</div>}
                    </div>)}
                    {activeTab === 'all' && ( <div className="controls-right"><p style={{fontSize: '0.9em', color: '#aaa'}}>Alle beschikbare peilingen en dieptes.</p></div> )}
                    {activeTab === 'planner' && ( <div className="controls-right"><p style={{fontSize: '0.9em', color: '#aaa'}}>Stel de routeplanner in en bereken de maximaal mogelijke diepgang voor de reis.</p></div> )}
                    {activeTab === 'cargo' && ( <div className="controls-right"><p style={{fontSize: '0.9em', color: '#aaa'}}>Bereken het laadvermogen voor verschillende scheepstypes op basis van de beschikbare diepgang.</p></div> )}
                </header>

                <div className="main-content">
                    <div className="tab-controls">
                        <button className={`tab-button ${activeTab === 'route' ? 'active' : ''}`} onClick={() => handleTabChange('route')}>{t('tabMaxDraft')}</button>
                        <button className={`tab-button ${activeTab === 'planner' ? 'active' : ''}`} onClick={() => handleTabChange('planner')}>{t('tabPlanner')}</button>
                        <button className={`tab-button ${activeTab === 'cargo' ? 'active' : ''}`} onClick={() => handleTabChange('cargo')}>{t('tabCargo')}</button>
                        <button className={`tab-button ${activeTab === 'all' ? 'active' : ''}`} onClick={() => handleTabChange('all')}>{t('tabAllData')}</button>
                    </div>

                    {(activeTab === 'route' || activeTab === 'all') && (
                        <div className="table-area-padding">
                            <div className="header-sentinel" ref={sentinelRef}></div>
                            <div className="table-scroll-wrapper" ref={scrollWrapperRef}>
                                <table className="original-table" ref={originalTableRef}>
                                    <thead ref={originalTheadRef}>
                                    <tr>
                                        <th rowSpan="2">{t('headerRiver')}</th>
                                        <th rowSpan="2">{t('headerSection')}</th>
                                        <th rowSpan="2">{t('headerName')}</th>
                                        <th rowSpan="2" className="numeric">{giwLabel}<br/><span style={{fontSize: '0.85em', fontWeight: 'normal'}}>{t('headerUnitCm')}</span></th>
                                        <th rowSpan="2" className="numeric">{tuGiwLabel}<br/><span style={{fontSize: '0.85em', fontWeight: 'normal'}}>{t('headerUnitCm')}</span></th>
                                        <th rowSpan="2" className="numeric"> {t('headerValue')} <br/> <span style={{fontSize: '0.85em', fontWeight: 'normal'}}>{t('headerUnitActual')}</span></th>
                                        <th rowSpan="2" className="numeric">{t('headerTrend')}<br/> <span style={{fontSize: '0.85em', fontWeight: 'normal'}}>(24h)</span></th>
                                        <th rowSpan="2" className="numeric">{t('headerOfficialRule')}<br/><span style={{fontSize: '0.85em', fontWeight: 'normal'}}>{t('headerUnitCm')}</span></th>
                                        <th colSpan="2" className="center">{t('headerCorrection')}</th>
                                        <th colSpan="2" className="center">{t('headerAdjRule')} <br/> {t('headerUnitCm')}</th>
                                        <th rowSpan="2" className="numeric">
                                            {displayMode === 'draft' ? t('headerActualDraft') : (displayMode === 'tonnage' ? t('headerActualTonnage') : t('headerActualLevel'))} <br/>
                                            <span style={{fontSize: '0.85em', fontWeight: 'normal'}}>{displayMode === 'draft' ? t('headerUnitCm') : (displayMode === 'tonnage' ? t('headerUnitTons') : t('headerUnitActual'))}</span>
                                        </th>
                                        {forecastDates.slice(1).map(dateStr => (
                                            <th key={`forecast-hdr-${dateStr}`} rowSpan="2" className="numeric forecast-header">
                                                {new Date(dateStr + 'T12:00:00Z').toLocaleDateString(locale, { weekday: 'short', day: 'numeric' })} <br/>
                                                <span style={{ fontSize: '0.85em', fontWeight: 'normal' }}>
                                                  {displayMode === 'tonnage' ? t('headerForecastValueTons', { mode: 'T' }) : t('headerForecastValue', { mode: displayMode === 'draft' ? 'D' : 'S' })}
                                                </span>
                                            </th>
                                        ))}
                                        {forecastDates.length === 0 && dataStatus.status !== 'pending' && <th rowSpan="2" className="forecast-header">{t('noForecasts')}</th>}
                                    </tr>
                                    <tr>
                                        <th className="numeric">{t('headerUp')}</th>
                                        <th className="numeric">{t('headerDown')}</th>
                                        <th className="numeric">{t('headerUp')}</th>
                                        <th className="numeric">{t('headerDown')}</th>
                                    </tr>
                                    </thead>
                                    <tbody>
                                    {dataStatus.status === 'pending' && (<tr><td colSpan={13 + Math.max(1, forecastDates.length)} style={{textAlign: 'center', fontStyle: 'italic', padding: '1rem'}}>{t('loading')}</td></tr>)}
                                    {dataStatus.status !== 'pending' && displayedGaugeData.length === 0 && (<tr><td colSpan={13 + Math.max(1, forecastDates.length)} style={{ textAlign: 'center', fontStyle: 'italic', padding: '1rem' }}> {activeTab === 'route' ? t('noDataForSelection') : (Object.keys(gaugeApiData).length === 0 ? t('noApiData') : t('noDataForFilter'))} </td></tr>)}
                                    {displayedGaugeData.map(gauge => {
                                        const apiData = gauge.apiData;
                                        const isCritical = activeTab === 'route' && gauge.name === criticalGaugeName;
                                        const currentLevel = apiData?.currentLevel;
                                        const currentTime = apiData?.currentTime || 'N/A';
                                        const currentTrend = apiData?.currentTrend ?? '-';
                                        const officialRuleDisplay = calculateOfficialRuleOfThumb(gauge);
                                        const customRuleDisplayUp = calculateCustomRuleOfThumbDisplay(gauge, 'upstream');
                                        const customRuleDisplayDown = calculateCustomRuleOfThumbDisplay(gauge, 'downstream');

                                        // Calculate base values
                                        const currentActualDraft = currentLevel !== null ? calculateDraft(gauge, currentLevel, gauge.segmentDirection) : null;
                                        const currentLevelDisplay = currentLevel;
                                        let currentTonnage = (displayMode === 'tonnage' && tonnageRefShip && currentActualDraft !== null) ? tonnageRefShip.fitFunc(currentActualDraft / 100) : null;

                                        if (currentTonnage !== null && tonnageRefShip.max_tonnage) {
                                            currentTonnage = Math.min(currentTonnage, tonnageRefShip.max_tonnage);
                                        }

                                        let lastColumnClass = "numeric ";
                                        let lastColumnValue = '-';

                                        if (displayMode === 'draft') {
                                            lastColumnClass += 'actual-draft-column';
                                            if (currentActualDraft !== null) {
                                                lastColumnValue = currentActualDraft.toFixed(0);
                                                if (isCritical) lastColumnClass += ' critical-actual-draft';
                                            }
                                        } else if (displayMode === 'tonnage') {
                                            lastColumnClass += 'actual-tonnage-column';
                                            if (currentTonnage !== null && currentTonnage > 0) {
                                                lastColumnValue = currentTonnage.toFixed(0);
                                            }
                                        } else { // 'level'
                                            if (currentLevelDisplay !== null) {
                                                lastColumnValue = currentLevelDisplay.toFixed(0);
                                                if (isCritical) lastColumnClass += ' critical-actual-level';
                                            }
                                        }
                                        let levelColumnClass = 'numeric';
                                        if (currentLevelDisplay !== null && isCritical) levelColumnClass += ' critical-level';

                                        return (
                                            <tr key={`${gauge.name}-${gauge.km ?? gauge.streckenAbschnitt ?? apiData?.apiName}`} className={isCritical ? 'critical-row' : ''}>
                                                <td>{gauge.river || 'N/A'}</td>
                                                <td>{gauge.streckenAbschnitt || 'N/A'}</td>
                                                <td><a href={getGaugeUrl(gauge)} target="_blank" rel="noopener noreferrer" className="gauge-link">{gauge.name}</a></td>
                                                <td className="numeric">{gauge.giw !== 'N/A' ? gauge.giw : '-'}</td>
                                                <td className="numeric">{gauge.depthAtGiw !== 'N/A' ? gauge.depthAtGiw : '-'}</td>
                                                <td className={levelColumnClass}> {currentLevelDisplay !== null ? currentLevelDisplay.toFixed(0) : (apiData?.status === 'ERROR' ? `Error` : '-')} <div className="time-display">{currentTime !== 'N/A' ? currentTime : (apiData?.status ? '' : t('loading'))}</div> </td>
                                                <td className="numeric">{currentTrend}</td>
                                                <td className="numeric">{officialRuleDisplay}</td>
                                                <td className="numeric"><input type="number" value={customCorrections.upstream[gauge.name] ?? ''} onChange={(e) => handleCorrectionChange('upstream', gauge.name, e.target.value)}/></td>
                                                <td className="numeric"><input type="number" value={customCorrections.downstream[gauge.name] ?? ''} onChange={(e) => handleCorrectionChange('downstream', gauge.name, e.target.value)}/></td>
                                                <td className="numeric">{customRuleDisplayUp}</td>
                                                <td className="numeric">{customRuleDisplayDown}</td>
                                                <td className={lastColumnClass}> {lastColumnValue} {lastColumnValue !== '-' && <div className="time-display">{currentTime !== 'N/A' ? currentTime : ''}</div>} </td>
                                                {/* Forecast Columns */}
                                                {forecastDates.slice(1).map(dateStr => {
                                                    let forecastDisplayValue = '-';
                                                    let forecastDisplayTime = '';
                                                    let uncertaintyText = '';
                                                    let valueSource = '';
                                                    let foundWeeklySlot = null;
                                                    let forecastLevel = null;
                                                    let forecastSlot = null;
                                                    const forecastsForDate = apiData?.forecasts?.[dateStr];

                                                    if (forecastsForDate && Object.keys(forecastsForDate).length > 0) {
                                                        const gaugeBaseTime = getGaugeBaseTime(apiData);
const selectedTime = getBestForecastTime(forecastsForDate, gaugeBaseTime);
                                                        forecastSlot = selectedTime ? forecastsForDate[selectedTime] : null;
                                                        if (forecastSlot && forecastSlot.value !== undefined && forecastSlot.value !== null) {
                                                            forecastLevel = forecastSlot.value;
                                                            forecastDisplayTime = selectedTime;
                                                            valueSource = 'daily';
                                                        }
                                                    }

                                                    if (forecastLevel === null && Array.isArray(apiData?.weeklyForecasts)) {
                                                        const targetDate = new Date(dateStr + 'T12:00:00Z');
                                                        for (const weeklyForecast of apiData.weeklyForecasts) {
                                                            if (weeklyForecast.weekRange && weeklyForecast.median !== null) {
                                                                try {
                                                                    const [startStr, endStr] = weeklyForecast.weekRange.split('-');
                                                                    const [startDay, startMonth, startYear] = startStr.split('.');
                                                                    const [endDay, endMonth, endYear] = endStr.split('.');
                                                                    const startDate = new Date(Date.UTC(startYear, startMonth - 1, startDay, 0, 0, 0));
                                                                    const endDate = new Date(Date.UTC(endYear, endMonth - 1, endDay, 23, 59, 59));
                                                                    if (!isNaN(startDate.getTime()) && !isNaN(endDate.getTime()) && targetDate >= startDate && targetDate <= endDate) {
                                                                        forecastLevel = weeklyForecast.median;
                                                                        forecastDisplayTime = "(BfG6W)";
                                                                        valueSource = 'weekly';
                                                                        foundWeeklySlot = weeklyForecast;
                                                                        break;
                                                                    }
                                                                } catch (e) {}
                                                            }
                                                        }
                                                    }

                                                    if (forecastLevel !== null) {
                                                        const calculatedFcDraft = calculateDraft(gauge, forecastLevel, gauge.segmentDirection);
                                                        let calculatedFcValue = forecastLevel;

                                                        if (displayMode === 'draft') {
                                                            calculatedFcValue = calculatedFcDraft;
                                                        } else if (displayMode === 'tonnage' && tonnageRefShip && calculatedFcDraft !== null) {
                                                            calculatedFcValue = tonnageRefShip.fitFunc(calculatedFcDraft / 100);
                                                            if (tonnageRefShip.max_tonnage) {
                                                                calculatedFcValue = Math.min(calculatedFcValue, tonnageRefShip.max_tonnage);
                                                            }
                                                        }

                                                        forecastDisplayValue = (calculatedFcValue !== null && (displayMode !== 'tonnage' || calculatedFcValue > 0)) ? calculatedFcValue.toFixed(0) : '-';

                                                        if (showUncertainty && calculatedFcDraft !== null) {
                                                            if (valueSource === 'daily' && forecastSlot && forecastSlot.low_80 !== null && forecastSlot.high_80 !== null) {
                                                                let lowVal = forecastSlot.low_80, highVal = forecastSlot.high_80;
                                                                const draftLow = calculateDraft(gauge, forecastSlot.low_80, gauge.segmentDirection);
                                                                const draftHigh = calculateDraft(gauge, forecastSlot.high_80, gauge.segmentDirection);
                                                                if (displayMode === 'draft') {
                                                                    lowVal = draftLow;
                                                                    highVal = draftHigh;
                                                                } else if (displayMode === 'tonnage') {
                                                                    lowVal = draftLow !== null ? tonnageRefShip.fitFunc(draftLow / 100) : null;
                                                                    highVal = draftHigh !== null ? tonnageRefShip.fitFunc(draftHigh / 100) : null;
                                                                    if (lowVal !== null && tonnageRefShip.max_tonnage) lowVal = Math.min(lowVal, tonnageRefShip.max_tonnage);
                                                                    if (highVal !== null && tonnageRefShip.max_tonnage) highVal = Math.min(highVal, tonnageRefShip.max_tonnage);
                                                                }
                                                                if (lowVal !== null && !isNaN(lowVal) && highVal !== null && !isNaN(highVal)) {
                                                                    uncertaintyText = `(${Math.min(lowVal, highVal).toFixed(0)}–${Math.max(lowVal, highVal).toFixed(0)})`;
                                                                }
                                                            } else if (valueSource === 'daily') {
                                                                const now = new Date();
                                                                const uncertaintyCm = calculateForecastUncertainty(gauge, dateStr, now);
                                                                if (uncertaintyCm !== null) {
                                                                    const levelLow = forecastLevel - uncertaintyCm, levelHigh = forecastLevel + uncertaintyCm;
                                                                    let lowVal = levelLow, highVal = levelHigh;
                                                                    const draftLow = calculateDraft(gauge, levelLow, gauge.segmentDirection);
                                                                    const draftHigh = calculateDraft(gauge, levelHigh, gauge.segmentDirection);
                                                                    if (displayMode === 'draft') {
                                                                        lowVal = draftLow;
                                                                        highVal = draftHigh;
                                                                    } else if (displayMode === 'tonnage') {
                                                                        lowVal = draftLow !== null ? tonnageRefShip.fitFunc(draftLow / 100) : null;
                                                                        highVal = draftHigh !== null ? tonnageRefShip.fitFunc(draftHigh / 100) : null;
                                                                        if (lowVal !== null && tonnageRefShip.max_tonnage) lowVal = Math.min(lowVal, tonnageRefShip.max_tonnage);
                                                                        if (highVal !== null && tonnageRefShip.max_tonnage) highVal = Math.min(highVal, tonnageRefShip.max_tonnage);
                                                                    }
                                                                    if (lowVal !== null && !isNaN(lowVal) && highVal !== null && !isNaN(highVal)) {
                                                                        uncertaintyText = `(${Math.min(lowVal, highVal).toFixed(0)}–${Math.max(lowVal, highVal).toFixed(0)}*)`;
                                                                    }
                                                                }
                                                            } else if (valueSource === 'weekly' && foundWeeklySlot && foundWeeklySlot.low_90 !== null && foundWeeklySlot.high_90 !== null) {
                                                                let lowVal = foundWeeklySlot.low_90, highVal = foundWeeklySlot.high_90;
                                                                const draftLow = calculateDraft(gauge, foundWeeklySlot.low_90, gauge.segmentDirection);
                                                                const draftHigh = calculateDraft(gauge, foundWeeklySlot.high_90, gauge.segmentDirection);
                                                                if (displayMode === 'draft') {
                                                                    lowVal = draftLow;
                                                                    highVal = draftHigh;
                                                                } else if (displayMode === 'tonnage') {
                                                                    lowVal = draftLow !== null ? tonnageRefShip.fitFunc(draftLow / 100) : null;
                                                                    highVal = draftHigh !== null ? tonnageRefShip.fitFunc(draftHigh / 100) : null;
                                                                    if (lowVal !== null && tonnageRefShip.max_tonnage) lowVal = Math.min(lowVal, tonnageRefShip.max_tonnage);
                                                                    if (highVal !== null && tonnageRefShip.max_tonnage) highVal = Math.min(highVal, tonnageRefShip.max_tonnage);
                                                                }
                                                                if (lowVal !== null && !isNaN(lowVal) && highVal !== null && !isNaN(highVal)) {
                                                                    uncertaintyText = `(${Math.min(lowVal, highVal).toFixed(0)}–${Math.max(lowVal, highVal).toFixed(0)})`;
                                                                }
                                                            }
                                                        }
                                                    }

                                                    return (<td key={`forecast-${gauge.name}-${dateStr}`} className="numeric forecast-cell"> {forecastDisplayValue !== '-' ? (<div> {forecastDisplayValue} {showUncertainty && uncertaintyText && (<span className="uncertainty-display">{uncertaintyText}</span>)} {forecastDisplayTime && (<div className={`time-display ${valueSource === 'weekly' ? 'weekly' : ''}`}>{forecastDisplayTime}</div>)} </div>) : ('-')} </td>);
                                                })}
                                                {forecastDates.length === 0 && dataStatus.status !== 'pending' && <td className="forecast-cell">-</td>}
                                            </tr>
                                        );
                                    })}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    )}

                    {activeTab === 'planner' && (
                        <div className="table-area-padding">
                            <div className="planner-settings-group">
                                <h3>{t('plannerSettingsTitle')}</h3>
                                <div className="control-group"><label htmlFor="startDate">{t('departureTime')}:</label> <input type="datetime-local" id="startDate" value={plannerSettings.startDate} onChange={(e) => handlePlannerSettingChange('startDate', e.target.value)}/> <button onClick={handleSetNow} className="now-button">{t('now')}</button> </div>
                                <div className="control-group"><label htmlFor="speedDownstream">{t('speedDownstream')}:</label> <input type="number" id="speedDownstream" min="1" value={plannerSettings.speedDownstream} onChange={(e) => handlePlannerSettingChange('speedDownstream', Number(e.target.value))}/> </div>
                                <div className="control-group"><label htmlFor="speedUpstream">{t('speedUpstream')}:</label> <input type="number" id="speedUpstream" min="1" value={plannerSettings.speedUpstream} onChange={(e) => handlePlannerSettingChange('speedUpstream', Number(e.target.value))}/> </div>
                                <div className="control-group"><label htmlFor="speedCanal">{t('speedCanal')}:</label> <input type="number" id="speedCanal" min="1" step="0.1" style={{width: "70px"}} value={plannerSettings.speedCanal} onChange={(e) => handlePlannerSettingChange('speedCanal', Number(e.target.value))}/> <span style={{fontSize: '0.8em', color: '#aaa', marginLeft: '0.5rem'}}>{t('speedCanalHint')}</span> </div>
                                <div className="control-group"><label htmlFor="operationalMode">{t('system')}:</label> <select id="operationalMode" value={plannerSettings.operationalMode} onChange={handleOperationalModeChange}> <option value="A1">{t('systemA1')}</option> <option value="A2">{t('systemA2')}</option> <option value="B">{t('systemB')}</option> <option value="Custom">{t('systemCustom')}</option> </select> {plannerSettings.operationalMode === 'Custom' && ( <input type="number" min="1" max="24" step="0.5" style={{width: "60px", marginLeft: "0.5rem"}} aria-label="Custom operational hours" value={plannerSettings.customOperationalHours} onChange={(e) => handlePlannerSettingChange('customOperationalHours', Number(e.target.value))}/>)} {plannerSettings.operationalMode !== 'Custom' && ( <span style={{ fontSize: '0.85em', color: '#aaa', marginLeft: '0.5rem' }}> ({plannerSettings.operationalMode === 'A1' ? 14 : (plannerSettings.operationalMode === 'A2' ? 18 : 24)} {t('hoursPerDay')}) </span>)} </div>
                                <div className="control-group"><label>{t('excludedDays')}:</label> <div className="excluded-days-group"> {weekdays.map((day, index) => ( <label key={day} className="day-label"> <input type="checkbox" checked={plannerSettings.excludedDays.includes(index)} onChange={(e) => handleExcludedDayChange(index, e.target.checked)}/> {day} </label>))} </div> </div>
                                <div className="control-group"><label htmlFor="showUncertaintyPlanner" className="toggle-label">{t('showUncertaintyPlanner')}:</label> <input type="checkbox" id="showUncertaintyPlanner" checked={showUncertainty} onChange={handleUncertaintyToggle}/> <span style={{fontSize: '0.8em', color: '#aaa'}}>{t('ifAvailable')}</span></div>
                                <div style={{borderTop: '1px solid #444', paddingTop: '1rem', marginTop: '1rem'}}>
                                    <h4>{t('optionalSegment')}</h4>
                                    <div className="control-group"> <label htmlFor="customSegmentKm">{t('extraDistance')}:</label> <input type="number" id="customSegmentKm" min="0" step="1" style={{width: "70px"}} value={plannerSettings.customSegmentKm} onChange={(e) => handlePlannerSettingChange('customSegmentKm', Number(e.target.value))} /> </div>
                                    <div className="control-group"> <label htmlFor="customSegmentSpeed">{t('extraSpeed')}:</label> <input type="number" id="customSegmentSpeed" min="0" step="0.5" style={{width: "70px"}} value={plannerSettings.customSegmentSpeed} onChange={(e) => handlePlannerSettingChange('customSegmentSpeed', Number(e.target.value))} /> </div>
                                    <div className="control-group"> <label htmlFor="customSegmentPosition">{t('extraPosition')}:</label> <select id="customSegmentPosition" value={plannerSettings.customSegmentPosition} onChange={(e) => handlePlannerSettingChange('customSegmentPosition', e.target.value)}> <option value="end">{t('posAfter')}</option> <option value="start">{t('posBefore')}</option> </select> <span style={{fontSize: '0.8em', color: '#aaa', marginLeft: '0.5rem'}}>{t('posHint')}</span> </div>
                                </div>
                                </div>
                            {routePlanStatus === 'error' && routePlanResult?.error && (<div style={{ color: '#ff6666', marginTop: '1rem', border: '1px solid red', padding: '0.5rem' }}> {t('calculationError', { error: routePlanResult.error })} </div>)}
                            {routePlanStatus === 'calculated' && routePlanResult && !routePlanResult.error && (
                                <div className="route-plan-results">
                                    <h4>{t('plannerResultTitle')}</h4>
                                    <div className="route-plan-summary"> {t('maxPossibleDraft')}: <strong>{routePlanResult.overallMaxDraft !== null ? `${routePlanResult.overallMaxDraft.toFixed(0)} cm` : 'N/A'}</strong>
                                        {routePlanResult.limitReason ? ( <span style={{ fontSize: '0.9em', color: '#ccc' }}> ({t('limitedBy')}: {routePlanResult.limitReason.message}) </span>
                                        ) : routePlanResult.criticalPoint ? ( <span style={{ fontSize: '0.9em', color: '#ccc' }}> ({t('limitedBy')}: {routePlanResult.criticalPoint.name} op KM {routePlanResult.criticalPoint.km} {showUncertainty && routePlanResult.criticalPoint.uncertaintyText ? ` ${routePlanResult.criticalPoint.uncertaintyText}` : ''}) </span>
                                        ) : null}
                                    </div>
                                    {routePlanResult.mgdWarning && ( <div className="mgd-warning"> {routePlanResult.mgdWarning} </div>)}
                                    <h5>{t('routeDetails')}:</h5>
                                    <div className="table-scroll-wrapper">
                                        <table className="original-table">
                                            <thead> <tr> <th>{t('plannerHeaderKm')}</th> <th>{t('plannerHeaderName')}</th> <th>{t('plannerHeaderEta')}</th> <th>{t('plannerHeaderForecastLevel')}</th> <th>{t('plannerHeaderOffset')}</th> <th>{t('plannerHeaderAdjRule')}</th> <th>{t('plannerHeaderMaxDraft')}</th> <th>{t('plannerHeaderNotes')}</th> </tr> </thead>
                                            <tbody>
                                            {routePlanResult.points.length === 0 && (<tr> <td colSpan="8" style={{textAlign: 'center', fontStyle: 'italic'}}>{t('noRoutePoints')}</td> </tr>)}
                                            {routePlanResult.points.map((point, index) => (
                                                <tr key={`${point.name}-${point.km}-${index}`} className={point.isCritical ? 'critical-route-point' : ''}>
                                                    <td className="numeric">{point.km}</td>
                                                    <td><a href={getGaugeUrl(point.gaugeRef)} target="_blank" rel="noopener noreferrer" className="gauge-link">{point.name}</a></td>
                                                    <td className="eta-time"> {point.eta.toLocaleDateString(locale, { weekday: 'short', day: 'numeric', month: 'short' })} {' '} {point.eta.toLocaleTimeString(locale, { hour: '2-digit', minute: '2-digit' })} </td>
                                                    <td className="numeric"> {point.forecastLevel !== null ? point.forecastLevel.toFixed(0) : '-'} {point.forecastTime && point.forecastTime !== 'N/A' && (<div className={`time-display ${point.forecastSource === 'weekly' ? 'weekly' : (point.forecastSource === 'current' ? 'current' : '')}`}>{point.forecastTime}</div>)} </td>
                                                    <td className="offset-value numeric"> {point.offset} </td>
                                                    <td className="numeric"> {point.correctedRule !== 'N/A' && !isNaN(Number(point.correctedRule)) ? Number(point.correctedRule).toFixed(0) : (point.correctedRule === 'N/A' ? '-' : point.correctedRule)} </td>
                                                    <td className="numeric"> {point.draftAtEta !== null ? point.draftAtEta.toFixed(0) : '-'} {showUncertainty && point.draftUncertaintyText && (<span className="uncertainty-display" style={{textAlign: 'right'}}>{point.draftUncertaintyText}</span>)} </td>
                                                    <td>{point.notes}</td>
                                                </tr>
                                            ))}
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                            )}
                        </div>
                    )}

                    {activeTab === 'cargo' && (
                        <div className="table-area-padding">
                             <div className="cargo-controls">
                                <div className="control-group">
                                    <label htmlFor="cargoDraftInput">{t('cargoInputDraft')}:</label>
                                    <input type="number" id="cargoDraftInput" value={cargoDraft} onChange={(e) => setCargoDraft(Number(e.target.value))} step="0.1" style={{width: '70px'}} />
                                </div>
                                <div className="control-group">
                                    <label style={{minWidth:'150px'}}>&nbsp;</label> {/* Spacer */}
                                    <div>
                                        <button onClick={handleSetCargoDraftFromCritical} className="cargo-controls-button" disabled={criticalDraftValue === null || criticalDraftValue === Infinity}>{t('useCriticalDraft')}</button>
                                        <span style={{color: '#aaa', fontSize: '0.9em', marginLeft: '0.5rem'}}> ({t('now')}: {criticalDraftValue !== null ? (criticalDraftValue / 100).toFixed(2) + 'm' : 'N/A'}) </span>
                                        <button onClick={handleSetCargoDraftFromPlanner} className="cargo-controls-button" style={{marginLeft: '1rem'}} disabled={!routePlanResult || routePlanResult.error || routePlanResult.overallMaxDraft === null}>{t('usePlannerDraft')}</button>
                                        <span style={{color: '#aaa', fontSize: '0.9em', marginLeft: '0.5rem'}}> ({t('tabPlanner')}: {(routePlanResult && !routePlanResult.error && routePlanResult.overallMaxDraft !== null) ? (routePlanResult.overallMaxDraft / 100).toFixed(2) + 'm' : 'N/A'}) </span>
                                    </div>
                                </div>
                                {isOnMDK && cargoDraft > 2.50 && (
                                    <div className="loading-warning">
                                        {t('loadingWarningMDKDraft', {input_draft: cargoDraft.toFixed(2)})}
                                    </div>
                                )}
                                <div className="control-group">
                                    <label>{t('shipFilterCategory')}:</label>
                                    <div className="ship-category-filter">
                                        <button className={shipFilter === 'all' ? 'active' : ''} onClick={() => setShipFilter('all')}>{t('categoryAll')}</button>
                                        <button className={shipFilter === 'dry_cargo' ? 'active' : ''} onClick={() => setShipFilter('dry_cargo')}>{t('categoryDryCargo')}</button>
                                        <button className={shipFilter === 'tanker' ? 'active' : ''} onClick={() => setShipFilter('tanker')}>{t('categoryTanker')}</button>
                                    </div>
                                </div>
                                <div className="control-group">
                                    <label>{t('manageCustomShips')}:</label>
                                    <button onClick={() => setIsCustomShipModalOpen(true)} className="add-ship-btn">{t('addCustomShip')}</button>
                                </div>
                                {customShips.length > 0 && (
                                <div className="custom-ship-list">
                                    {customShips.map(ship => (
                                    <div key={ship.id} className="custom-ship-item">
                                        <span>{ship.name}</span>
                                        <button className="delete-ship-btn" onClick={() => handleDeleteCustomShip(ship.id, ship.name)}>Delete</button>
                                    </div>
                                    ))}
                                </div>
                                )}
                             </div>
                             <div className="ship-list">
                                {['dry_cargo', 'tanker'].map(category => {
                                    const shipsInCategory = filteredShipsForCargoTab.filter(s => s.category === category);
                                    if(shipsInCategory.length === 0) return null;
                                    const categoryName = category === 'dry_cargo' ? t('categoryDryCargo') : t('categoryTanker');
                                    return (
                                        <div key={category} className="ship-category-group">
                                            <h4>{categoryName}</h4>
                                            {shipsInCategory.map(ship => {
                                                // Use the pre-calculated tonnage for display. It's uncapped as requested.
                                                const displayTonnage = ship.currentTonnage;
                                                const maxTonnage = ship.max_tonnage || 1;

                                                // The visual percentage can go over 100% to indicate overflow
                                                const percentage = (displayTonnage / maxTonnage) * 100;

                                                const crew = ship.min_crew_required?.A1?.S1;
                                                const crewMax = ship.min_crew_required?.B?.S1;
                                                const crewDisplay = crew && crewMax ? `${crew}-${crewMax} (A1-B)` : 'N/A';

                                                const effectiveDraft = isOnMDK ? Math.min(cargoDraft, 2.50) : cargoDraft;
                                                const isBelowMinDraft = effectiveDraft < ship.min_draft;

                                                // The loading bar's width is capped at 100%
                                                const barPercent = Math.min(percentage, 100);

                                                let barClass = "loading-bar";
                                                if (ship.isAllowed) {
                                                    if (isBelowMinDraft) {
                                                        barClass += ' below-min-draft';
                                                    } else if (percentage > 100) {
                                                        barClass += ' over-100';
                                                    }
                                                }

                                                return (
                                                    <div key={ship.id} className={`ship-card ${ship.category === 'tanker' ? 'is-tanker' : ''} ${!ship.isAllowed ? 'disallowed' : ''}`}>
                                                        <div className="ship-header">
                                                            <h5 className="ship-name">{ship.name}</h5>
                                                            <div className="ship-details"> {ship.length}m x {ship.width}m x {ship.max_draft.toFixed(2)}m &nbsp;|&nbsp; {t('crew')}: {crewDisplay} </div>
                                                        </div>
                                                        <div className="ship-loading-info">
                                                            <span className="loading-text">
                                                                {displayTonnage.toFixed(0)} T / {maxTonnage.toFixed(0)} T ({percentage.toFixed(1)}%)
                                                            </span>
                                                            <div className="loading-bar-container">
                                                                <div className={barClass}
                                                                    style={{ width: `${barPercent}%` }}
                                                                ></div>
                                                            </div>
                                                            {ship.isAllowed && isBelowMinDraft && <div className="loading-warning">{t('loadingWarningMinDraft', {min_draft: ship.min_draft.toFixed(2)})}</div>}
                                                        </div>
                                                        {ship.constraintWarnings.length > 0 && (
                                                            <div className="ship-constraints">
                                                                <strong>{ship.isAllowed ? t('warnings') : t('notAllowedOnRoute')}</strong>
                                                                <ul> {ship.constraintWarnings.map((warn, i) => <li key={i}>{warn}</li>)} </ul>
                                                            </div>
                                                        )}
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    )
                                })}
                            </div>
                        </div>
                    )}
                </div>

                <footer>
                    <div>{t('footerApiDate')}: {lastUpdated ? lastUpdated.toLocaleString(locale, { dateStyle: 'short', timeStyle: 'short' }) : t('notLoadedYet')}</div>
                    <div>RDD Calculator &copy; FilipJFZ</div>
                </footer>
            </div>
        );
    }

    const CustomShipModal = ({ onClose, onSave, baseShips }) => {
        const { t } = useContext(I18nContext);
        const [shipName, setShipName] = useState('');
        const [creationMethod, setCreationMethod] = useState('tpc');
        const [minDraft, setMinDraft] = useState(1.0);
        const [maxDraft, setMaxDraft] = useState(3.5);
        const [length, setLength] = useState(110);
        const [width, setWidth] = useState(11.45);
        const [category, setCategory] = useState('dry_cargo');
        // TPC state
        const [tpc, setTpc] = useState(10);
        const [emptyDraft, setEmptyDraft] = useState(1.5);
        // Points state
        const [points, setPoints] = useState([{draft: 1.5, tonnage: 500}, {draft: 2.5, tonnage: 1500}]);
        // Inherit state
        const [baseShip, setBaseShip] = useState(baseShips[0]?.id || '');
        const [inheritPoint, setInheritPoint] = useState({draft: 2.5, tonnage: 2000});

        const handlePointChange = (index, field, value) => {
            const newPoints = [...points];
            newPoints[index][field] = Number(value);
            setPoints(newPoints);
        };
        const addPoint = () => setPoints([...points, {draft: 0, tonnage: 0}]);
        const removePoint = (index) => setPoints(points.filter((_, i) => i !== index));

        const isFormValid = () => {
            if (!shipName.trim()) return false;
            if(creationMethod === 'tpc') return tpc > 0 && emptyDraft > 0;
            if(creationMethod === 'points') return points.length >= 2 && points.every(p => p.draft > 0 && p.tonnage > 0);
            if(creationMethod === 'inherit') return baseShip && inheritPoint.draft > 0 && inheritPoint.tonnage > 0;
            return false;
        };

        const handleSave = () => {
            if (!isFormValid()) {
                // You could add more specific error messages here
                alert("Please fill out the form correctly.");
                return;
            }
            const newShip = {
                name: shipName.trim(),
                length: Number(length),
                width: Number(width),
                min_draft: Number(minDraft),
                max_draft: Number(maxDraft),
                category,
                creationMethod,
            };
            if(creationMethod === 'tpc') {
                newShip.tpc = Number(tpc);
                newShip.emptyDraft = Number(emptyDraft);
            } else if (creationMethod === 'points') {
                newShip.points = points.map(p => ({draft: Number(p.draft), tonnage: Number(p.tonnage)}));
            } else if (creationMethod === 'inherit') {
                newShip.baseShip = baseShip;
                newShip.points = [{draft: Number(inheritPoint.draft), tonnage: Number(inheritPoint.tonnage)}];
            }
            onSave(newShip);
        };

        return (
            <div className="modal-backdrop" onClick={onClose}>
                <div className="modal-content" onClick={e => e.stopPropagation()}>
                    <div className="modal-header">
                        <h3>{t('modalTitleAddShip')}</h3>
                        <button className="modal-close-btn" onClick={onClose}>&times;</button>
                    </div>

                    <div className="modal-form-group">
                        <label htmlFor="shipName">{t('modalShipName')}</label>
                        <input id="shipName" type="text" value={shipName} onChange={e => setShipName(e.target.value)} />
                    </div>
                    <div className="modal-form-group">
                        <label>Dimensions & Type</label>
                        <div className="control-group">
                            <input type="number" value={length} onChange={e=>setLength(e.target.value)} placeholder="Length (m)" />
                            <input type="number" value={width} onChange={e=>setWidth(e.target.value)} placeholder="Width (m)" />
                             <select value={category} onChange={e=>setCategory(e.target.value)}>
                                <option value="dry_cargo">{t('categoryDryCargo')}</option>
                                <option value="tanker">{t('categoryTanker')}</option>
                            </select>
                        </div>
                         <div className="control-group">
                             <input type="number" value={minDraft} onChange={e=>setMinDraft(e.target.value)} placeholder="Min Draft (m)" />
                             <input type="number" value={maxDraft} onChange={e=>setMaxDraft(e.target.value)} placeholder="Max Draft (m)" />
                         </div>
                    </div>
                    <div className="modal-form-group">
                        <label htmlFor="creationMethod">{t('modalCreationMethod')}</label>
                        <select id="creationMethod" value={creationMethod} onChange={e => setCreationMethod(e.target.value)}>
                            <option value="tpc">{t('modalMethodTpc')}</option>
                            <option value="points">{t('modalMethodPoints')}</option>
                            <option value="inherit">{t('modalMethodInherit')}</option>
                        </select>
                    </div>

                    {creationMethod === 'tpc' && (
                        <div className="modal-form-group">
                            <label>{t('modalEmptyDraft')}</label>
                            <input type="number" value={emptyDraft} onChange={e => setEmptyDraft(e.target.value)} />
                            <label>{t('modalTpc')}</label>
                            <input type="number" value={tpc} onChange={e => setTpc(e.target.value)} />
                        </div>
                    )}

                    {creationMethod === 'points' && (
                        <div className="modal-form-group">
                            <div className="modal-form-points-list">
                            {points.map((p, i) => (
                                <div key={i} className="control-group modal-form-point-item">
                                    <input type="number" value={p.draft} onChange={e => handlePointChange(i, 'draft', e.target.value)} placeholder={t('modalDraft')} />
                                    <input type="number" value={p.tonnage} onChange={e => handlePointChange(i, 'tonnage', e.target.value)} placeholder={t('modalTonnage')} />
                                    {points.length > 2 && <button onClick={() => removePoint(i)}>&times;</button>}
                                </div>
                            ))}
                            </div>
                            <button onClick={addPoint} style={{alignSelf: 'flex-start', marginTop: '0.5rem'}}>{t('modalAddPoint')}</button>
                        </div>
                    )}

                     {creationMethod === 'inherit' && (
                        <div className="modal-form-group">
                            <label>{t('modalBaseShip')}</label>
                            <select value={baseShip} onChange={e => setBaseShip(e.target.value)}>
                                {baseShips.map(s => <option key={s.id} value={s.id}>{s.name}</option>)}
                            </select>
                            <label>Data Point</label>
                             <div className="control-group">
                                <input type="number" value={inheritPoint.draft} onChange={e => setInheritPoint({...inheritPoint, draft: e.target.value})} placeholder={t('modalDraft')} />
                                <input type="number" value={inheritPoint.tonnage} onChange={e => setInheritPoint({...inheritPoint, tonnage: e.target.value})} placeholder={t('modalTonnage')} />
                            </div>
                        </div>
                    )}

                    <div className="modal-footer">
                        <button className="cancel-btn" onClick={onClose}>{t('modalCancel')}</button>
                        <button className="save-btn" onClick={handleSave} disabled={!isFormValid()}>{t('modalSave')}</button>
                    </div>
                </div>
            </div>
        );
    }


    ReactDOM.render(
        <I18nProvider>
            <RhineDraftCalculator/>
        </I18nProvider>,
        document.getElementById('root')
    );

</script>
</body>
</html>