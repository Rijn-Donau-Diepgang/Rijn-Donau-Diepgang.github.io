
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <!-- I18N: Title will be set dynamically -->
    <title>Diepgang calculator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.21.2/babel.min.js"></script>
    <style>
        /* --- CSS is unchanged, so it is omitted for brevity --- */
        /* --- Base & Layout (Combined - Using Original Base) --- */
        html, body {
            margin: 0;
            padding: 0;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            color: white;
            background-color: #121212;
            min-height: 150vh; /* Ensure enough scroll height for testing */
        }

        .container {
            display: flex;
            flex-direction: column;
            width: 100%;
            min-height: 100vh;
        }

        /* --- Header Controls Area (Merged: Original Layout + Planner Controls) --- */
        header.controls-area {
            background-color: #1e1e1e;
            padding: 1rem;
            border-bottom: 1px solid #333;
            flex-shrink: 0;
            z-index: 20;
            position: relative;
            min-height: 100px;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: flex-start;
            gap: 1rem;
        }

        .controls-left {
            flex: 2;
            min-width: 400px;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .controls-left > div {
            margin-bottom: 0.5rem;
        }

        .controls-left > div:last-child {
            margin-bottom: 0;
        }

        .controls-right {
            flex: 1;
            min-width: 300px;
            max-width: 500px;
            align-self: flex-start;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .control-group label:not(.day-label):not(.toggle-label) {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            min-width: 120px; /* Slightly wider default */
        }

        select, input, button {
            background-color: #2a2a2a;
            color: white;
            border: 1px solid #444;
            padding: 0.5rem;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        input[type="number"] {
            width: 50px;
            text-align: right;
            padding: 0.4rem;
        }

        input[type="datetime-local"] {
            background-color: #2a2a2a;
            color: white;
            border: 1px solid #444;
            padding: 0.4rem;
            border-radius: 4px;
            font-size: 0.9rem;
            color-scheme: dark;
        }

        input[type="checkbox"], input[type="radio"] {
            width: auto;
            margin-right: 0.3rem;
            accent-color: #4da6ff;
        }

        button {
            cursor: pointer;
        }

        .view-toggle-group label {
            margin-right: 1rem;
            cursor: pointer;
            min-width: unset;
        }

        /* Override min-width for toggles */
        .view-toggle-group input[type="radio"] {
            margin-right: 0.3rem;
        }

        /* --- Route Planner Specific Styles --- */
        .planner-settings-group {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            margin-bottom: 1rem;
        }

        .planner-settings-group .control-group {
            align-items: center;
            gap: 0.8rem;
        }

        .planner-settings-group .control-group label:not(.day-label):not(.toggle-label) {
            min-width: 180px;
        }

        .planner-settings-group input[type="number"] {
            width: 60px;
        }

        .excluded-days-group {
            display: flex;
            gap: 0.8rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .excluded-days-group label.day-label {
            min-width: 40px;
        }

        .now-button {
            padding: 0.4rem 0.6rem;
            font-size: 0.8rem;
            margin-left: 0.3rem;
            background-color: #444;
        }

        .now-button:hover {
            background-color: #555;
        }

        .planner-calculate-btn {
            background-color: #0080ff;
            font-weight: bold;
            padding: 0.6rem 1.2rem;
        }

        .planner-calculate-btn:disabled {
            background-color: #444;
            cursor: not-allowed;
        }

        .route-plan-results {
            margin-top: 1.5rem;
            padding: 1rem;
            background-color: #1e1e1e;
            border: 1px solid #333;
            border-radius: 4px;
        }

        .route-plan-summary {
            margin-bottom: 1rem;
            font-size: 1.1em;
        }

        .route-plan-summary strong {
            color: #4da6ff;
        }

        .mgd-warning {
            color: #ffcc00;
            background-color: rgba(255, 204, 0, 0.1);
            border: 1px solid #cc9900;
            padding: 0.5rem;
            border-radius: 4px;
            margin-top: 0.5rem;
            font-size: 0.9em;
        }

        /* --- Main Content Area (Original) --- */
        .main-content {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            padding: 0;
        }

        /* --- Tab Controls (Original) --- */
        .tab-controls {
            margin-bottom: 1rem;
            border-bottom: 1px solid #333;
            padding: 1rem 1rem 0.5rem 1rem;
            background-color: #121212; /* Match body */
            flex-shrink: 0;
            position: relative; /* Keep stacking context */
            z-index: 15; /* Below controls, above table */
        }

        .tab-button {
            background-color: #2a2a2a;
            border: 1px solid #444;
            padding: 0.5rem 1rem;
            margin-right: 0.5rem;
            border-radius: 4px 4px 0 0;
            cursor: pointer;
        }

        .tab-button.active {
            background-color: #3a3a3a;
            border-bottom: 1px solid #3a3a3a;
            font-weight: bold;
        }

        .tab-button:disabled {
            background-color: #222;
            color: #666;
            cursor: not-allowed;
            border-color: #333;
        }

        /* --- Table Area Structures (Original) --- */
        .table-area-padding {
            padding: 0 1rem 1rem 1rem; /* Apply padding here */
            width: 100%;
            box-sizing: border-box;
            flex-grow: 1; /* Allow it to take space */
            display: flex; /* Use flex to make wrapper fill it */
            flex-direction: column; /* Stack sentinel and wrapper */
        }

        .header-sentinel {
            height: 1px; /* Trigger for IntersectionObserver */
            flex-shrink: 0;
        }

        .table-scroll-wrapper {
            overflow-x: auto; /* Handle horizontal scroll */
            overflow-y: visible; /* Allow content height to determine wrapper height */
            width: 100%; /* Take full width of the padding container */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            flex-grow: 1; /* Take remaining space */
            display: block; /* Needed for overflow to work correctly with flex parent */
            flex-shrink: 0; /* Prevent shrinking */
        }

        /* --- Original Table (Styles from FIRST block - DESIRED STATE) --- */
        /* These apply unless overridden by .route-plan-results above */
        table.original-table {
            width: 100%;
            border-collapse: collapse;
            border-spacing: 0;
            background-color: #1a1a1a; /* Table background */
            table-layout: fixed; /* KEY: Use fixed layout */
        }

        /* Original Table Header / Visibility (from FIRST block) */
        .original-table > thead {
            visibility: visible; /* Default state */
        }

        .original-table > thead.hidden {
            visibility: hidden !important; /* Hide when fixed header is active */
        }

        /* Original Header Cells (thead th) - Base Styles (from FIRST block) */
        .original-table > thead th {
            background-color: #1e1e1e; /* Header background */
            border-bottom: 1px solid #555;
            padding: 0.6rem 0.4rem; /* <<< CHANGED: Increased vertical padding for wrapping */
            text-align: left;
            white-space: normal; /* <<< CHANGED: Allow text to wrap */
            overflow: visible;
            text-overflow: clip;
            border-left: 1px solid #333;
            vertical-align: middle;
            font-size: 0.8rem;
            font-weight: bold;
            line-height: 1.3; /* <<< CHANGED: Increased for better multi-line readability */
        }

        .original-table > thead th:first-child {
            border-left: none;
        }

        .original-table > thead th.numeric {
            text-align: right;
        }

        .original-table > thead th.center {
            text-align: center;
        }

        .original-table > thead tr:first-child th {
            border-top: 1px solid #555;
        }

        /* --- Define Column Width Variables & Font Sizes --- */
        :root {
            /* Default width (Original) */
            --col-default-width: 60px;

            /* Column-specific widths (FROM FIRST BLOCK - DESIRED ORIGINAL STATE) */
            --col-1-width: 80px; /* Rivier */
            --col-2-width: 90px; /* Strecke */
            --col-3-width: 95px; /* Naam */
            --col-4-width: 45px; /* GIW */
            --col-5-width: 45px; /* TuGIW */
            --col-6-width: 45px; /* Waarde Actueel */
            --col-7-width: 45px; /* Tendens */
            --col-8-width: 65px; /* Off. Vuist */
            --col-9-width: 150px; /* Correctie Op (Original Wider Value) */
            --col-10-width: 100px; /* Correctie Af (Original Wider Value) */
            --col-11-width: 65px; /* Aang. Vuist Op */
            --col-12-width: 45px; /* Aang. Vuist Af */
            --col-13-width: 100px; /* Diepgang/Waarde Actueel */
            --forecast-width: 45px; /* Forecast Columns */

            /* NEW: Font size for table body cells */
            --table-body-font-size: 0.9rem; /* Adjust this value easily */

            /* Route Plan Table Widths */
            --rp-col-km-width: 50px;
            --rp-col-name-width: 100px;
            --rp-col-eta-width: 140px;
            --rp-col-level-width: 70px;
            --rp-col-offset-width: 65px; /* Offset Column */
            /* NEW: Width for Corrected Rule column */
            --rp-col-rule-width: 75px;
            --rp-col-draft-width: 90px;
            --rp-col-notes-width: 120px;
        }

        /* Original Body Cells (tbody td) - Base Styles */
        .original-table > tbody td {
            padding: 0.5rem 0.4rem; /* Original reduced padding */
            text-align: left;
            border-bottom: 1px solid #333;
            white-space: normal; /* Allow wrapping */
            border-left: 1px solid #333;
            vertical-align: middle;
            /* USE VARIABLE: Apply the font size variable */
            font-size: var(--table-body-font-size);
            line-height: 1.3; /* Original line height */
        }

        .original-table > tbody td:first-child {
            border-left: none;
        }

        .original-table > tbody td.numeric {
            text-align: right;
        }

        .original-table > tbody td.center {
            text-align: center;
        }

        .original-table > tbody tr:hover td {
            background-color: #2a2a2a;
        }

        /* --- Default Column Settings (Original) --- */
        /* Applies to Max Draft/All tabs via .original-table, unless overridden by .route-plan-results */
        .original-table > thead th,
        .original-table > tbody td {
            min-width: var(--col-default-width);
            width: auto; /* Let specific widths below take precedence */
        }

        /* --- Column Width Definitions (Applied to ORIGINAL table - From FIRST block) --- */
        /* Column 1 - Rivier */
        .original-table > thead th:nth-child(1), .original-table > tbody td:nth-child(1) {
            min-width: var(--col-1-width);
            width: var(--col-1-width);
            max-width: var(--col-1-width);
        }

        /* Column 2 - Strecke */
        .original-table > thead th:nth-child(2), .original-table > tbody td:nth-child(2) {
            min-width: var(--col-2-width);
            width: var(--col-2-width);
            max-width: var(--col-2-width);
        }

        /* Column 3 - Naam */
        .original-table > thead th:nth-child(3), .original-table > tbody td:nth-child(3) {
            min-width: var(--col-3-width);
            width: var(--col-3-width);
            max-width: var(--col-3-width);
        }

        /* Column 4 - GIW */
        .original-table > thead th:nth-child(4), .original-table > tbody td:nth-child(4) {
            min-width: var(--col-4-width);
            width: var(--col-4-width);
        }

        /* Column 5 - TuGIW */
        .original-table > thead th:nth-child(5), .original-table > tbody td:nth-child(5) {
            min-width: var(--col-5-width);
            width: var(--col-5-width);
        }

        /* Column 6 - Waarde Actueel */
        .original-table > thead th:nth-child(6), .original-table > tbody td:nth-child(6) {
            min-width: var(--col-6-width);
            width: var(--col-6-width);
        }

        /* Column 7 - Tendens */
        .original-table > thead th:nth-child(7), .original-table > tbody td:nth-child(7) {
            min-width: var(--col-7-width);
            width: var(--col-7-width);
        }

        /* Column 8 - Off. Vuist */
        .original-table > thead th:nth-child(8), .original-table > tbody td:nth-child(8) {
            min-width: var(--col-8-width);
            width: var(--col-8-width);
            max-width: var(--col-8-width);
        }

        /* Column 9 - Correctie Op */
        .original-table > thead th:nth-child(9), .original-table > tbody td:nth-child(9) {
            min-width: var(--col-9-width);
            width: var(--col-9-width);
            max-width: var(--col-9-width);
        }

        /* Column 10 - Correctie Af */
        .original-table > thead th:nth-child(10), .original-table > tbody td:nth-child(10) {
            min-width: var(--col-10-width);
            width: var(--col-10-width);
            max-width: var(--col-10-width);
        }

        /* Column 11 - Aang. Vuist Op */
        .original-table > thead th:nth-child(11), .original-table > tbody td:nth-child(11) {
            min-width: var(--col-11-width);
            width: var(--col-11-width);
            max-width: var(--col-11-width);
        }

        /* Column 12 - Aang. Vuist Af */
        .original-table > thead th:nth-child(12), .original-table > tbody td:nth-child(12) {
            min-width: var(--col-12-width);
            width: var(--col-12-width);
            max-width: var(--col-12-width);
        }

        /* Column 13 - Diepgang/Waarde Actueel */
        .original-table > thead th:nth-child(13), .original-table > tbody td:nth-child(13) {
            min-width: var(--col-13-width);
            width: var(--col-13-width);
            max-width: var(--col-13-width);
        }

        /* Forecast Columns */
        .original-table > thead th.forecast-header, .original-table > tbody td.forecast-cell {
            min-width: var(--forecast-width);
            width: var(--forecast-width);
        }

        /* Optional: Text handling for certain original columns */
        .original-table > tbody td:nth-child(11),
        .original-table > tbody td:nth-child(12) {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* --- Column Width Definitions (Route Plan Table - Specific overrides) --- */
        /* Applied ONLY within the .route-plan-results context */
        /* NOTE: nth-child indexes are shifted after adding the new column */
        .route-plan-results .original-table th:nth-child(1), .route-plan-results .original-table td:nth-child(1) {
            width: var(--rp-col-km-width);
            min-width: var(--rp-col-km-width);
            max-width: none;
            text-align: right;
        }

        /* KM */
        .route-plan-results .original-table th:nth-child(2), .route-plan-results .original-table td:nth-child(2) {
            width: var(--rp-col-name-width);
            min-width: var(--rp-col-name-width);
            max-width: none;
            text-align: left;
        }

        /* Naam */
        .route-plan-results .original-table th:nth-child(3), .route-plan-results .original-table td:nth-child(3) {
            width: var(--rp-col-eta-width);
            min-width: var(--rp-col-eta-width);
            max-width: none;
            text-align: left;
        }

        /* ETA */
        .route-plan-results .original-table th:nth-child(4), .route-plan-results .original-table td:nth-child(4) {
            width: var(--rp-col-level-width);
            min-width: var(--rp-col-level-width);
            max-width: none;
            text-align: right;
        }

        /* Forecast Level */
        .route-plan-results .original-table th:nth-child(5), .route-plan-results .original-table td:nth-child(5) {
            width: var(--rp-col-offset-width);
            min-width: var(--rp-col-offset-width);
            max-width: none;
            text-align: right;
        }

        /* Offset */
        /* NEW: Corrected Rule Column (index 6) */
        .route-plan-results .original-table th:nth-child(6), .route-plan-results .original-table td:nth-child(6) {
            width: var(--rp-col-rule-width);
            min-width: var(--rp-col-rule-width);
            max-width: none;
            text-align: right;
        }

        /* Corrected Rule */
        /* SHIFTED: Max Draft Column (now index 7) */
        .route-plan-results .original-table th:nth-child(7), .route-plan-results .original-table td:nth-child(7) {
            width: var(--rp-col-draft-width);
            min-width: var(--rp-col-draft-width);
            max-width: none;
            text-align: right;
        }

        /* Max Draft */
        /* SHIFTED: Notes Column (now index 8) */
        .route-plan-results .original-table th:nth-child(8), .route-plan-results .original-table td:nth-child(8) {
            width: var(--rp-col-notes-width);
            min-width: var(--rp-col-notes-width);
            max-width: none;
            font-size: 0.8em;
            color: #aaa;
            text-align: left;
        }

        /* Notes */
        /* Reset any further columns in planner results if they exist (unlikely) */
        .route-plan-results .original-table th:nth-child(n+9),
        .route-plan-results .original-table td:nth-child(n+9) {
            width: auto;
            min-width: var(--col-default-width);
            max-width: none;
        }

        /* Styles for table *inside* planner results (overrides general styles) */
        .route-plan-results .original-table th,
        .route-plan-results .original-table td {
            /* USE VARIABLE: Apply the font size variable here too */
            font-size: var(--table-body-font-size);
            padding: 0.4rem 0.5rem;
        }

        .route-plan-results .original-table .critical-route-point td {
            background-color: rgba(255, 100, 100, 0.2) !important;
            font-weight: bold;
        }

        .route-plan-results .original-table .eta-time {
            font-size: 0.9em;
            color: #ccc;
        }

        .route-plan-results .original-table .offset-value {
            font-style: italic;
            color: #bbb;
            font-size: 0.9em;
        }

        /* Ensure specific alignments for planner table body cells (adjusting indexes) */
        .route-plan-results .original-table > tbody td:nth-child(1), /* KM */
        .route-plan-results .original-table > tbody td:nth-child(4), /* Level */
        .route-plan-results .original-table > tbody td:nth-child(5), /* Offset */
            /* NEW: Corrected Rule Alignment */
        .route-plan-results .original-table > tbody td:nth-child(6), /* Corrected Rule */
            /* SHIFTED: Max Draft Alignment */
        .route-plan-results .original-table > tbody td:nth-child(7) /* Max Draft */
        {
            text-align: right;
        }

        /* Left aligned columns */
        .route-plan-results .original-table > tbody td:nth-child(2), /* Name */
        .route-plan-results .original-table > tbody td:nth-child(3), /* ETA */
            /* SHIFTED: Notes Alignment */
        .route-plan-results .original-table > tbody td:nth-child(8) /* Notes */
        {
            text-align: left;
        }

        /* Scroll wrapper for planner table */
        .route-plan-results .table-scroll-wrapper {
            /* INCREASED HEIGHT: Use vh for better responsiveness */
            max-height: 600px; /* Adjust as needed */
            overflow-y: auto;
            /* Add horizontal scroll too */
            overflow-x: auto;
        }


        /* --- Fixed Header Clone Container (Styles from FIRST block) --- */
        .fixed-header-container {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 100;
            overflow: hidden;
            visibility: hidden;
            background-color: #1e1e1e;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            /* width will be set by JS */
        }

        .fixed-header-container.visible {
            visibility: visible;
        }

        .fixed-header-container table {
            table-layout: fixed; /* <<< KEY */
            border-collapse: collapse;
            border-spacing: 0;
            background-color: transparent;
            width: 100%;
        }

        /* Cloned Header Cells - Mirror Original Styles (from FIRST block) */
        .fixed-header-container th {
            background-color: #1e1e1e;
            border-bottom: 1px solid #555;
            padding: 0.6rem 0.4rem; /* <<< CHANGED: Increased vertical padding */
            text-align: left;
            white-space: normal; /* <<< CHANGED: Allow text to wrap */
            overflow: visible;
            text-overflow: clip;
            border-left: 1px solid #333;
            vertical-align: middle;
            font-size: 0.8rem;
            font-weight: bold;
            line-height: 1.3; /* <<< CHANGED: Increased line height */
            border-top: none;
        }

        .fixed-header-container th:first-child {
            border-left: none;
        }

        .fixed-header-container th.numeric {
            text-align: right;
        }

        .fixed-header-container th.center {
            text-align: center;
        }

        .fixed-header-container thead tr:first-child th {
            border-top: 1px solid #555;
        }

        /* Add top border like original */

        /* Apply ORIGINAL table widths to fixed header (from FIRST block) */
        .fixed-header-container th:nth-child(1) {
            min-width: var(--col-1-width);
            width: var(--col-1-width);
            max-width: var(--col-1-width);
        }

        .fixed-header-container th:nth-child(2) {
            min-width: var(--col-2-width);
            width: var(--col-2-width);
            max-width: var(--col-2-width);
        }

        .fixed-header-container th:nth-child(3) {
            min-width: var(--col-3-width);
            width: var(--col-3-width);
            max-width: var(--col-3-width);
        }

        .fixed-header-container th:nth-child(4) {
            min-width: var(--col-4-width);
            width: var(--col-4-width);
        }

        .fixed-header-container th:nth-child(5) {
            min-width: var(--col-5-width);
            width: var(--col-5-width);
        }

        .fixed-header-container th:nth-child(6) {
            min-width: var(--col-6-width);
            width: var(--col-6-width);
        }

        .fixed-header-container th:nth-child(7) {
            min-width: var(--col-7-width);
            width: var(--col-7-width);
        }

        .fixed-header-container th:nth-child(8) {
            min-width: var(--col-8-width);
            width: var(--col-8-width);
            max-width: var(--col-8-width);
        }

        .fixed-header-container th:nth-child(9) {
            min-width: var(--col-9-width);
            width: var(--col-9-width);
            max-width: var(--col-9-width);
        }

        /* Uses original wider var */
        .fixed-header-container th:nth-child(10) {
            min-width: var(--col-10-width);
            width: var(--col-10-width);
            max-width: var(--col-10-width);
        }

        /* Uses original wider var */
        .fixed-header-container th:nth-child(11) {
            min-width: var(--col-11-width);
            width: var(--col-11-width);
            max-width: var(--col-11-width);
        }

        .fixed-header-container th:nth-child(12) {
            min-width: var(--col-12-width);
            width: var(--col-12-width);
            max-width: var(--col-12-width);
        }

        .fixed-header-container th:nth-child(13) {
            min-width: var(--col-13-width);
            width: var(--col-13-width);
            max-width: var(--col-13-width);
        }

        .fixed-header-container th.forecast-header {
            min-width: var(--forecast-width);
            width: var(--forecast-width);
        }


        /* --- Highlights & Cell Content Styling (Merged) --- */
        .critical-row td {
            background-color: rgba(255, 0, 0, 0.2) !important;
        }

        .critical-draft {
            font-weight: bold;
            color: #ff6666;
        }

        .critical-level {
            font-weight: bold;
            color: #ffb3b3;
        }

        .actual-draft-column {
            font-weight: bold;
        }

        .critical-actual-draft {
            font-weight: bold;
            color: #ff4d4d;
        }

        .critical-actual-level {
            font-weight: bold;
            color: #ff9999;
        }

        .forecast-cell div {
            line-height: 1.2;
        }

        .uncertainty-display {
            font-size: 0.75em;
            color: #aaa;
            margin-top: 2px;
            display: block;
        }

        .time-display {
            font-size: 0.75em;
            color: #aaa;
            font-weight: normal;
            margin-top: 3px;
            display: block;
            line-height: 1.1;
        }

        .time-display.weekly {
            font-style: italic;
            color: #ccc;
        }

        .time-display.current {
            font-style: italic;
            color: #8f8;
        }

        /* Style for 'Actueel' */
        .gauge-link {
            color: #4da6ff;
            text-decoration: none;
        }

        .gauge-link:hover {
            text-decoration: underline;
        }

        /* --- Footer & Misc (Merged) --- */
        footer {
            background-color: #1e1e1e;
            padding: 0.8rem 1rem;
            font-size: 0.8rem;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid #333;
            flex-shrink: 0;
            margin-top: auto;
        }

        .highlight-box {
            background-color: #cc9900;
            border-radius: 4px;
            padding: 0.5rem 1rem;
            color: black;
            font-weight: bold;
            border: 1px solid #997300;
        }

        .highlight-box div {
            margin-bottom: 3px;
            line-height: 1.3;
        }

        .highlight-box span.label {
            display: inline-block;
            min-width: 60px;
            padding-right: 5px;
            font-size: 0.9em;
        }

        .highlight-box span.value {
            display: inline-block;
            min-width: 55px;
            font-size: 0.9em;
        }

        .highlight-box span.gauge {
            font-size: 0.8em;
            color: #333;
            margin-left: 4px;
        }

        .highlight-box span.time {
            font-size: 0.75em;
            color: #555;
            margin-left: 4px;
        }

        .highlight-box .forecast-uncertainty {
            font-size: 0.8em;
            color: #333;
            font-weight: normal;
            display: inline-block;
            vertical-align: baseline;
            margin-left: 4px;
            margin-top: 0;
            margin-bottom: 0;
        }

        .data-status {
            padding: 0.4rem 0.8rem;
            background-color: #333;
            border-radius: 4px;
            font-size: 0.8rem;
            border-left: 4px solid #555;
            display: inline-block;
            margin-left: 0.5rem;
        }

        .data-status.pending {
            background-color: #444;
            border-left-color: #aaa;
        }

        .data-status.success {
            background-color: #004d00;
            border-left-color: #00cc66;
        }

        .data-status.warning {
            background-color: #665200;
            border-left-color: #ffcc00;
        }

        .data-status.error {
            background-color: #660000;
            border-left-color: #ff6666;
        }

        .refresh-btn {
            background-color: #0066cc;
            padding: 0.4rem 0.8rem;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .refresh-btn:hover {
            background-color: #0055aa;
        }

        .refresh-btn:disabled {
            background-color: #444;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
    const {useState, useEffect, useCallback, useRef, useMemo, createContext, useContext} = React;

    // --- I18N: START INTERNATIONALIZATION SETUP ---

    // 1. Translations Object
const translations = {
    nl: {
        appTitle: "Diepgang Calculator",
        autoRefresh: "Auto-verversing",
        nextRefresh: "Volgende",
        language: "Taal",
        contextRiver: "Context / Rivier",
        allRivers: "Alle Rivieren",
        journey: "Traject",
        selectStart: "Selecteer begin",
        selectEnd: "Selecteer einde",
        to: "tot",
        displayMode: "Weergave Modus",
        displayModeDraft: "Diepgang",
        displayModeLevel: "Waterstand (ruw)",
        showUncertainty: "Toon Prognose Onzekerheid",
        reloadData: "Data opnieuw laden",
        loading: "Laden...",
        apiTime: "API tijd",
        initializing: "Initialiseren...",
        loadingStatic: "Laden statische peiling definities...",
        staticLoaded: "Statische data geladen.",
        fetchingData: "Data ophalen van API...",
        dataUpdated: "Data bijgewerkt ({successfulUpdates}/{apiGaugeCount} API bronnen)",
        updateError: "Fout bij bijwerken ({errorCount} mislukt). Eerste: {firstError}",
        updateWarning: "Deels bijgewerkt ({warningCount} waarschuwingen). Eerste: {firstWarning}",
        loadError: "Fout bij laden: {errorMessage}",
        criticalDraftTitle: "Kritieke diepgang ({direction})",
        directionUp: "Op",
        directionDown: "Af",
        directionMixed: "op/af",
        now: "Nu",
        forecast: "Prognose",
        noCriticalForecast: "Geen kritieke prognose gevonden",
        noForecastsAvailable: "Geen prognose data beschikbaar",
        loadingForecasts: "Prognoses laden...",
        tabMaxDraft: "Max Diepgang (Traject)",
        tabPlanner: "Route Planner",
        tabAllData: "Alle Data",
        headerRiver: "Rivier",
        headerSection: "Strecke",
        headerName: "Naam",
        headerValue: "Waarde",
        headerTrend: "Tendens",
        headerOfficialRule: "Off. Vuist.",
        headerCorrection: "Correctie (cm)",
        headerUp: "Op",
        headerDown: "Af",
        headerAdjRule: "Aang. Vuist.",
        headerActualDraft: "Diepgang",
        headerActualLevel: "Waarde",
        headerUnitCm: "(cm)",
        headerUnitActual: "(Act., cm)",
        headerForecastValue: "({mode}, cm)",
        noForecasts: "Geen Prognoses",
        noDataForSelection: "Selecteer een geldig traject of geen data beschikbaar voor traject.",
        noApiData: "Geen API data geladen.",
        noDataForFilter: "Geen data gevonden voor de geselecteerde filter.",
        plannerSettingsTitle: "Route Planner Instellingen",
        departureTime: "Vertrek Datum/Tijd",
        speedDownstream: "Snelheid Stroomaf (km/u)",
        speedUpstream: "Snelheid Stroomop (km/u)",
        speedCanal: "Gem. Snelheid Main/RMD (km/u)",
        speedCanalHint: "(Van Mainz tot Kelheim)",
        system: "Systeem",
        systemA1: "A1 (14 uur/dag)",
        systemA2: "A2 (18 uur/dag)",
        systemB: "B (24 uur/dag)",
        systemCustom: "Custom",
        hoursPerDay: "uur/dag",
        excludedDays: "Uitgesloten Dagen",
        showUncertaintyPlanner: "Toon Prognose Onzekerheid",
        ifAvailable: "(Indien beschikbaar)",
        calculateMaxDraft: "Bereken Maximale Diepgang",
        calculating: "Berekenen...",
        plannerResultTitle: "Route Plan Resultaat",
        maxPossibleDraft: "Maximale Mogelijke Diepgang",
        limitedBy: "Beperkt door",
        mgdWarningText: "WAARSCHUWING: De berekende diepgang van {calculatedDraft} cm overschrijdt de MGD voor {mgdName} ({mgdDraft} cm). Varen met deze diepgang is op eigen risico.",
        canalLimitReason: "(boven)Main (max. 250 cm)",
        routeDetails: "Route Details",
        plannerHeaderKm: "KM",
        plannerHeaderName: "Naam",
        plannerHeaderEta: "ETA",
        plannerHeaderForecastLevel: "Prog. Niveau (cm)",
        plannerHeaderOffset: "Offset (cm)",
        plannerHeaderAdjRule: "Aang. Vuist. (cm)",
        plannerHeaderMaxDraft: "Max Diepgang (cm)",
        plannerHeaderNotes: "Notities",
        noRoutePoints: "Geen routepunten berekend (mogelijk geen prognoses beschikbaar voor ETA's).",
        notesNoDataForEta: "Geen data voor ETA",
        notesWeeklyForecast: "Weekpr.",
        notesCurrentLevel: "Actueel",
        footerApiDate: "Data API per",
        notLoadedYet: "Nog niet geladen",
        optionalSegment: "Optioneel Extra Trajectdeel",
        extraDistance: "Extra Afstand (km)",
        extraSpeed: "Snelheid Extra Deel (km/u)",
        extraPosition: "Positie Extra Deel",
        posAfter: "Na berekende route",
        posBefore: "Vóór berekende route",
        posHint: "(Voegt tijd toe aan begin/eind ETA)",
        errorInvalidDate: "Ongeldige startdatum/-tijd.",
        errorNoRoute: "Selecteer een begin- en eindpunt.",
        errorInvalidSpeed: "Snelheden moeten groter dan 0 zijn.",
        errorInvalidHours: "Ongeldige custom uren (1-24).",
        errorNoPath: "Geen route gevonden tussen {start} en {end}. Controleer of er een logische verbinding bestaat.",
        errorCustomSegmentSpeed: "Snelheid voor extra trajectdeel moet groter dan 0 zijn als afstand is ingevuld.",
        calculationError: "Fout bij berekenen: {error}",
    },
    en: {
        appTitle: "Draft Calculator",
        autoRefresh: "Auto-refresh",
        nextRefresh: "Next",
        language: "Language",
        contextRiver: "Context / River",
        allRivers: "All Rivers",
        journey: "Journey",
        selectStart: "Select start",
        selectEnd: "Select end",
        to: "to",
        displayMode: "Display Mode",
        displayModeDraft: "Draft",
        displayModeLevel: "Water Level (raw)",
        showUncertainty: "Show Forecast Uncertainty",
        reloadData: "Reload Data",
        loading: "Loading...",
        apiTime: "API time",
        initializing: "Initializing...",
        loadingStatic: "Loading static gauge definitions...",
        staticLoaded: "Static data loaded.",
        fetchingData: "Fetching data from API...",
        dataUpdated: "Data updated ({successfulUpdates}/{apiGaugeCount} API sources)",
        updateError: "Error updating ({errorCount} failed). First: {firstError}",
        updateWarning: "Partially updated ({warningCount} warnings). First: {firstWarning}",
        loadError: "Error loading: {errorMessage}",
        criticalDraftTitle: "Critical draft ({direction})",
        directionUp: "Upstream",
        directionDown: "Downstream",
        directionMixed: "up/down",
        now: "Now",
        forecast: "Forecast",
        noCriticalForecast: "No critical forecast found",
        noForecastsAvailable: "No forecast data available",
        loadingForecasts: "Loading forecasts...",
        tabMaxDraft: "Max Draft (Journey)",
        tabPlanner: "Route Planner",
        tabAllData: "All Data",
        headerRiver: "River",
        headerSection: "Section",
        headerName: "Name",
        headerValue: "Value",
        headerTrend: "Trend",
        headerOfficialRule: "Off. Rule",
        headerCorrection: "Correction (cm)",
        headerUp: "Up",
        headerDown: "Down",
        headerAdjRule: "Adj. Rule",
        headerActualDraft: "Draft",
        headerActualLevel: "Value",
        headerUnitCm: "(cm)",
        headerUnitActual: "(Act., cm)",
        headerForecastValue: "({mode}, cm)",
        noForecasts: "No Forecasts",
        noDataForSelection: "Select a valid journey or no data available for journey.",
        noApiData: "No API data loaded.",
        noDataForFilter: "No data found for the selected filter.",
        plannerSettingsTitle: "Route Planner Settings",
        departureTime: "Departure Date/Time",
        speedDownstream: "Speed Downstream (km/h)",
        speedUpstream: "Speed Upstream (km/h)",
        speedCanal: "Avg. Speed Main/RMD (km/h)",
        speedCanalHint: "(From Mainz to Kelheim)",
        system: "System",
        systemA1: "A1 (14 hours/day)",
        systemA2: "A2 (18 hours/day)",
        systemB: "B (24 hours/day)",
        systemCustom: "Custom",
        hoursPerDay: "hours/day",
        excludedDays: "Excluded Days",
        showUncertaintyPlanner: "Show Forecast Uncertainty",
        ifAvailable: "(If available)",
        calculateMaxDraft: "Calculate Maximum Draft",
        calculating: "Calculating...",
        plannerResultTitle: "Route Plan Result",
        maxPossibleDraft: "Maximum Possible Draft",
        limitedBy: "Limited by",
        mgdWarningText: "WARNING: The calculated draft of {calculatedDraft} cm exceeds the MGD for {mgdName} ({mgdDraft} cm). Sailing at this draft is at your own risk.",
        canalLimitReason: "(upper) Main (max 250 cm)",
        routeDetails: "Route Details",
        plannerHeaderKm: "KM",
        plannerHeaderName: "Name",
        plannerHeaderEta: "ETA",
        plannerHeaderForecastLevel: "Fcst. Level (cm)",
        plannerHeaderOffset: "Offset (cm)",
        plannerHeaderAdjRule: "Adj. Rule (cm)",
        plannerHeaderMaxDraft: "Max Draft (cm)",
        plannerHeaderNotes: "Notes",
        noRoutePoints: "No route points calculated (possibly no forecasts available for ETAs).",
        notesNoDataForEta: "No data for ETA",
        notesWeeklyForecast: "Weekly fcst.",
        notesCurrentLevel: "Current",
        footerApiDate: "Data API as of",
        notLoadedYet: "Not loaded yet",
        optionalSegment: "Optional Extra Segment",
        extraDistance: "Extra Distance (km)",
        extraSpeed: "Speed Extra Segment (km/h)",
        extraPosition: "Position Extra Segment",
        posAfter: "After calculated route",
        posBefore: "Before calculated route",
        posHint: "(Adds time to start/end ETA)",
        errorInvalidDate: "Invalid start date/time.",
        errorNoRoute: "Please select a start and end point.",
        errorInvalidSpeed: "Speeds must be greater than 0.",
        errorInvalidHours: "Invalid custom hours (1-24).",
        errorNoPath: "No route found between {start} and {end}. Check if a logical connection exists.",
        errorCustomSegmentSpeed: "Speed for extra segment must be greater than 0 if distance is entered.",
        calculationError: "Error calculating: {error}",
    },
    de: {
        appTitle: "Tiefgang-Rechner",
        autoRefresh: "Auto-Aktualisierung",
        nextRefresh: "Nächste",
        language: "Sprache",
        contextRiver: "Kontext / Fluss",
        allRivers: "Alle Flüsse",
        journey: "Strecke",
        selectStart: "Start wählen",
        selectEnd: "Ende wählen",
        to: "bis",
        displayMode: "Anzeigemodus",
        displayModeDraft: "Tiefgang",
        displayModeLevel: "Wasserstand (roh)",
        showUncertainty: "Prognose-Unsicherheit anzeigen",
        reloadData: "Daten neu laden",
        loading: "Laden...",
        apiTime: "API-Zeit",
        initializing: "Initialisiere...",
        loadingStatic: "Lade statische Pegeldefinitionen...",
        staticLoaded: "Statische Daten geladen.",
        fetchingData: "Daten von API abrufen...",
        dataUpdated: "Daten aktualisiert ({successfulUpdates}/{apiGaugeCount} API-Quellen)",
        updateError: "Fehler bei Aktualisierung ({errorCount} fehlgeschlagen). Erster: {firstError}",
        updateWarning: "Teilweise aktualisiert ({warningCount} Warnungen). Erster: {firstWarning}",
        loadError: "Fehler beim Laden: {errorMessage}",
        criticalDraftTitle: "Kritischer Tiefgang ({direction})",
        directionUp: "Bergfahrt",
        directionDown: "Talfahrt",
        directionMixed: "Berg/Tal",
        now: "Jetzt",
        forecast: "Prognose",
        noCriticalForecast: "Keine kritische Prognose gefunden",
        noForecastsAvailable: "Keine Prognosedaten verfügbar",
        loadingForecasts: "Lade Prognosen...",
        tabMaxDraft: "Max. Tiefgang (Strecke)",
        tabPlanner: "Routenplaner",
        tabAllData: "Alle Daten",
        headerRiver: "Fluss",
        headerSection: "Strecke",
        headerName: "Name",
        headerValue: "Wert",
        headerTrend: "Tendenz",
        headerOfficialRule: "Off. Faustr.",
        headerCorrection: "Korrektur (cm)",
        headerUp: "Berg",
        headerDown: "Tal",
        headerAdjRule: "Ang. Faustr.",
        headerActualDraft: "Tiefgang",
        headerActualLevel: "Wert",
        headerUnitCm: "(cm)",
        headerUnitActual: "(Akt., cm)",
        headerForecastValue: "({mode}, cm)",
        noForecasts: "Keine Prognosen",
        noDataForSelection: "Gültige Strecke wählen oder keine Daten für Strecke verfügbar.",
        noApiData: "Keine API-Daten geladen.",
        noDataForFilter: "Keine Daten für den gewählten Filter gefunden.",
        plannerSettingsTitle: "Routenplaner-Einstellungen",
        departureTime: "Abfahrtsdatum/-zeit",
        speedDownstream: "Geschwindigkeit Talfahrt (km/h)",
        speedUpstream: "Geschwindigkeit Bergfahrt (km/h)",
        speedCanal: "Ø Geschw. Main/RMD (km/h)",
        speedCanalHint: "(Von Mainz bis Kelheim)",
        system: "System",
        systemA1: "A1 (14 Std./Tag)",
        systemA2: "A2 (18 Std./Tag)",
        systemB: "B (24 Std./Tag)",
        systemCustom: "Benutzerdef.",
        hoursPerDay: "Std./Tag",
        excludedDays: "Ausgeschlossene Tage",
        showUncertaintyPlanner: "Prognose-Unsicherheit anzeigen",
        ifAvailable: "(Falls verfügbar)",
        calculateMaxDraft: "Maximalen Tiefgang berechnen",
        calculating: "Berechne...",
        plannerResultTitle: "Routenplan-Ergebnis",
        maxPossibleDraft: "Maximal möglicher Tiefgang",
        limitedBy: "Begrenzt durch",
        mgdWarningText: "WARNUNG: Der berechnete Tiefgang von {calculatedDraft} cm überschreitet die MGD für {mgdName} ({mgdDraft} cm). Fahrt auf eigene Gefahr.",
        canalLimitReason: "(ober)Main (max. 250 cm)",
        routeDetails: "Routendetails",
        plannerHeaderKm: "KM",
        plannerHeaderName: "Name",
        plannerHeaderEta: "Ank.-Zeit",
        plannerHeaderForecastLevel: "Prog. Stand (cm)",
        plannerHeaderOffset: "Offset (cm)",
        plannerHeaderAdjRule: "Ang. Faustr. (cm)",
        plannerHeaderMaxDraft: "Max. Tiefg. (cm)",
        plannerHeaderNotes: "Notizen",
        noRoutePoints: "Keine Routenpunkte berechnet (möglicherweise keine Prognosen für Ankunftszeiten verfügbar).",
        notesNoDataForEta: "Keine Daten für Ank.-Zeit",
        notesWeeklyForecast: "Wochenprog.",
        notesCurrentLevel: "Aktuell",
        footerApiDate: "Daten API vom",
        notLoadedYet: "Noch nicht geladen",
        optionalSegment: "Optionaler Zusatzabschnitt",
        extraDistance: "Zusätzliche Distanz (km)",
        extraSpeed: "Geschw. Zusatzabschnitt (km/h)",
        extraPosition: "Position Zusatzabschnitt",
        posAfter: "Nach berechneter Route",
        posBefore: "Vor berechneter Route",
        posHint: "(Fügt Zeit am Anfang/Ende hinzu)",
        errorInvalidDate: "Ungültiges Startdatum/-zeit.",
        errorNoRoute: "Bitte Start- und Endpunkt auswählen.",
        errorInvalidSpeed: "Geschwindigkeiten müssen größer als 0 sein.",
        errorInvalidHours: "Ungültige benutzerdef. Stunden (1-24).",
        errorNoPath: "Keine Route zwischen {start} und {end} gefunden. Prüfen Sie, ob eine logische Verbindung besteht.",
        errorCustomSegmentSpeed: "Geschwindigkeit für Zusatzabschnitt muss > 0 sein, wenn Distanz eingegeben wurde.",
        calculationError: "Fehler bei Berechnung: {error}",
    },
    fr: {
        appTitle: "Calculateur de Tirant d'eau",
        autoRefresh: "Actualisation auto",
        nextRefresh: "Prochain",
        language: "Langue",
        contextRiver: "Contexte / Rivière",
        allRivers: "Toutes les rivières",
        journey: "Trajet",
        selectStart: "Sélectionner le départ",
        selectEnd: "Sélectionner l'arrivée",
        to: "à",
        displayMode: "Mode d'affichage",
        displayModeDraft: "Tirant d'eau",
        displayModeLevel: "Niveau d'eau (brut)",
        showUncertainty: "Afficher l'incertitude des prévisions",
        reloadData: "Recharger les données",
        loading: "Chargement...",
        apiTime: "Heure API",
        initializing: "Initialisation...",
        loadingStatic: "Chargement des définitions statiques...",
        staticLoaded: "Données statiques chargées.",
        fetchingData: "Récupération des données de l'API...",
        dataUpdated: "Données mises à jour ({successfulUpdates}/{apiGaugeCount} sources API)",
        updateError: "Erreur de mise à jour ({errorCount} échecs). Premier: {firstError}",
        updateWarning: "Mise à jour partielle ({warningCount} avertissements). Premier: {firstWarning}",
        loadError: "Erreur de chargement : {errorMessage}",
        criticalDraftTitle: "Tirant d'eau critique ({direction})",
        directionUp: "Montant",
        directionDown: "Avalant",
        directionMixed: "mont/aval",
        now: "Maintenant",
        forecast: "Prévision",
        noCriticalForecast: "Aucune prévision critique trouvée",
        noForecastsAvailable: "Aucune donnée de prévision disponible",
        loadingForecasts: "Chargement des prévisions...",
        tabMaxDraft: "Tirant d'eau max (Trajet)",
        tabPlanner: "Planificateur d'itinéraire",
        tabAllData: "Toutes les données",
        headerRiver: "Rivière",
        headerSection: "Section",
        headerName: "Nom",
        headerValue: "Valeur",
        headerTrend: "Tendance",
        headerOfficialRule: "Règle off.",
        headerCorrection: "Correction (cm)",
        headerUp: "Montant",
        headerDown: "Avalant",
        headerAdjRule: "Règle ajus.",
        headerActualDraft: "Tirant d'eau",
        headerActualLevel: "Valeur",
        headerUnitCm: "(cm)",
        headerUnitActual: "(Act., cm)",
        headerForecastValue: "({mode}, cm)",
        noForecasts: "Aucune prévision",
        noDataForSelection: "Sélectionnez un trajet valide ou aucune donnée disponible pour le trajet.",
        noApiData: "Aucune donnée API chargée.",
        noDataForFilter: "Aucune donnée trouvée pour le filtre sélectionné.",
        plannerSettingsTitle: "Paramètres du planificateur d'itinéraire",
        departureTime: "Date/Heure de départ",
        speedDownstream: "Vitesse en aval (km/h)",
        speedUpstream: "Vitesse en amont (km/h)",
        speedCanal: "Vit. moy. Main/RMD (km/h)",
        speedCanalHint: "(De Mayence à Kelheim)",
        system: "Système",
        systemA1: "A1 (14 heures/jour)",
        systemA2: "A2 (18 heures/jour)",
        systemB: "B (24 heures/jour)",
        systemCustom: "Personnalisé",
        hoursPerDay: "heures/jour",
        excludedDays: "Jours exclus",
        showUncertaintyPlanner: "Afficher l'incertitude des prévisions",
        ifAvailable: "(Si disponible)",
        calculateMaxDraft: "Calculer le tirant d'eau maximum",
        calculating: "Calcul en cours...",
        plannerResultTitle: "Résultat du plan d'itinéraire",
        maxPossibleDraft: "Tirant d'eau maximum possible",
        limitedBy: "Limité par",
        mgdWarningText: "AVERTISSEMENT : Le tirant d'eau calculé de {calculatedDraft} cm dépasse le MGD pour {mgdName} ({mgdDraft} cm). La navigation avec ce tirant d'eau est à vos propres risques.",
        canalLimitReason: "(haute) Main (max. 250 cm)",
        routeDetails: "Détails de l'itinéraire",
        plannerHeaderKm: "KM",
        plannerHeaderName: "Nom",
        plannerHeaderEta: "HPA",
        plannerHeaderForecastLevel: "Niv. Prévu (cm)",
        plannerHeaderOffset: "Décalage (cm)",
        plannerHeaderAdjRule: "Règle ajus. (cm)",
        plannerHeaderMaxDraft: "Tirant d'eau max (cm)",
        plannerHeaderNotes: "Notes",
        noRoutePoints: "Aucun point d'itinéraire calculé (probablement aucune prévision disponible pour les HPA).",
        notesNoDataForEta: "Pas de données pour HPA",
        notesWeeklyForecast: "Prév. hebd.",
        notesCurrentLevel: "Actuel",
        footerApiDate: "Données API du",
        notLoadedYet: "Pas encore chargé",
        optionalSegment: "Segment supplémentaire optionnel",
        extraDistance: "Distance suppl. (km)",
        extraSpeed: "Vitesse seg. suppl. (km/h)",
        extraPosition: "Position seg. suppl.",
        posAfter: "Après l'itinéraire calculé",
        posBefore: "Avant l'itinéraire calculé",
        posHint: "(Ajoute du temps à l'HPA de départ/fin)",
        errorInvalidDate: "Date/heure de départ invalide.",
        errorNoRoute: "Veuillez sélectionner un point de départ et d'arrivée.",
        errorInvalidSpeed: "Les vitesses doivent être supérieures à 0.",
        errorInvalidHours: "Heures personnalisées invalides (1-24).",
        errorNoPath: "Aucun itinéraire trouvé entre {start} et {end}. Vérifiez qu'une connexion logique existe.",
        errorCustomSegmentSpeed: "La vitesse du segment supplémentaire doit être supérieure à 0 si la distance est saisie.",
        calculationError: "Erreur de calcul : {error}",
    },
    ru: {
        appTitle: "Калькулятор Осадки",
        autoRefresh: "Автообновление",
        nextRefresh: "Следующее",
        language: "Язык",
        contextRiver: "Контекст / Река",
        allRivers: "Все реки",
        journey: "Маршрут",
        selectStart: "Выбрать старт",
        selectEnd: "Выбрать финиш",
        to: "до",
        displayMode: "Режим отображения",
        displayModeDraft: "Осадка",
        displayModeLevel: "Уровень воды (сырой)",
        showUncertainty: "Показать неопределенность прогноза",
        reloadData: "Перезагрузить данные",
        loading: "Загрузка...",
        apiTime: "Время API",
        initializing: "Инициализация...",
        loadingStatic: "Загрузка статических определений...",
        staticLoaded: "Статические данные загружены.",
        fetchingData: "Получение данных из API...",
        dataUpdated: "Данные обновлены ({successfulUpdates}/{apiGaugeCount} источников API)",
        updateError: "Ошибка обновления ({errorCount} сбоев). Первая: {firstError}",
        updateWarning: "Частично обновлено ({warningCount} предупреждений). Первое: {firstWarning}",
        loadError: "Ошибка загрузки: {errorMessage}",
        criticalDraftTitle: "Критическая осадка ({direction})",
        directionUp: "Против течения",
        directionDown: "По течению",
        directionMixed: "вверх/вниз по течению",
        now: "Сейчас",
        forecast: "Прогноз",
        noCriticalForecast: "Критический прогноз не найден",
        noForecastsAvailable: "Данные прогноза недоступны",
        loadingForecasts: "Загрузка прогнозов...",
        tabMaxDraft: "Макс. Осадка (Маршрут)",
        tabPlanner: "Планировщик маршрута",
        tabAllData: "Все данные",
        headerRiver: "Река",
        headerSection: "Участок",
        headerName: "Название",
        headerValue: "Значение",
        headerTrend: "Тенденция",
        headerOfficialRule: "Офиц. правило",
        headerCorrection: "Коррекция (см)",
        headerUp: "Против теч.",
        headerDown: "По теч.",
        headerAdjRule: "Скорр. правило",
        headerActualDraft: "Осадка",
        headerActualLevel: "Значение",
        headerUnitCm: "(см)",
        headerUnitActual: "(Акт., см)",
        headerForecastValue: "({mode}, см)",
        noForecasts: "Нет прогнозов",
        noDataForSelection: "Выберите действительный маршрут или данные для маршрута недоступны.",
        noApiData: "Данные API не загружены.",
        noDataForFilter: "Данные для выбранного фильтра не найдены.",
        plannerSettingsTitle: "Настройки планировщика маршрута",
        departureTime: "Дата/Время отправления",
        speedDownstream: "Скорость по течению (км/ч)",
        speedUpstream: "Скорость против течения (км/ч)",
        speedCanal: "Сред. скорость Майн/РМД (км/ч)",
        speedCanalHint: "(От Майнца до Кельхайма)",
        system: "Система",
        systemA1: "A1 (14 часов/день)",
        systemA2: "A2 (18 часов/день)",
        systemB: "B (24 часа/день)",
        systemCustom: "Пользов.",
        hoursPerDay: "часов/день",
        excludedDays: "Исключенные дни",
        showUncertaintyPlanner: "Показать неопределенность прогноза",
        ifAvailable: "(Если доступно)",
        calculateMaxDraft: "Рассчитать максимальную осадку",
        calculating: "Расчет...",
        plannerResultTitle: "Результат плана маршрута",
        maxPossibleDraft: "Максимально возможная осадка",
        limitedBy: "Ограничено",
        mgdWarningText: "ВНИМАНИЕ: Расчетная осадка {calculatedDraft} см превышает MGD для {mgdName} ({mgdDraft} см). Движение с такой осадкой на ваш страх и риск.",
        canalLimitReason: "(верх.) Майн (макс. 250 см)",
        routeDetails: "Детали маршрута",
        plannerHeaderKm: "КМ",
        plannerHeaderName: "Название",
        plannerHeaderEta: "ПВП",
        plannerHeaderForecastLevel: "Прогн. Уровень (см)",
        plannerHeaderOffset: "Смещение (см)",
        plannerHeaderAdjRule: "Скорр. правило (см)",
        plannerHeaderMaxDraft: "Макс. Осадка (см)",
        plannerHeaderNotes: "Примечания",
        noRoutePoints: "Точки маршрута не рассчитаны (возможно, нет прогнозов для ПВП).",
        notesNoDataForEta: "Нет данных для ПВП",
        notesWeeklyForecast: "Нед. прогн.",
        notesCurrentLevel: "Текущий",
        footerApiDate: "Данные API от",
        notLoadedYet: "Еще не загружено",
        optionalSegment: "Дополнительный участок (опционально)",
        extraDistance: "Доп. расстояние (км)",
        extraSpeed: "Скорость на доп. участке (км/ч)",
        extraPosition: "Положение доп. участка",
        posAfter: "После расчетного маршрута",
        posBefore: "До расчетного маршрута",
        posHint: "(Добавляет время к начальному/конечному ПВП)",
        errorInvalidDate: "Неверная дата/время отправления.",
        errorNoRoute: "Пожалуйста, выберите начальную и конечную точки.",
        errorInvalidSpeed: "Скорости должны быть больше 0.",
        errorInvalidHours: "Неверные пользовательские часы (1-24).",
        errorNoPath: "Маршрут между {start} и {end} не найден. Проверьте наличие логического соединения.",
        errorCustomSegmentSpeed: "Скорость дополнительного участка должна быть больше 0, если введено расстояние.",
        calculationError: "Ошибка расчета: {error}",
    }
};

    // 2. Locale mapping for date/time formatting
    const localeMap = {
        nl: 'nl-NL',
        en: 'en-GB',
        de: 'de-DE',
        fr: 'fr-FR',
        ru: 'ru-RU'
    };
    
    // 3. Create React Context for i18n
    const I18nContext = createContext();

    // 4. Create a Provider component
    function I18nProvider({ children }) {
        const [language, setLanguageState] = useState(() => getCookie('appLanguage') || 'nl');

        const setLanguage = (lang) => {
            setCookie('appLanguage', lang, 365);
            setLanguageState(lang);
            document.documentElement.lang = lang; // Set html lang attribute
        };
        
        useEffect(() => {
            document.documentElement.lang = language;
        }, [language]);

        const t = useCallback((key, replacements = {}) => {
            // Fallback chain: Current Lang -> English -> Key
            let text = translations[language]?.[key] || translations.en?.[key] || key;
            
            for (const placeholder in replacements) {
                text = text.replace(`{${placeholder}}`, replacements[placeholder]);
            }
            
            return text;
        }, [language]);

        const value = {
            language,
            setLanguage,
            t,
            locale: localeMap[language] || 'en-GB', // The full locale string for date formatting
            weekdays: WEEKDAYS // Pass weekdays constant through context if it needs translation later
        };

        return (
            <I18nContext.Provider value={value}>
                {children}
            </I18nContext.Provider>
        );
    }

    // --- I18N: END INTERNATIONALIZATION SETUP ---


    // --- Constants ---
    const API_URL = 'https://rdd-backend.vercel.app/api/data';
    const REFRESH_INTERVAL_MS = 10 * 60 * 1000;
    const DEFAULT_DEPTH_SAFETY_MARGIN = 0;
    const MAX_FORECAST_DAYS = 8;
    const MAIN_ROUTE_RIVERS = ['Rijn', 'Waal'];
    const MGD_TRIGGER_GAUGES = ['Tiel', 'Nijmegen', 'Lobith'];
    //Millingen = spijk, Loevestijn = Woudrichem
    const MGD_TARGET_GAUGE_NAMES = ['Spijk - Woudrichem', 'Millingen tot Maas-Waalkanaal', "Maas-Waalkan tot A'dam-Rijnkanaal", "Maas-Waalkanaal tot A'dam-Rijnkanaal", "Maas-Waalkanaal tot Amsterdam-Rijnkanaal", "A'dam-Rijnkanaal tot Loevestein", "Amsterdam-Rijnkanaal tot Loevestein", "Spijk - Maas-WaalKanaal", "Maas-Waalkanaal - A'dam-Rijnkanaal", "Maas-Waalkanaal - Amsterdam-Rijnkanaal", "A'dam-Rijnkanaal - Woudrichem", , "A'dam-Rijnkanaal - Woudrichem"];
    const MGD_TARGET_GAUGE_KMS = ["857.7 - 952.5", "857.7 - 887.0", "887.0 - 913.3", "913.3 - 952.5"]
    // I18N: Weekdays can be translated if needed, but short codes are often universal.
    // For full day names, this would be moved into the translations object.
    const WEEKDAYS = ['Zo', 'Ma', 'Di', 'Wo', 'Do', 'Vr', 'Za'];

    // --- Cookie Utilities (Unchanged) ---
    function setCookie(name, value, days = 3650) {
        const date = new Date();
        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
        const expires = `expires=${date.toUTCString()}`;
        document.cookie = `${name}=${JSON.stringify(value)};${expires};path=/;SameSite=Lax`;
    }

    function getCookie(name) {
        const nameEQ = `${name}=`;
        const ca = document.cookie.split(';');
        for (let i = 0; i < ca.length; i++) {
            let c = ca[i];
            while (c.charAt(0) === ' ') c = c.substring(1, c.length);
            if (c.indexOf(nameEQ) === 0) {
                try {
                    return JSON.parse(c.substring(nameEQ.length, c.length));
                } catch (e) {
                    console.error("Error parsing cookie:", name, e);
                    return null;
                }
            }
        }
        return null;
    }

    // --- API Fetch Function (Unchanged) ---
    async function fetchConsolidatedData(force = false) { /* ... */
        const url = `${API_URL}?t=${Date.now()}`;
        console.log(`Fetching data from: ${url}`);
        try {
            const response = await fetch(url);
            if (!response.ok) {
                let errorText = `API request failed: ${response.status}`;
                try {
                    const errorBody = await response.json();
                    errorText += ` - ${errorBody.error || JSON.stringify(errorBody)}`;
                } catch (parseError) {
                    try {
                        const textBody = await response.text();
                        errorText += ` - ${textBody.substring(0, 200)}`;
                    } catch (readError) {
                    }
                }
                throw new Error(errorText);
            }
            const data = await response.json();
            console.log("API Data Received:", Object.keys(data).length, "gauges");
            return data;
        } catch (error) {
            console.error("Error fetching consolidated data:", error);
            throw error;
        }
    }

    // --- Helper Functions ---
    // I18N: Updated to accept a locale
    function formatTimeDisplay(timeString, locale = 'nl-NL') {
        if (!timeString || typeof timeString !== 'string') return "N/A";
        if (timeString.length === 5 && timeString.includes(':')) return timeString;
        if (timeString.includes(' ') && timeString.includes(':')) {
            const timePart = timeString.split(' ')[1];
            if (timePart && timePart.length >= 5) return timePart.substring(0, 5);
        }
        try {
            const date = new Date(timeString);
            if (!isNaN(date.getTime())) return date.toLocaleTimeString(locale, {hour: '2-digit', minute: '2-digit'});
        } catch (e) {
        }
        return timeString || "N/A";
    }

    function getGaugeUrl(gauge) { /* ... Unchanged ... */
        if (!gauge) return '#';
        const gaugeName = gauge.name;
        const gaugeRiver = gauge.river;
        const gaugeRegion = gauge.region || gauge.apiData?.region;
        if (gaugeRiver === 'MGD' || (gaugeRegion && gaugeRegion.includes('depths'))) return `https://www.vaarweginformatie.nl/frp/main/#/hydro/mgd`;
        const dutchGaugeUrlCodes = {
            'Nijmegen': 'Nijmegen-haven(NIJM)',
            'Tiel': 'Tiel-Waal(TIEW)',
            'Pannerdense kop': 'Pannerdense-kop(PANN)',
            'IJsselkop': 'IJsselkop(IJSS)',
            'Doesburg': 'Doesburg-brug(DOES)',
            'Deventer': 'Deventer(DEVE)',
            'Katerveer': 'Katerveer(KATV)'
        };
        const germanGaugeIds = {
            'Konstanz': '00007',
            'Iffezheim': '09137',
            'Maxau': '09016',
            'Speyer': '09017',
            'Mannheim': '09001',
            'Worms': '09018'
        };
        const rlpGaugeUrls = {
            'Mainz': 'https://www.hochwasser.rlp.de/flussgebiet/mittelrhein/mainz',
            'Bingen': 'https://www.hochwasser.rlp.de/flussgebiet/mittelrhein/bingen',
            'Andernach': 'https://www.hochwasser.rlp.de/flussgebiet/mittelrhein/andernach',
            'Bonn': 'https://www.hochwasser.rlp.de/flussgebiet/mittelrhein/bonn',
            'Wesel': 'https://www.hochwasser.rlp.de/flussgebiet/niederrhein/wesel'
        };
        if (rlpGaugeUrls[gaugeName]) return rlpGaugeUrls[gaugeName];
        if (gaugeName === 'Lobith') return 'https://www.rijkswaterstaat.nl/water/waterdata-en-waterberichtgeving/waterdata/lobith-waterstanden-en-afvoeren';
        if (germanGaugeIds[gaugeName]) return `https://www.hvz.baden-wuerttemberg.de/pegel.html?id=${germanGaugeIds[gaugeName]}`;
        if (dutchGaugeUrlCodes[gaugeName] || (gaugeRegion && gaugeRegion.includes('dutch'))) {
            const urlCode = dutchGaugeUrlCodes[gaugeName] || encodeURIComponent(gaugeName);
            return `https://waterinfo.rws.nl/publiek/waterhoogte/${urlCode}/details`;
        }
        const elwisNameBase = gauge.apiDataName || gauge.name || '';
        //const elwisName = elwisNameBase.toUpperCase().replace(/ /g, '_');
        const elwisName = elwisNameBase.toUpperCase();
        if (elwisName) return `https://www.elwis.de/DE/dynamisch/Wasserstaende/Pegelvorhersage:${elwisName}`;
        return '#';
    }

    function diffDays(dateStr1, dateStr2) { /* ... Unchanged ... */
        try {
            const date1 = new Date(Date.UTC(parseInt(dateStr1.substring(0, 4)), parseInt(dateStr1.substring(5, 7)) - 1, parseInt(dateStr1.substring(8, 10)), 12, 0, 0));
            const date2 = new Date(Date.UTC(parseInt(dateStr2.substring(0, 4)), parseInt(dateStr2.substring(5, 7)) - 1, parseInt(dateStr2.substring(8, 10)), 12, 0, 0));
            if (isNaN(date1.getTime()) || isNaN(date2.getTime())) return NaN;
            return Math.round((date2 - date1) / (1000 * 60 * 60 * 24));
        } catch (e) {
            console.error("Error calculating date difference:", dateStr1, dateStr2, e);
            return NaN;
        }
    }

    // --- Date/Time Helper for Operational Time (Unchanged) ---
    function addOperationalTime(startDate, durationHours, operationalHoursPerDay, excludedDaysOfWeek) { /* ... Unchanged ... */
        if (operationalHoursPerDay <= 0 || durationHours <= 0) return startDate;

        let currentTime = new Date(startDate.getTime());
        let remainingDurationHours = durationHours;

        const getOperationalWindow = (date, mode) => {
            let startHour, endHour;
            const dayOfWeek = date.getDay();

            if (excludedDaysOfWeek.includes(dayOfWeek)) {
                return { start: null, end: null }; // Not an operational day
            }

            switch (mode) {
                case 'A1':
                    startHour = 6;
                    // Special rule: if the journey *starts* after 20:00, the window extends to 22:00
                    // We check this by comparing the initial startDate, not the iterating currentTime
                    const startOfDayForStartDate = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
                    const startOfDayForCurrentDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());

                    if (startOfDayForStartDate.getTime() === startOfDayForCurrentDate.getTime() && startDate.getHours() >= 20) {
                         endHour = 22;
                    } else {
                         endHour = 20;
                    }
                    break;
                case 'A2':
                    startHour = 5;
                    endHour = 23;
                    break;
                case 'B':
                default: // Default to 24-hour operation
                    startHour = 0;
                    endHour = 24;
                    break;
            }
            const startTime = new Date(date.getFullYear(), date.getMonth(), date.getDate(), startHour, 0, 0);
            const endTime = new Date(date.getFullYear(), date.getMonth(), date.getDate(), endHour, 0, 0);
            return { start: startTime, end: endTime };
        };

        // Determine operational mode from the hours per day
        let mode = 'B'; // Default
        if (operationalHoursPerDay === 14) mode = 'A1';
        if (operationalHoursPerDay === 18) mode = 'A2';
        // Note: 'Custom' mode will fall through to default B (24h) as it's not explicitly defined with start/end times.
        // This could be enhanced later if needed.

        while (remainingDurationHours > 1e-6) { // Use a small epsilon for float comparison
            let { start: opStart, end: opEnd } = getOperationalWindow(currentTime, mode);

            // If we are on a non-operational day, jump to the start of the next day
            if (!opStart) {
                currentTime.setDate(currentTime.getDate() + 1);
                currentTime.setHours(0, 0, 0, 0);
                continue;
            }

            // If current time is before the window starts, jump to the start of the window
            if (currentTime < opStart) {
                currentTime = new Date(opStart.getTime());
            }

            // If current time is after the window ends, jump to the start of the next day's window
            if (currentTime >= opEnd) {
                currentTime.setDate(currentTime.getDate() + 1);
                let { start: nextOpStart } = getOperationalWindow(currentTime, mode);
                while(!nextOpStart) { // Keep skipping non-operational days
                    currentTime.setDate(currentTime.getDate() + 1);
                    // *** THIS IS THE CORRECTED LINE ***
                    nextOpStart = getOperationalWindow(currentTime, mode).start;
                }
                currentTime = new Date(nextOpStart.getTime());
                continue;
            }

            // Calculate available time in the current window
            const availableMs = opEnd.getTime() - currentTime.getTime();
            const availableHours = availableMs / (1000 * 60 * 60);

            const timeToConsume = Math.min(remainingDurationHours, availableHours);

            currentTime.setTime(currentTime.getTime() + timeToConsume * 1000 * 60 * 60);
            remainingDurationHours -= timeToConsume;
        }

        return currentTime;
    }

    // --- Get Forecast for specific Date/Time (Unchanged) ---
    function getForecastForDateTime(apiData, targetDateTime) { /* ... Unchanged ... */
        if (!apiData || !targetDateTime || isNaN(targetDateTime.getTime())) return null;
        const targetYear = targetDateTime.getFullYear();
        const targetMonth = String(targetDateTime.getMonth() + 1).padStart(2, '0');
        const targetDay = String(targetDateTime.getDate()).padStart(2, '0');
        const targetDateStr = `${targetYear}-${targetMonth}-${targetDay}`;
        const targetHour = targetDateTime.getHours();
        const targetMinute = targetDateTime.getMinutes();
        const targetTotalMins = targetHour * 60 + targetMinute;
        const forecastsForDate = apiData.forecasts?.[targetDateStr];
        if (forecastsForDate && Object.keys(forecastsForDate).length > 0) {
            const availableTimes = Object.keys(forecastsForDate).filter(t => t.match(/^\d{2}:\d{2}$/));
            if (availableTimes.length > 0) {
                let bestMatchTime = null;
                let minDiff = Infinity;
                for (const time of availableTimes) {
                    const [h, m] = time.split(':').map(Number);
                    const totalMins = h * 60 + m;
                    const diff = Math.abs(totalMins - targetTotalMins);
                    if (diff < minDiff) {
                        minDiff = diff;
                        bestMatchTime = time;
                    }
                }
                if (bestMatchTime) {
                    const forecastSlot = forecastsForDate[bestMatchTime];
                    if (forecastSlot && forecastSlot.value !== undefined && forecastSlot.value !== null) {
                        let uncertainty = null;
                        if (forecastSlot.low_80 !== null && forecastSlot.high_80 !== null) {
                            uncertainty = {low: forecastSlot.low_80, high: forecastSlot.high_80};
                        }
                        return {
                            value: forecastSlot.value,
                            time: bestMatchTime,
                            source: 'daily',
                            uncertainty: uncertainty
                        };
                    }
                }
            }
        }
        if (Array.isArray(apiData.weeklyForecasts) && apiData.weeklyForecasts.length > 0) {
            const targetDateUtc = new Date(Date.UTC(targetYear, targetMonth - 1, targetDay, 12, 0, 0));
            for (const weeklyForecast of apiData.weeklyForecasts) {
                if (weeklyForecast.weekRange && weeklyForecast.median !== null) {
                    try {
                        const [startStr, endStr] = weeklyForecast.weekRange.split('-');
                        const [startDay, startMonth, startYear] = startStr.split('.');
                        const [endDay, endMonth, endYear] = endStr.split('.');
                        const startDate = new Date(Date.UTC(startYear, startMonth - 1, startDay, 0, 0, 0));
                        const endDate = new Date(Date.UTC(endYear, endMonth - 1, endDay, 23, 59, 59));
                        if (!isNaN(startDate.getTime()) && !isNaN(endDate.getTime()) && targetDateUtc >= startDate && targetDateUtc <= endDate) {
                            let uncertainty = null;
                            if (weeklyForecast.low_90 !== null && weeklyForecast.high_90 !== null) {
                                uncertainty = {low: weeklyForecast.low_90, high: weeklyForecast.high_90};
                            }
                            return {
                                value: weeklyForecast.median,
                                time: "(BfG6W)",
                                source: 'weekly',
                                uncertainty: uncertainty,
                                weeklySlot: weeklyForecast
                            };
                        }
                    } catch (e) {
                        console.warn(`Error parsing weekRange "${weeklyForecast.weekRange}" in getForecastForDateTime for gauge ${apiData.apiName}:`, e);
                    }
                }
            }
        }
        return null;
    }

    // --- NEW: Calculate Forecast Uncertainty based on river and publication time (Unchanged) ---
    function calculateForecastUncertainty(gauge, forecastDateStr, now) { /* ... Unchanged ... */
        if (!gauge || !gauge.river || !forecastDateStr || !now) {
            return null;
        }

        let publishHour;
        let thresholdHours;

        // 1. Determine rules based on the river
        switch (gauge.river) {
            case 'Rijn':
            case 'Waal':
            case 'Pannerdens Kanaal':
            case 'IJssel':
                publishHour = 7;
                thresholdHours = 48;
                break;
            case 'Donau':
                publishHour = 5;
                thresholdHours = 24;
                break;
            default:
                return null; // No uncertainty rules for this river
        }

        // 2. Determine the most recent forecast publication time
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate(), publishHour, 0, 0);
        let mostRecentPublishTime = today;

        if (now < today) {
            // If it's before today's publication time, the latest forecast is from yesterday
            mostRecentPublishTime.setDate(mostRecentPublishTime.getDate() - 1);
        }

        // 3. Calculate the difference in hours from publication to the forecast date
        const forecastDate = new Date(forecastDateStr + 'T12:00:00Z'); // Use noon for a stable comparison point
        const diffMs = forecastDate.getTime() - mostRecentPublishTime.getTime();
        const diffHours = diffMs / (1000 * 60 * 60);

        if (diffHours < 0) {
            return null; // Forecast is for a date before the last publication, unlikely but safe to handle
        }

        // 4. Apply the threshold
        if (diffHours <= thresholdHours) {
            return 10; // ±10 cm
        } else {
            return 20; // ±20 cm
        }
    }
    // --- NEW: Standalone Pathfinding Helper Function (Unchanged) ---
    const findRoutePath = (startGaugeName, endGaugeName, allGauges, speeds) => { /* ... Unchanged ... */
        if (!startGaugeName || !endGaugeName) return null;

        const gaugeMap = new Map(allGauges.map(g => [g.name, g]));
        const graph = new Map();

        // Build graph with weighted edges (travel time in hours)
        allGauges.forEach(gauge => {
            if (!graph.has(gauge.name)) graph.set(gauge.name, []);

            const neighbors = new Map(); // Use map to avoid duplicate neighbors

            // Add explicit connections (junctions, canals)
            if (gauge.connections) {
                gauge.connections.forEach(conn => {
                    const targetGauge = gaugeMap.get(conn.targetGaugeName);
                    if (targetGauge) {
                        const distance = conn.distance || Math.abs(gauge.km - targetGauge.km);
                        const speed = conn.speed || speeds.downstream; // Default speed for simple connections
                        const travelTime = distance / speed;
                        neighbors.set(targetGauge.name, {
                            node: targetGauge.name,
                            weight: travelTime,
                            targetGauge: targetGauge
                        });
                    }
                });
            }

            // Add implicit connections to adjacent gauges on the same river
            const sameRiverGauges = allGauges.filter(g => g.river === gauge.river && g.name !== gauge.name);
            if (sameRiverGauges.length > 0) {
                let nextUpstream = null, nextDownstream = null;

                // Determine next gauge based on KM value, handling Danube's inverted system
                if (gauge.river === 'Donau') {
                    nextUpstream = sameRiverGauges.filter(g => g.km > gauge.km).sort((a,b) => a.km - b.km)[0];
                    nextDownstream = sameRiverGauges.filter(g => g.km < gauge.km).sort((a,b) => b.km - a.km)[0];
                } else {
                    nextUpstream = sameRiverGauges.filter(g => g.km < gauge.km).sort((a,b) => b.km - a.km)[0];
                    nextDownstream = sameRiverGauges.filter(g => g.km > gauge.km).sort((a,b) => a.km - b.km)[0];
                }

                [nextUpstream, nextDownstream].forEach(neighbor => {
                    if (neighbor && !neighbors.has(neighbor.name)) {
                        const distance = Math.abs(gauge.km - neighbor.km);
                        const isDownstream = (gauge.river === 'Donau') ? neighbor.km < gauge.km : neighbor.km > gauge.km;
                        const speed = isDownstream ? speeds.downstream : speeds.upstream;
                        if (speed > 0) {
                            neighbors.set(neighbor.name, {
                                node: neighbor.name,
                                weight: distance / speed,
                                targetGauge: neighbor
                            });
                        }
                    }
                });
            }
            graph.set(gauge.name, Array.from(neighbors.values()));
        });

        // Dijkstra's algorithm
        const distances = new Map();
        const prev = new Map();
        const pq = new Set();

        allGauges.forEach(g => {
            distances.set(g.name, Infinity);
            prev.set(g.name, null);
            pq.add(g.name);
        });

        distances.set(startGaugeName, 0);

        while (pq.size > 0) {
            let u = null;
            pq.forEach(gaugeName => {
                if (u === null || distances.get(gaugeName) < distances.get(u)) {
                    u = gaugeName;
                }
            });

            if (u === endGaugeName) break;
            if (u === null) break;

            pq.delete(u);

            const uNeighbors = graph.get(u) || [];
            uNeighbors.forEach(neighbor => {
                const alt = distances.get(u) + neighbor.weight;
                if (alt < distances.get(neighbor.node)) {
                    distances.set(neighbor.node, alt);
                    prev.set(neighbor.node, u);
                }
            });
        }

        // Reconstruct path
        const path = [];
        let current = endGaugeName;
        if (prev.get(current) || current === startGaugeName) {
            while (current) {
                path.unshift(gaugeMap.get(current));
                current = prev.get(current);
            }
        }

        return (path.length > 0 && path[0].name === startGaugeName) ? path : null;
    };


// --- React Component ---
function RhineDraftCalculator() {
        // I18N: Use the i18n context
        const { language, setLanguage, t, locale, weekdays } = useContext(I18nContext);

        // I18N: Set document title dynamically
        useEffect(() => {
            document.title = t('appTitle');
        }, [t]);

        // --- State ---
        const [allGaugeStaticData, setAllGaugeStaticData] = useState([]);
        const [gaugeApiData, setGaugeApiData] = useState({});
        const [customCorrections, setCustomCorrections] = useState(() => getCookie('rhineDraftCorrections') || {
            upstream: {},
            downstream: {}
        });
        const [forecastDates, setForecastDates] = useState([]);
        const [dataStatus, setDataStatus] = useState({status: 'pending', message: t('initializing')});
        const [lastUpdated, setLastUpdated] = useState(null);
        const [travelDirection, setTravelDirection] = useState('downstream');
        const [autoRefresh, setAutoRefresh] = useState(true);
        const [nextRefreshTime, setNextRefreshTime] = useState(null);
        const refreshButtonRef = useRef(null);
        const [journey, setJourney] = useState(() => getCookie('riverJourneys') || {
            'Rijn/Waal': {start: 'Tiel', end: 'Emmerich'},
            'Donau': {start: 'Kelheim', end: 'Passau Donau'},
            'IJssel': {start: 'Katerveer', end: 'IJsselkop'},
            'all': { start: null, end: null }
        });
        const [activeTab, setActiveTab] = useState('planner');
        const [displayMode, setDisplayMode] = useState('draft');
        const [showUncertainty, setShowUncertainty] = useState(() => getCookie('rhineShowUncertainty') ?? false);
        const defaultStartDate = useMemo(() => {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }, []);


        const [routePlanResult, setRoutePlanResult] = useState(null);
        const [routePlanStatus, setRoutePlanStatus] = useState('idle');
        const [selectedRiver, setSelectedRiver] = useState(() => getCookie('selectedRiverContext') || 'all');
const [plannerSettings, setPlannerSettings] = useState(() => {
            const savedSettings = getCookie('rhinePlannerSettings');
            return {
                startDate: savedSettings?.startDate || defaultStartDate,
                speedDownstream: savedSettings?.speedDownstream || 20,
                speedUpstream: savedSettings?.speedUpstream || 9,
                speedCanal: savedSettings?.speedCanal || 7.1,
                operationalMode: savedSettings?.operationalMode || 'A1',
                customOperationalHours: savedSettings?.customOperationalHours || 14,
                excludedDays: savedSettings?.excludedDays || [0, 6],
                customSegmentKm: savedSettings?.customSegmentKm || 0,
                customSegmentSpeed: savedSettings?.customSegmentSpeed || 0,
                customSegmentPosition: savedSettings?.customSegmentPosition || 'end',
            };
        });

        // --- Refs for Fixed Header ---
        const sentinelRef = useRef(null);
        const scrollWrapperRef = useRef(null);
        const originalTableRef = useRef(null);
        const originalTheadRef = useRef(null);
        const fixedHeaderContainerRef = useRef(null);
        const fixedHeaderTableRef = useRef(null);
        const isHeaderFixedRef = useRef(false);

        const [gaugesOnRoute, setGaugesOnRoute] = useState([]);

        // --- Effects ---
        useEffect(() => {
            // Only calculate the path if we have a valid journey selected
            if (!journey[selectedRiver]?.start || !journey[selectedRiver]?.end) {
                setGaugesOnRoute([]);
                return;
            }
            // Speeds are just for pathfinding weight, don't need to match planner settings exactly
            const path = findRoutePath(
                journey[selectedRiver].start,
                journey[selectedRiver].end,
                allGaugeStaticData,
                { downstream: 20, upstream: 9 }
            );
            setGaugesOnRoute(path || []);
        }, [journey, selectedRiver, allGaugeStaticData]);

        useEffect(() => {
            setDataStatus({status: 'pending', message: t('loadingStatic')});
            const CANAL_AVG_SPEED = 7.1;
            const CANAL_DISTANCE = 555;
            const combinedStaticList = [
                // --- Donau (Danube) Gauges ---
                {
                    name: 'Ingolstadt',
                    apiDataName: 'Ingolstadt Luitpoldstrasse',
                    km: 2458,
                    river: 'Donau',
                    streckenAbschnitt: '2458-XXXX',
                    giw: 'N/A',
                    depthAtGiw: 'N/A',
                    officialSafetyMargin: 'N/A',
                    correctionOp: 0,
                    correctionAf: 0
                },
                {
                    name: 'Kelheim',
                    apiDataName: 'Kelheim Donau',
                    km: 2410,
                    river: 'Donau',
                    streckenAbschnitt: '2415-2399',
                    giw: 250,
                    depthAtGiw: 290,
                    officialSafetyMargin: 30,
                    correctionOp: 0,
                    correctionAf: 0,
                    connections: [
                        {
                            targetGaugeName: 'Mainz',
                            distance: CANAL_DISTANCE,
                            speed: CANAL_AVG_SPEED,
                            isCanal: true
                        }
                    ]
                },
                { name: 'Oberndorf', km: 2397, river: 'Donau', streckenAbschnitt: '2397-2380', giw: 170, depthAtGiw: 290, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Schwabelweis', km: 2377, river: 'Donau', streckenAbschnitt: '2380-2355', giw: 292, depthAtGiw: 290, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Pfatter', km: 2351, river: 'Donau', streckenAbschnitt: '2354-2330', giw: 310, depthAtGiw: 290, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Pfelling', km: 2306, river: 'Donau', streckenAbschnitt: '2322-2290', giw: 290, depthAtGiw: 200, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Deggendorf', km: 2284, river: 'Donau', streckenAbschnitt: '2290-2282', giw: 210, depthAtGiw: 200, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Hofkirchen', km: 2257, river: 'Donau', streckenAbschnitt: '2282-2231', giw: 207, depthAtGiw: 200, officialSafetyMargin: 30, correctionOp: -8, correctionAf: -3 },
                { name: 'Passau Donau', km: 2227, river: 'Donau', streckenAbschnitt: '2231-2204', giw: 415, depthAtGiw: 270, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                // --- Rhine and other gauges ---
                { name: 'Konstanz', km: 0, river: 'Rijn', streckenAbschnitt: '0-1', giw: 0, depthAtGiw: 0, officialSafetyMargin: 0, correctionOp: 0, correctionAf: 0 },
                { name: 'Iffezheim', km: 334, river: 'Rijn', streckenAbschnitt: '334-384', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 10, correctionAf: 20, customVuistregel: 80 },
                { name: 'Maxau', km: 362, river: 'Rijn', streckenAbschnitt: '335-384', giw: 372, depthAtGiw: 210, officialSafetyMargin: 30, correctionOp: 12, correctionAf: 12 },
                { name: 'Speyer', km: 400, river: 'Rijn', streckenAbschnitt: '384-410.5', giw: 237, depthAtGiw: 210, officialSafetyMargin: 30, correctionOp: 27, correctionAf: 27 },
                { name: 'Mannheim', km: 424, river: 'Rijn', streckenAbschnitt: '410.5-431.5', giw: 155, depthAtGiw: 210, officialSafetyMargin: 30, correctionOp: 30, correctionAf: 30 },
                { name: 'Worms', km: 443, river: 'Rijn', streckenAbschnitt: '431.5-462', giw: 68, depthAtGiw: 210, officialSafetyMargin: 30, correctionOp: 33, correctionAf: 33 },
                {
                    name: 'Mainz',
                    km: 498,
                    river: 'Rijn',
                    streckenAbschnitt: '462-508',
                    giw: 171,
                    depthAtGiw: 210,
                    officialSafetyMargin: 30,
                    correctionOp: 11,
                    correctionAf: 11,
                    connections: [
                        {
                            targetGaugeName: 'Kelheim',
                            distance: CANAL_DISTANCE,
                            speed: CANAL_AVG_SPEED,
                            isCanal: true
                        }
                    ]
                },
                { name: 'Oestrich', km: 518, river: 'Rijn', streckenAbschnitt: '508-528', giw: 92, depthAtGiw: 190, officialSafetyMargin: 30, correctionOp: 42, correctionAf: 42 },
                { name: 'Bingen', km: 528, river: 'Rijn', streckenAbschnitt: '528-540', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 0, customVuistregel: 100 },
                { name: 'Kaub', km: 546, river: 'Rijn', streckenAbschnitt: '541-566', giw: 77, depthAtGiw: 190, officialSafetyMargin: 30, correctionOp: 17, correctionAf: 17 },
                { name: 'Koblenz', km: 591, river: 'Rijn', streckenAbschnitt: '566-592', giw: 77, depthAtGiw: 210, officialSafetyMargin: 30, correctionOp: 27, correctionAf: 27 },
                { name: 'Koblenz (Mosel)', apiDataName: 'Koblenz', km: 592, river: 'Rijn', streckenAbschnitt: '592-601', giw: 77, depthAtGiw: 250, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Andernach', km: 613, river: 'Rijn', streckenAbschnitt: '601-624', giw: 91, depthAtGiw: 250, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Bonn', km: 655, river: 'Rijn', streckenAbschnitt: '624-660', giw: 142, depthAtGiw: 250, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Köln', km: 688, river: 'Rijn', streckenAbschnitt: '660-710', giw: 139, depthAtGiw: 250, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 9 },
                { name: 'Düsseldorf', km: 744, river: 'Rijn', streckenAbschnitt: '710-763', giw: 91, depthAtGiw: 250, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Duisburg-Ruhrort', km: 780, river: 'Rijn', streckenAbschnitt: '763-794', giw: 227, depthAtGiw: 280, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Wesel', km: 814, river: 'Rijn', streckenAbschnitt: '794-837', giw: 174, depthAtGiw: 280, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Emmerich', km: 852, river: 'Rijn', streckenAbschnitt: '837-857', giw: 74, depthAtGiw: 280, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Lobith', km: 862, river: 'Rijn', streckenAbschnitt: '857-867.5', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 0, customVuistregel: -478, connections: [{ targetGaugeName: 'Pannerdense kop' }, { targetGaugeName: 'Nijmegen' }] },
                { name: 'Nijmegen', km: 883, river: 'Waal', streckenAbschnitt: '867.5-893', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 0, customVuistregel: -260, connections: [{ targetGaugeName: 'Pannerdense kop' }, { targetGaugeName: 'Lobith' }] },
                { name: 'Tiel', km: 914, river: 'Waal', streckenAbschnitt: '893-930', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 0, customVuistregel: 10 },
                { name: 'Pannerdense kop', km: 867, river: 'Pannerdens Kanaal', streckenAbschnitt: 'PK 867.5-878.6', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 0, customVuistregel: -485, connections: [{ targetGaugeName: 'Lobith' }, { targetGaugeName: 'Nijmegen' }, { targetGaugeName: 'IJsselkop' }] },
                { name: 'IJsselkop', km: 878, river: 'IJssel', streckenAbschnitt: 'IJ 867-903', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 10, correctionAf: 20, customVuistregel: -480, connections: [{ targetGaugeName: 'Pannerdense kop' }] },
                { name: 'Doesburg', km: 903, river: 'IJssel', streckenAbschnitt: 'IJ 903-931', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 10, correctionAf: 20, customVuistregel: -200 },
                { name: 'Deventer', km: 931, river: 'IJssel', streckenAbschnitt: 'IJ 931-981', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 10, customVuistregel: 90 },
                { name: 'Katerveer', km: 981, river: 'IJssel', streckenAbschnitt: 'IJ 981-1005', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 10, customVuistregel: 270 },
                { name: 'Spijk - Woudrichem', km: 905, river: 'MGD', streckenAbschnitt: 'Waal km 857.7-952.5', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0, isMGDTarget: true, mgdKmRange: '857.7-952.5', alternativeNames: ['Spijk - Loevestein', 'Millingen - Woudrichem', 'Millingen - Loevestein'] },
                { name: 'Millingen tot Maas-Waalkanaal', km: 872, river: 'MGD', streckenAbschnitt: 'Waal km 857.7-887.0', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0, isMGDTarget: true, mgdKmRange: '857.7-887.0', alternativeNames: ['Spijk - Maas-WaalKanaal', 'Millingen - Maas-Waalkanaal'] },
                { name: 'Maas-Waalkanaal tot Amsterdam-Rijnkanaal', km: 900, river: 'MGD', streckenAbschnitt: 'Waal km 887.0-913.3', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0, isMGDTarget: true, mgdKmRange: '887.0-913.3', alternativeNames: ['Maas-Waalkan tot A\'dam-Rijnkanaal', 'Maas-Waalkanaal tot A\'dam-Rijnkanaal', 'Maas-Waalkanaal - A\'dam-Rijnkanaal', 'Maas-Waalkanaal - Amsterdam-Rijnkanaal'] },
                { name: 'Amsterdam-Rijnkanaal tot Loevestein', km: 933, river: 'MGD', streckenAbschnitt: 'Waal km 913.3-952.5', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0, isMGDTarget: true, mgdKmRange: '913.3-952.5', alternativeNames: ['A\'dam-Rijnkanaal tot Loevestein', 'A\'dam-Rijnkanaal tot Woudrichem', 'A\'dam-Rijnkanaal - Woudrichem', 'Amsterdam-Rijnkanaal - Loevestein'] },
                { name: 'Pannerdensche Kop - IJsselkop', km: 872, river: 'MGD', streckenAbschnitt: 'Pannerdensch Kanaal km 867.5-878.6', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0, alternativeNames: ['Pannerdens Kop - IJsselkop'] },
                { name: 'IJsselkop - Driel', km: 881, river: 'MGD', streckenAbschnitt: 'Nederrijn km 878.6-891.0', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'Driel - Heteren', km: 893, river: 'MGD', streckenAbschnitt: 'Nederrijn km 891.0-895.0', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'Heteren - Amsterdam-Rijnkanaal', km: 913, river: 'MGD', streckenAbschnitt: 'Nederrijn km 895.0-929.0', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0, alternativeNames: ['Heteren - A\'dam-Rijnkanaal'] },
                { name: 'Amsterdam-Rijnkanaal - Hagestein', km: 938, river: 'MGD', streckenAbschnitt: 'Lek km 929.0-947.0', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0, alternativeNames: ['A\'dam-Rijnkanaal - Hagestein'] },
                { name: 'IJsselkop - Twenthekanaal', km: 900, river: 'MGD', streckenAbschnitt: 'IJssel km 878.6-931.0', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0, },
                { name: 'Twenthekanaal - Zwolle-IJsselkanaal', km: 956, river: 'MGD', streckenAbschnitt: 'IJssel km 931.0-981.0', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0, },
                { name: 'Uitvaartdiepte Oostsluis Weurt', km: 887, river: 'MGD', streckenAbschnitt: 'Oostsluis Weurt', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'Uitvaartdiepte Westsluis Weurt', km: 887.1, river: 'MGD', streckenAbschnitt: 'Westsluis Weurt', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 }
            ];

            const processedStaticData = combinedStaticList.map(g => ({
                ...g,
                giw: g.giw ?? 'N/A',
                depthAtGiw: g.depthAtGiw ?? 'N/A',
                officialSafetyMargin: g.officialSafetyMargin === undefined ? 'N/A' : g.officialSafetyMargin,
                isMainRoute: MAIN_ROUTE_RIVERS.includes(g.river)
            })).sort((a, b) => {
                const riverOrder = { 'Rijn': 1, 'Pannerdens Kanaal': 2, 'Waal': 3, 'Nederrijn': 4, 'Lek': 5, 'IJssel': 6, 'MGD': 7, 'Unknown': 99 };
                const riverA = a.river || 'Unknown';
                const riverB = b.river || 'Unknown';
                const orderA = riverOrder[riverA] || 99;
                const orderB = riverOrder[riverB] || 99;
                if (orderA !== orderB) return orderA - orderB;
                const kmA = a.km === undefined || a.km === null ? Infinity : a.km;
                const kmB = b.km === undefined || b.km === null ? Infinity : b.km;
                return kmA - kmB;
            });
            setAllGaugeStaticData(processedStaticData);
            const savedCorrections = getCookie('rhineDraftCorrections');
            const defaultCorrections = {upstream: {}, downstream: {}};
            processedStaticData.forEach(gauge => {
                defaultCorrections.upstream[gauge.name] = gauge.correctionOp === undefined ? 0 : gauge.correctionOp;
                defaultCorrections.downstream[gauge.name] = gauge.correctionAf === undefined ? 0 : gauge.correctionAf;
            });
            const mergedCorrections = {
                upstream: {...defaultCorrections.upstream, ...(savedCorrections?.upstream || {})},
                downstream: {...defaultCorrections.downstream, ...(savedCorrections?.downstream || {})}
            };
            setCustomCorrections(mergedCorrections);
            setDataStatus({status: 'success', message: t('staticLoaded')});
        }, [t]);

        const loadGaugeApiData = useCallback(async (force = false) => {
            setDataStatus({status: 'pending', message: t('fetchingData')});
            if (refreshButtonRef.current) refreshButtonRef.current.disabled = true;
            try {
                const apiResponse = await fetchConsolidatedData(force);
                const newApiData = {};
                let successfulUpdates = 0;
                let apiGaugeCount = 0;
                let warningMessages = [];
                let errorMessages = [];
                let overallStatus = 'success';
                let latestApiTimestamp = 0;
                const todayDate = new Date();
                const nlYear = todayDate.toLocaleDateString('en-CA', {year: 'numeric', timeZone: 'Europe/Amsterdam'});
                const nlMonth = todayDate.toLocaleDateString('en-CA', {month: '2-digit', timeZone: 'Europe/Amsterdam'});
                const nlDay = todayDate.toLocaleDateString('en-CA', {day: '2-digit', timeZone: 'Europe/Amsterdam'});
                const todayStr = `${nlYear}-${nlMonth}-${nlDay}`;
                apiGaugeCount = Object.keys(apiResponse).length;
                Object.entries(apiResponse).forEach(([apiGaugeName, data]) => {
                    if (data.status === 'OK' || data.status === 'WARNING') successfulUpdates++; else if (data.status?.startsWith('CACHED')) {
                        successfulUpdates++;
                        if (data.status !== 'CACHED' && data.status !== 'CACHED_UNCHANGED') {
                            warningMessages.push(`${apiGaugeName}: ${data.status} (${data.error || 'stale/partial'})`);
                            if (overallStatus !== 'error') overallStatus = 'warning';
                        }
                    } else {
                        errorMessages.push(`${apiGaugeName}: ${data.error || data.status || 'Unknown error'}`);
                        overallStatus = 'error';
                    }
                    if (data.error && data.status !== 'ERROR' && !data.status?.startsWith('CACHED')) {
                        warningMessages.push(`${apiGaugeName}: ${data.error}`);
                        if (overallStatus !== 'error') overallStatus = 'warning';
                    }
                    if (data.lastUpdated) {
                        try {
                            const t = new Date(data.lastUpdated).getTime();
                            if (!isNaN(t) && t > latestApiTimestamp) latestApiTimestamp = t;
                        } catch (e) {}
                    }
                });
                allGaugeStaticData.forEach(staticGauge => {
                    const apiLookupKey = staticGauge.apiDataName || staticGauge.name;
                    const rawData = apiResponse[apiLookupKey];
                    const displayKey = staticGauge.name;
                    if (rawData) {
                        const processedForecasts = {};
                        if (rawData.forecasts) {
                            Object.entries(rawData.forecasts).forEach(([dateStr, timeEntries]) => {
                                if (dateStr >= todayStr) {
                                    const validTimeEntries = {};
                                    Object.entries(timeEntries).forEach(([timeStr, forecastData]) => {
                                        if (timeStr.match(/^\d{2}:\d{2}$/) && forecastData && forecastData.value !== undefined && forecastData.value !== null) {
                                            validTimeEntries[timeStr] = {
                                                value: forecastData.value,
                                                low_80: forecastData.low_80 ?? null,
                                                high_80: forecastData.high_80 ?? null
                                            };
                                        }
                                    });
                                    if (Object.keys(validTimeEntries).length > 0) {
                                        processedForecasts[dateStr] = validTimeEntries;
                                    }
                                }
                            });
                        }
                        newApiData[displayKey] = {
                            apiName: apiLookupKey,
                            currentLevel: rawData.currentLevel ?? null,
                            currentTime: formatTimeDisplay(rawData.currentTime || rawData.lastUpdated, locale),
                            currentTrend: rawData.currentTrend ?? null,
                            forecasts: processedForecasts,
                            weeklyForecasts: rawData.weeklyForecasts ?? null,
                            status: rawData.status || 'ERROR',
                            error: rawData.error || null,
                            river: staticGauge.river || rawData.river || 'Unknown',
                            region: staticGauge.region || rawData.region || 'unknown',
                            source: rawData.source || {measurement: null, forecast: null},
                            lastUpdated: rawData.lastUpdated || null,
                            giw: staticGauge.giw,
                            depthAtGiw: staticGauge.depthAtGiw,
                            officialSafetyMargin: staticGauge.officialSafetyMargin,
                            customVuistregel: staticGauge.customVuistregel,
                            isMGDTarget: staticGauge.isMGDTarget
                        };
                    }
                });
                setGaugeApiData(newApiData);
                const futureDates = [];
                let currentDate = new Date(todayStr + 'T12:00:00Z');
                currentDate.setUTCDate(currentDate.getUTCDate() + 1);
                for (let i = 0; i < MAX_FORECAST_DAYS; i++) {
                    const year = currentDate.getUTCFullYear();
                    const month = String(currentDate.getUTCMonth() + 1).padStart(2, '0');
                    const day = String(currentDate.getUTCDate()).padStart(2, '0');
                    futureDates.push(`${year}-${month}-${day}`);
                    currentDate.setUTCDate(currentDate.getUTCDate() + 1);
                }
                setForecastDates(futureDates);
                setLastUpdated(latestApiTimestamp > 0 ? new Date(latestApiTimestamp) : new Date());
                let finalMessage;
                if (overallStatus === 'error') {
                    finalMessage = t('updateError', { errorCount: errorMessages.length, firstError: errorMessages[0] || '' });
                } else if (overallStatus === 'warning') {
                    finalMessage = t('updateWarning', { warningCount: warningMessages.length, firstWarning: warningMessages[0] || '' });
                } else {
                    finalMessage = t('dataUpdated', { successfulUpdates, apiGaugeCount });
                }
                setDataStatus({status: overallStatus, message: finalMessage});
            } catch (error) {
                console.error("Failed to load or process API data:", error);
                setDataStatus({status: 'error', message: t('loadError', { errorMessage: error.message })});
                setLastUpdated(new Date());
            } finally {
                if (refreshButtonRef.current) refreshButtonRef.current.disabled = false;
                if (autoRefresh) {
                    const nextTime = new Date(Date.now() + REFRESH_INTERVAL_MS);
                    setNextRefreshTime(nextTime);
                } else {
                    setNextRefreshTime(null);
                }
            }
        }, [allGaugeStaticData, autoRefresh, t, locale]);

        useEffect(() => {
            if (allGaugeStaticData.length > 0) loadGaugeApiData(false);
        }, [allGaugeStaticData, loadGaugeApiData]);

        useEffect(() => {
            if (!autoRefresh) {
                setNextRefreshTime(null);
                return () => {};
            }
            let timerId;
            const setTimer = () => {
                const nextTime = new Date(Date.now() + REFRESH_INTERVAL_MS);
                setNextRefreshTime(nextTime);
                timerId = setTimeout(() => {
                    console.log("Auto-refresh triggered at", new Date().toLocaleTimeString());
                    if (refreshHandlerRef.current && !refreshButtonRef.current?.disabled) {
                        refreshHandlerRef.current?.(false);
                    } else {
                        console.log("Auto-refresh skipped, setting timer again.");
                        setTimer();
                    }
                }, REFRESH_INTERVAL_MS);
            };
            setTimer();
            return () => clearTimeout(timerId);
        }, [autoRefresh]);

        useEffect(() => {
            if (activeTab === 'planner') {
                if (fixedHeaderContainerRef.current) fixedHeaderContainerRef.current.classList.remove('visible');
                if (originalTheadRef.current) originalTheadRef.current.classList.remove('hidden');
                isHeaderFixedRef.current = false;
                return () => {};
            }
            const sentinel = sentinelRef.current;
            const scrollWrapper = scrollWrapperRef.current;
            const originalTable = originalTableRef.current;
            const originalThead = originalTheadRef.current;
            const fixedHeaderContainer = fixedHeaderContainerRef.current;
            const fixedHeaderTable = fixedHeaderTableRef.current;
            if (!sentinel || !scrollWrapper || !originalTable || !originalThead || !fixedHeaderContainer || !fixedHeaderTable) {
                console.warn("Fixed header refs not ready for tab:", activeTab);
                return;
            }
            let clonedThead = null;
            const cloneHeader = () => {
                while (fixedHeaderTable.firstChild) {
                    fixedHeaderTable.removeChild(fixedHeaderTable.firstChild);
                }
                if (originalThead) {
                    clonedThead = originalThead.cloneNode(true);
                    fixedHeaderTable.appendChild(clonedThead);
                    if (isHeaderFixedRef.current) {
                        syncHeaderGeometry();
                        syncHeaderScroll(scrollWrapper.scrollLeft);
                    }
                } else {
                    console.warn("Original thead ref not found for cloning.");
                }
            };
            cloneHeader();
            const syncHeaderGeometry = () => {
                if (!isHeaderFixedRef.current || !scrollWrapper || !originalTable || !fixedHeaderContainer || !fixedHeaderTable) return;
                requestAnimationFrame(() => {
                    const scrollWrapperRect = scrollWrapper.getBoundingClientRect();
                    const originalTableWidth = Math.max(originalTable.offsetWidth, originalTable.scrollWidth);
                    fixedHeaderContainer.style.left = `${scrollWrapperRect.left}px`;
                    fixedHeaderContainer.style.width = `${scrollWrapper.clientWidth}px`;
                    fixedHeaderTable.style.width = `${originalTableWidth}px`;
                });
            };
            const syncHeaderScroll = (scrollLeft) => {
                if (!fixedHeaderContainer) return;
                requestAnimationFrame(() => {
                    fixedHeaderContainer.scrollLeft = scrollLeft;
                });
            };
            const observer = new IntersectionObserver(([entry]) => {
                const shouldBeFixed = !entry.isIntersecting && entry.boundingClientRect.top < 0;
                if (shouldBeFixed && !isHeaderFixedRef.current) {
                    isHeaderFixedRef.current = true;
                    originalThead?.classList.add('hidden');
                    syncHeaderGeometry();
                    syncHeaderScroll(scrollWrapper.scrollLeft);
                    fixedHeaderContainer?.classList.add('visible');
                } else if (!shouldBeFixed && isHeaderFixedRef.current) {
                    isHeaderFixedRef.current = false;
                    originalThead?.classList.remove('hidden');
                    fixedHeaderContainer?.classList.remove('visible');
                }
            }, {threshold: [0], rootMargin: "0px"});
            observer.observe(sentinel);
            const handleScroll = () => {
                if (isHeaderFixedRef.current) {
                    syncHeaderScroll(scrollWrapper.scrollLeft);
                }
            };
            const handleResize = () => {
                cloneHeader();
                if (isHeaderFixedRef.current) {
                    syncHeaderGeometry();
                    syncHeaderScroll(scrollWrapper.scrollLeft);
                }
            };
            scrollWrapper.addEventListener('scroll', handleScroll, {passive: true});
            window.addEventListener('resize', handleResize);
            window.addEventListener('scroll', handleResize, {passive: true});
            const initialCheckTimeout = setTimeout(() => {
                if (!sentinelRef.current || !scrollWrapperRef.current || !originalTheadRef.current) return;
                const sentinelRect = sentinelRef.current.getBoundingClientRect();
                const shouldBeFixedInitially = sentinelRect.top < 0;
                if (shouldBeFixedInitially && !isHeaderFixedRef.current) {
                    isHeaderFixedRef.current = true;
                    originalTheadRef.current?.classList.add('hidden');
                    syncHeaderGeometry();
                    syncHeaderScroll(scrollWrapperRef.current.scrollLeft);
                    fixedHeaderContainerRef.current?.classList.add('visible');
                } else if (!shouldBeFixedInitially && isHeaderFixedRef.current) {
                    isHeaderFixedRef.current = false;
                    originalTheadRef.current?.classList.remove('hidden');
                    fixedHeaderContainerRef.current?.classList.remove('visible');
                }
            }, 150);
            return () => {
                clearTimeout(initialCheckTimeout);
                observer.disconnect();
                const currentScrollWrapper = scrollWrapperRef.current;
                currentScrollWrapper?.removeEventListener('scroll', handleScroll);
                window.removeEventListener('resize', handleResize);
                window.removeEventListener('scroll', handleResize);
                if (fixedHeaderContainerRef.current) fixedHeaderContainerRef.current.classList.remove('visible');
                if (originalTheadRef.current) originalTheadRef.current.classList.remove('hidden');
                isHeaderFixedRef.current = false;
            };
        }, [activeTab, forecastDates.length]);

        useEffect(() => {
            setCookie('rhinePlannerSettings', plannerSettings);
        }, [plannerSettings]);
        useEffect(() => {
            setCookie('rhineShowUncertainty', showUncertainty);
        }, [showUncertainty]);
        useEffect(() => {
            setCookie('rhineDraftCorrections', customCorrections);
        }, [customCorrections]);
        useEffect(() => {
            setCookie('selectedRiverContext', selectedRiver);
        }, [selectedRiver]);


        // --- Event Handlers ---
        const handleCorrectionChange = (direction, gaugeName, value) => {
            const parsedValue = parseInt(value, 10);
            const newValue = value === '' ? 0 : (isNaN(parsedValue) ? (customCorrections[direction][gaugeName] || 0) : parsedValue);
            const newCorrections = {
                ...customCorrections,
                [direction]: {...customCorrections[direction], [gaugeName]: newValue}
            };
            setCustomCorrections(newCorrections);
        };

        const handleJourneyChange = (type, value) => {
            const newJourneyForRiver = {
                ...(journey[selectedRiver] || {}),
                [type]: value || null
            };
            const newJourneys = {...journey, [selectedRiver]: newJourneyForRiver};
            setJourney(newJourneys);
            setCookie('riverJourneys', newJourneys);
        };
        const handleRefresh = useCallback((force = true) => {
            console.log("Manual refresh triggered.", `Force: ${force}`);
            loadGaugeApiData(force);
        }, [loadGaugeApiData]);
        const refreshHandlerRef = useRef();
        useEffect(() => {
            refreshHandlerRef.current = handleRefresh;
        }, [handleRefresh]);
        const handleTabChange = (tab) => {
            setActiveTab(tab);
        };
        const handleDisplayModeChange = (event) => {
            setDisplayMode(event.target.value);
        };
        const handleUncertaintyToggle = (event) => {
            setShowUncertainty(event.target.checked);
        };
        const handlePlannerSettingChange = (key, value) => {
            setPlannerSettings(prev => ({...prev, [key]: value}));
        };
        const handleExcludedDayChange = (dayIndex, isChecked) => {
            setPlannerSettings(prev => {
                const currentExcluded = prev.excludedDays || [];
                if (isChecked) {
                    return {...prev, excludedDays: [...new Set([...currentExcluded, dayIndex])]};
                } else {
                    return {...prev, excludedDays: currentExcluded.filter(d => d !== dayIndex)};
                }
            });
        };
        const handleOperationalModeChange = (e) => {
            const mode = e.target.value;
            let hours = plannerSettings.customOperationalHours;
            if (mode === 'A1') hours = 14; else if (mode === 'A2') hours = 18; else if (mode === 'B') hours = 24;
            setPlannerSettings(prev => ({
                ...prev,
                operationalMode: mode,
                customOperationalHours: (mode !== 'Custom') ? hours : prev.customOperationalHours
            }));
        };
        const handleSetNow = () => {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const formattedNow = `${year}-${month}-${day}T${hours}:${minutes}`;
            handlePlannerSettingChange('startDate', formattedNow);
        };

        useEffect(() => {
            const currentJourneySettings = journey[selectedRiver];
            if (!currentJourneySettings || !currentJourneySettings.start || !currentJourneySettings.end || allGaugeStaticData.length === 0) {
                 return;
            }

            const startGauge = allGaugeStaticData.find(g => g.name === currentJourneySettings.start);
            const endGauge = allGaugeStaticData.find(g => g.name === currentJourneySettings.end);

            if (startGauge && endGauge && startGauge.river === endGauge.river) {
                 if (startGauge.river === 'Donau') {
                    setTravelDirection(startGauge.km > endGauge.km ? 'downstream' : 'upstream');
                } else {
                    setTravelDirection(startGauge.km < endGauge.km ? 'downstream' : 'upstream');
                }
            } else {
                setTravelDirection('downstream');
            }
        }, [journey, selectedRiver, allGaugeStaticData]);

        const displayedGaugeDataMaxDraft = useMemo(() => {
            // For route tab, map over the ordered gaugesOnRoute array to preserve order
            if (activeTab === 'route') {
                const routeWithApiData = gaugesOnRoute
                    .map(routeGauge => {
                        const apiData = gaugeApiData[routeGauge.name];
                        if (apiData && (apiData.status === 'OK' || apiData.status?.startsWith('CACHED') || apiData.status === 'WARNING')) {
                            return { ...routeGauge, apiData: apiData };
                        }
                        return null;
                    })
                    .filter(Boolean); // Filter out gauges without valid API data

                // Now, iterate again to add the segment direction to each point
                return routeWithApiData.map((gauge, index) => {
                    let segmentDirection = travelDirection; // Default to overall journey direction
                    const nextGauge = index < routeWithApiData.length - 1 ? routeWithApiData[index + 1] : null;
                    const prevGauge = index > 0 ? routeWithApiData[index - 1] : null;

                    if (nextGauge && nextGauge.river === gauge.river) {
                        // Standard case: continuing on the same river. Base direction on the next step.
                        if (gauge.river === 'Donau') {
                            segmentDirection = nextGauge.km < gauge.km ? 'downstream' : 'upstream';
                        } else {
                            segmentDirection = nextGauge.km > gauge.km ? 'downstream' : 'upstream';
                        }
                    } else if (prevGauge && prevGauge.river === gauge.river) {
                        // End of a river segment or a junction. Base direction on how we arrived.
                        if (gauge.river === 'Donau') {
                            segmentDirection = gauge.km < prevGauge.km ? 'downstream' : 'upstream';
                        } else {
                            segmentDirection = gauge.km > prevGauge.km ? 'downstream' : 'upstream';
                        }
                    }
                    return { ...gauge, segmentDirection };
                });
            }

            // For 'all' tab, filter the main static data list
            if (activeTab === 'all') {
                return allGaugeStaticData.filter(staticGauge => {
                    const apiData = gaugeApiData[staticGauge.name];
                    const hasApiData = !!apiData && (apiData.status === 'OK' || apiData.status?.startsWith('CACHED') || apiData.status === 'WARNING');
                    if (!hasApiData) return false;

                    if (selectedRiver === 'all') return true;

                    if (selectedRiver === 'Rijn/Waal') {
                         return staticGauge.river === 'Rijn' || staticGauge.river === 'Waal' || staticGauge.name === 'Spijk - Woudrichem';
                    }

                    if (selectedRiver === 'IJssel') {

                        return staticGauge.river === 'IJssel' || staticGauge.name === 'IJsselkop - Twenthekanaal' || staticGauge.name === 'Twenthekanaal - Zwolle-IJsselkanaal';
                    }

                    return staticGauge.river === selectedRiver;

                }).map(staticGauge => ({
                    ...staticGauge,
                    apiData: gaugeApiData[staticGauge.name],
                    segmentDirection: travelDirection
                }));
            }

            return [];
        }, [allGaugeStaticData, gaugeApiData, activeTab, selectedRiver, gaugesOnRoute, travelDirection]);

        const displayedGaugeData = activeTab === 'planner' ? [] : displayedGaugeDataMaxDraft;

        const calculateDraft = useCallback((gauge, waterLevel, direction) => {
            if (!gauge || waterLevel === null || waterLevel === undefined || isNaN(Number(waterLevel))) return null;
            if (gauge.name === "Konstanz") return null;

            let calculatedDraft = null;
            const numericLevel = Number(waterLevel);
            const effectiveDirection = direction || travelDirection;
            const correction = customCorrections[effectiveDirection]?.[gauge.name] || 0;

            if (gauge.river === 'MGD') {
                const safetyMargin = gauge.officialSafetyMargin !== 'N/A' ? Number(gauge.officialSafetyMargin) : DEFAULT_DEPTH_SAFETY_MARGIN;
                if (!isNaN(safetyMargin)) {
                    calculatedDraft = (numericLevel - safetyMargin + correction);
                }
            } else if (gauge.customVuistregel !== undefined && gauge.customVuistregel !== null && !isNaN(Number(gauge.customVuistregel))) {
                calculatedDraft = (numericLevel + Number(gauge.customVuistregel) + correction);
            } else if (['Rijn', 'IJssel', 'Donau'].includes(gauge.river) && gauge.giw !== 'N/A' && gauge.depthAtGiw !== 'N/A' && gauge.officialSafetyMargin !== 'N/A') {
                const giw = Number(gauge.giw);
                const depth = Number(gauge.depthAtGiw);
                const safety = Number(gauge.officialSafetyMargin);
                if (!isNaN(giw) && !isNaN(depth) && !isNaN(safety)) {
                    calculatedDraft = (numericLevel - giw + depth - safety + correction);
                }
            }
            if (calculatedDraft !== null) {
                if (gauge.river === 'Donau') {
                    return Math.min(calculatedDraft, 270);
                }
            }
            return calculatedDraft;
        }, [customCorrections, travelDirection]);

        const calculateOfficialRuleOfThumb = useCallback((gauge) => {
            if (gauge.river === 'MGD' || gauge.giw === 'N/A' || gauge.depthAtGiw === 'N/A' || gauge.officialSafetyMargin === 'N/A') return "N/A";
            const giw = Number(gauge.giw);
            const depth = Number(gauge.depthAtGiw);
            const safety = Number(gauge.officialSafetyMargin);
            if (isNaN(giw) || isNaN(depth) || isNaN(safety)) return "N/A";
            if (["Nijmegen", "Tiel", "Bingen", "Iffezheim", "Konstanz", "Lobith", "Pannerdense kop", "IJsselkop", "Doesburg", "Deventer", "Katerveer"].includes(gauge.name)) return "N/A";
            return (depth - safety - giw).toFixed(0);
        }, []);

        const calculateCustomRuleOfThumbDisplay = useCallback((gauge, direction) => {
            if (!gauge || gauge.name === "Konstanz") return "N/A";
            const effectiveDirection = direction || travelDirection;
            const correction = customCorrections[effectiveDirection]?.[gauge.name] || 0;
            if (gauge.river === 'MGD') {
                return correction.toFixed(0);
            }
            let baseRule = null;
            if (gauge.customVuistregel !== undefined && gauge.customVuistregel !== null && !isNaN(Number(gauge.customVuistregel))) {
                baseRule = Number(gauge.customVuistregel);
            } else {
                const officialRule = calculateOfficialRuleOfThumb(gauge);
                if (officialRule !== "N/A") {
                    baseRule = Number(officialRule);
                }
            }
            if (baseRule !== null) {
                return (baseRule + correction).toFixed(0);
            }
            return "N/A";
        }, [customCorrections, travelDirection, calculateOfficialRuleOfThumb]);

        const findCriticalGaugeMaxDraft = useCallback(() => {
            if (activeTab !== 'route' || displayedGaugeDataMaxDraft.length === 0) return { name: null, draft: null, apiData: null };
            let criticalGaugeName = null;
            let minDraft = Infinity;
            let criticalApiData = null;
            displayedGaugeDataMaxDraft.forEach(gauge => {
                const apiData = gauge.apiData;
                if (apiData && apiData.currentLevel !== null) {
                    const draft = calculateDraft(gauge, apiData.currentLevel, gauge.segmentDirection);
                    if (draft !== null && !isNaN(Number(draft))) {
                        const numericDraft = Number(draft);
                        if (numericDraft < minDraft) {
                            minDraft = numericDraft;
                            criticalGaugeName = gauge.name;
                            criticalApiData = apiData;
                        }
                    }
                }
            });
            return {name: criticalGaugeName, draft: minDraft === Infinity ? null : minDraft, apiData: criticalApiData};
        }, [activeTab, displayedGaugeDataMaxDraft, calculateDraft]);

        const isMixedDirectionRoute = useMemo(() => {
            if (activeTab !== 'route' || gaugesOnRoute.length < 2) return false;

            const directions = new Set();
            // Iterate over segments of the route
            for (let i = 0; i < gaugesOnRoute.length - 1; i++) {
                const currentGauge = gaugesOnRoute[i];
                const nextGauge = gaugesOnRoute[i + 1];

                // Only consider segments on the same river to get a clear direction
                if (currentGauge.river === nextGauge.river) {
                    let direction;
                    if (currentGauge.river === 'Donau') {
                        direction = nextGauge.km < currentGauge.km ? 'downstream' : 'upstream';
                    } else {
                        direction = nextGauge.km > currentGauge.km ? 'downstream' : 'upstream';
                    }
                    directions.add(direction);
                }
            }
            // If the set contains both 'upstream' and 'downstream', the route is mixed.
            return directions.size > 1;
        }, [activeTab, gaugesOnRoute]);

        const { name: criticalGaugeName, draft: criticalDraftValue, apiData: criticalApiDataForHighlight } = findCriticalGaugeMaxDraft();

        const todayStr = useMemo(() => {
            const todayDate = new Date();
            const nlYear = todayDate.toLocaleDateString('en-CA', {year: 'numeric', timeZone: 'Europe/Amsterdam'});
            const nlMonth = todayDate.toLocaleDateString('en-CA', {month: '2-digit', timeZone: 'Europe/Amsterdam'});
            const nlDay = todayDate.toLocaleDateString('en-CA', {day: '2-digit', timeZone: 'Europe/Amsterdam'});
            return `${nlYear}-${nlMonth}-${nlDay}`;
        }, []);

        function getBestForecastTime(forecastsForDate, currentTime) {
            if (!forecastsForDate || typeof forecastsForDate !== 'object') {
                return null;
            }
            const availableTimes = Object.keys(forecastsForDate).filter(t => t.match(/^\d{2}:\d{2}$/));
            if (availableTimes.length === 0) {
                return null;
            }
            if (availableTimes.length === 1) {
                return availableTimes[0];
            }
            availableTimes.sort();
            if (!currentTime) {
                return availableTimes[availableTimes.length - 1];
            }
            let currentMinutes = 0;
            try {
                const [hours, minutes] = currentTime.split(':').map(Number);
                currentMinutes = hours * 60 + minutes;
            } catch (e) {
                return availableTimes[availableTimes.length - 1];
            }
            let bestTime = availableTimes[0];
            let minDiff = Infinity;
            for (const time of availableTimes) {
                const [hours, minutes] = time.split(':').map(Number);
                const timeMinutes = hours * 60 + minutes;
                const diff = Math.abs(timeMinutes - currentMinutes);
                if (diff < minDiff) {
                    minDiff = diff;
                    bestTime = time;
                }
            }
            return bestTime;
        }

        const forecastBottlenecks = useMemo(() => {
            if (activeTab !== 'route' || forecastDates.length === 0 || displayedGaugeDataMaxDraft.length === 0) return [];
            return forecastDates.map(dateStr => {
                let criticalGauge = null;
                let minDraft = Infinity;
                let forecastTime = null;
                let forecastLevelForCrit = null;
                let forecastSlotForCrit = null;
                let weeklyForecastSlotForCrit = null;
                let valueSource = null;
                let uncertaintyText = '';
                displayedGaugeDataMaxDraft.forEach(gauge => {
                    const apiData = gauge.apiData;
                    let potentialDraft = null;
                    let currentForecastLevel = null;
                    let currentForecastTime = null;
                    let currentForecastSlot = null;
                    let currentWeeklyForecastSlot = null;
                    let currentValueSource = null;
                    const forecastsForDate = apiData?.forecasts?.[dateStr];
                    if (forecastsForDate && Object.keys(forecastsForDate).length > 0) {
                        const selectedTime = getBestForecastTime(forecastsForDate, apiData?.currentTime);
                        const dailySlot = selectedTime ? forecastsForDate[selectedTime] : null;
                        if (dailySlot && dailySlot.value !== undefined && dailySlot.value !== null) {
                            currentForecastLevel = dailySlot.value;
                            currentForecastTime = selectedTime;
                            currentForecastSlot = dailySlot;
                            currentValueSource = 'daily';
                            potentialDraft = calculateDraft(gauge, currentForecastLevel, gauge.segmentDirection);
                        }
                    }
                    if (potentialDraft === null && Array.isArray(apiData?.weeklyForecasts) && apiData.weeklyForecasts.length > 0) {
                        const targetDate = new Date(dateStr + 'T12:00:00Z');
                        for (const weeklyForecast of apiData.weeklyForecasts) {
                            if (weeklyForecast.weekRange && weeklyForecast.median !== null) {
                                try {
                                    const [startStr, endStr] = weeklyForecast.weekRange.split('-');
                                    const [startDay, startMonth, startYear] = startStr.split('.');
                                    const [endDay, endMonth, endYear] = endStr.split('.');
                                    const startDate = new Date(Date.UTC(startYear, startMonth - 1, startDay, 0, 0, 0));
                                    const endDate = new Date(Date.UTC(endYear, endMonth - 1, endDay, 23, 59, 59));
                                    if (!isNaN(startDate.getTime()) && !isNaN(endDate.getTime()) && targetDate >= startDate && targetDate <= endDate) {
                                        currentForecastLevel = weeklyForecast.median;
                                        currentForecastTime = "(BfG6W)";
                                        currentForecastSlot = null;
                                        currentWeeklyForecastSlot = weeklyForecast;
                                        currentValueSource = 'weekly';
                                        potentialDraft = calculateDraft(gauge, currentForecastLevel, gauge.segmentDirection);
                                        break;
                                    }
                                } catch (e) { }
                            }
                        }
                    }
                    if (potentialDraft !== null && !isNaN(Number(potentialDraft))) {
                        const numericDraft = Number(potentialDraft);
                        if (numericDraft < minDraft) {
                            minDraft = numericDraft;
                            criticalGauge = gauge;
                            forecastTime = currentForecastTime;
                            forecastLevelForCrit = currentForecastLevel;
                            forecastSlotForCrit = currentForecastSlot;
                            weeklyForecastSlotForCrit = currentWeeklyForecastSlot;
                            valueSource = currentValueSource;
                        }
                    }
                });
                if (criticalGauge && showUncertainty) {
                    if (valueSource === 'daily' && forecastSlotForCrit) {
                        if (forecastSlotForCrit.low_80 !== null && forecastSlotForCrit.high_80 !== null) {
                            const draftLow = calculateDraft(criticalGauge, forecastSlotForCrit.low_80, criticalGauge.segmentDirection);
                            const draftHigh = calculateDraft(criticalGauge, forecastSlotForCrit.high_80, criticalGauge.segmentDirection);
                            if (draftLow !== null && draftHigh !== null && !isNaN(draftLow) && !isNaN(draftHigh)) {
                                uncertaintyText = `(${Math.min(draftLow, draftHigh).toFixed(0)}–${Math.max(draftLow, draftHigh).toFixed(0)} cm)`;
                            } else {
                                uncertaintyText = '(Bereik N/A)';
                            }
                        } else if (forecastLevelForCrit !== null) {
                            const now = new Date();
                            const uncertaintyCm = calculateForecastUncertainty(criticalGauge, dateStr, now);
                            if (uncertaintyCm !== null) {
                                const draftLow = calculateDraft(criticalGauge, forecastLevelForCrit - uncertaintyCm, criticalGauge.segmentDirection);
                                const draftHigh = calculateDraft(criticalGauge, forecastLevelForCrit + uncertaintyCm, criticalGauge.segmentDirection);
                                if (draftLow !== null && draftHigh !== null && !isNaN(draftLow) && !isNaN(draftHigh)) {
                                    uncertaintyText = `(${Math.min(draftLow, draftHigh).toFixed(0)}–${Math.max(draftLow, draftHigh).toFixed(0)} cm*)`;
                                } else {
                                    uncertaintyText = `(±${uncertaintyCm} cm*)`;
                                }
                            }
                        }
                    } else if (valueSource === 'weekly' && weeklyForecastSlotForCrit) {
                        if (weeklyForecastSlotForCrit.low_90 !== null && weeklyForecastSlotForCrit.high_90 !== null) {
                            const draftLow = calculateDraft(criticalGauge, weeklyForecastSlotForCrit.low_90, criticalGauge.segmentDirection);
                            const draftHigh = calculateDraft(criticalGauge, weeklyForecastSlotForCrit.high_90, criticalGauge.segmentDirection);
                            if (draftLow !== null && draftHigh !== null && !isNaN(draftLow) && !isNaN(draftHigh)) {
                                uncertaintyText = `(${Math.min(draftLow, draftHigh).toFixed(0)}–${Math.max(draftLow, draftHigh).toFixed(0)} cm)`;
                            } else {
                                uncertaintyText = '(Bereik N/A)';
                            }
                        }
                    }
                }
                return {
                    date: dateStr,
                    gauge: criticalGauge?.name || null,
                    draft: criticalGauge && minDraft !== Infinity ? minDraft.toFixed(0) : 'N/A',
                    time: forecastTime,
                    uncertainty: uncertaintyText
                };
            });
        }, [activeTab, forecastDates, displayedGaugeDataMaxDraft, calculateDraft, showUncertainty, todayStr, getBestForecastTime, diffDays]);


        // --- Route Planning Calculation Function ---
const calculateRoutePlan = useCallback(() => {
            setRoutePlanStatus('calculating');
            setRoutePlanResult(null);

            try {
                // 1. Validate Inputs
                const startDateTime = new Date(plannerSettings.startDate);
                if (isNaN(startDateTime.getTime())) throw new Error(t('errorInvalidDate'));

                const startGaugeName = journey[selectedRiver]?.start;
                const endGaugeName = journey[selectedRiver]?.end;
                if (!startGaugeName || !endGaugeName) throw new Error(t('errorNoRoute'));

                if (!plannerSettings.speedDownstream || plannerSettings.speedDownstream <= 0 || !plannerSettings.speedUpstream || plannerSettings.speedUpstream <= 0) throw new Error(t('errorInvalidSpeed'));
                let operationalHours;
                switch (plannerSettings.operationalMode) {
                    case 'A1': operationalHours = 14; break;
                    case 'A2': operationalHours = 18; break;
                    case 'B': operationalHours = 24; break;
                    case 'Custom':
                        operationalHours = Number(plannerSettings.customOperationalHours);
                        if (!operationalHours || operationalHours <= 0 || operationalHours > 24) throw new Error(t('errorInvalidHours'));
                        break;
                    default: throw new Error(t('system'));
                }
                if (plannerSettings.customSegmentKm > 0 && (!plannerSettings.customSegmentSpeed || plannerSettings.customSegmentSpeed <= 0)) {
                    throw new Error(t('errorCustomSegmentSpeed'));
                }

                // 2. Find the route using the pathfinder
                const routeGauges = findRoutePath(startGaugeName, endGaugeName, allGaugeStaticData, {
                    downstream: plannerSettings.speedDownstream,
                    upstream: plannerSettings.speedUpstream,
                });

                if (!routeGauges || routeGauges.length === 0) {
                     throw new Error(t('errorNoPath', { start: startGaugeName, end: endGaugeName }));
                }

                // 3. Initialize variables for calculation loop
                const intermediatePoints = [];
                let currentTime = new Date(startDateTime.getTime());
                let overallMinDraft = Infinity;
                let criticalPointInfo = null;
                const now = new Date();

                // Add Custom Segment calculation BEFORE loop if position is 'start'
                if (plannerSettings.customSegmentPosition === 'start' && plannerSettings.customSegmentKm > 0 && plannerSettings.customSegmentSpeed > 0) {
                    const segmentHours = plannerSettings.customSegmentKm / plannerSettings.customSegmentSpeed;
                    currentTime = addOperationalTime(currentTime, segmentHours, operationalHours, plannerSettings.excludedDays);
                }

                // 4. MAIN CALCULATION LOOP
                for (let i = 0; i < routeGauges.length; i++) {
                    const currentGauge = routeGauges[i];
                    const currentApiData = gaugeApiData[currentGauge.name];
                    let eta = new Date(currentTime.getTime());
                    let planDirection = 'downstream'; // Default

                    // Calculate travel time from previous point
                    if (i > 0) {
                        const prevGauge = routeGauges[i - 1];

                        // Check for special connection (e.g., canal)
                        const specialConnection = (prevGauge.connections || []).find(c => c.targetGaugeName === currentGauge.name && c.isCanal);

                        let travelHours = 0;
                        if (specialConnection) {
                             // MODIFIED: Use the adjustable canal speed from planner settings
                             if (plannerSettings.speedCanal > 0) {
                                 travelHours = specialConnection.distance / plannerSettings.speedCanal;
                             }
                        } else {
                            const distance = Math.abs(currentGauge.km - prevGauge.km);
                            // Determine direction for this specific segment
                            if (currentGauge.river === 'Donau') {
                                planDirection = currentGauge.km < prevGauge.km ? 'downstream' : 'upstream';
                            } else {
                                planDirection = currentGauge.km > prevGauge.km ? 'downstream' : 'upstream';
                            }
                            const speed = planDirection === 'downstream' ? plannerSettings.speedDownstream : plannerSettings.speedUpstream;
                            if (speed > 0) travelHours = distance / speed;
                        }

                        eta = addOperationalTime(currentTime, travelHours, operationalHours, plannerSettings.excludedDays);
                    } else {
                         eta = addOperationalTime(currentTime, 0, operationalHours, plannerSettings.excludedDays);
                    }
                    currentTime = new Date(eta.getTime());


                    // Find forecast level for the calculated ETA
                    let forecastLevel = null, forecastTimeStr = 'N/A', forecastUncertainty = null, forecastSource = '', isCurrentLevelUsed = false;

                    if (i === 0 && startDateTime <= now && currentApiData?.currentLevel !== null) {
                        forecastLevel = currentApiData.currentLevel;
                        forecastTimeStr = currentApiData.currentTime || t('now');
                        forecastSource = 'current';
                        isCurrentLevelUsed = true;
                    } else {
                        const forecast = getForecastForDateTime(currentApiData, eta);
                        if (forecast) {
                            forecastLevel = forecast.value;
                            forecastTimeStr = forecast.time;
                            forecastSource = forecast.source;
                            forecastUncertainty = forecast.uncertainty;
                        }
                    }

                    // Calculate draft and corrected rule for this segment's direction
                    const draftAtEta = calculateDraft(currentGauge, forecastLevel, planDirection);
                    const correctedRule = calculateCustomRuleOfThumbDisplay(currentGauge, planDirection);

                    if (draftAtEta !== null && draftAtEta < overallMinDraft) {
                        overallMinDraft = draftAtEta;
                        criticalPointInfo = { name: currentGauge.name, km: currentGauge.km, draft: draftAtEta, eta: eta };
                    }

                    let draftUncertaintyText = '';
                     if (showUncertainty && draftAtEta !== null && !isCurrentLevelUsed) {
                        if (forecastUncertainty) {
                            const draftLow = calculateDraft(currentGauge, forecastUncertainty.low, planDirection);
                            const draftHigh = calculateDraft(currentGauge, forecastUncertainty.high, planDirection);
                            if (draftLow !== null && draftHigh !== null && !isNaN(draftLow) && !isNaN(draftHigh)) {
                                draftUncertaintyText = `(${Math.min(draftLow, draftHigh).toFixed(0)}–${Math.max(draftLow, draftHigh).toFixed(0)} cm)`;
                            }

                        } else if (forecastSource === 'daily' && forecastLevel !== null) {
                            const etaDateStr = eta.toISOString().split('T')[0];
                            const uncertaintyCm = calculateForecastUncertainty(currentGauge, etaDateStr, now);
                            if (uncertaintyCm !== null) {
                                const draftLow = calculateDraft(currentGauge, forecastLevel - uncertaintyCm, planDirection);
                                const draftHigh = calculateDraft(currentGauge, forecastLevel + uncertaintyCm, planDirection);
                                if (draftLow !== null && draftHigh !== null && !isNaN(draftLow) && !isNaN(draftHigh)) {
                                    draftUncertaintyText = `(${Math.min(draftLow, draftHigh).toFixed(0)}–${Math.max(draftLow, draftHigh).toFixed(0)} cm*)`;
                                }
                            }
                        }
                    }

                    intermediatePoints.push({
                        name: currentGauge.name, km: currentGauge.km, eta: eta, forecastLevel: forecastLevel,
                        forecastTime: forecastTimeStr, forecastSource: forecastSource, draftAtEta: draftAtEta,
                        correctedRule: correctedRule, offset: '-', draftUncertaintyText: draftUncertaintyText,
                        notes: forecastLevel === null ? t('notesNoDataForEta') : (forecastSource === 'weekly' ? t('notesWeeklyForecast') : (forecastSource === 'current' ? t('notesCurrentLevel') : '')),
                        isCritical: false, gaugeRef: currentGauge
                    });
                }

                // --- Add Custom Segment calculation AFTER loop if position is 'end' ---
                if (plannerSettings.customSegmentPosition === 'end' && plannerSettings.customSegmentKm > 0 && plannerSettings.customSegmentSpeed > 0 && intermediatePoints.length > 0) {
                    const segmentHours = plannerSettings.customSegmentKm / plannerSettings.customSegmentSpeed;
                    const lastPoint = intermediatePoints[intermediatePoints.length - 1];
                    const finalEtaWithSegment = addOperationalTime(lastPoint.eta, segmentHours, operationalHours, plannerSettings.excludedDays);
                    lastPoint.eta = finalEtaWithSegment;
                    lastPoint.notes = (lastPoint.notes ? lastPoint.notes + '; ' : '') + `+${plannerSettings.customSegmentKm}km`;
                    if (criticalPointInfo && criticalPointInfo.name === lastPoint.name && criticalPointInfo.km === lastPoint.km) {
                        criticalPointInfo.eta = finalEtaWithSegment;
                    }
                }

                // --- Main-Danube Canal Draft Limit Check ---
                let finalOverallMinDraft = overallMinDraft;
                let limitReason = null; // To store a specific reason for the draft limit
                const routeContainsCanal = routeGauges.some((gauge, index) => {
                    if (index > 0) {
                        const prevGauge = routeGauges[index - 1];
                        return (prevGauge.name === 'Mainz' && gauge.name === 'Kelheim') ||
                               (prevGauge.name === 'Kelheim' && gauge.name === 'Mainz');
                    }
                    return false;
                });

                if (routeContainsCanal && finalOverallMinDraft > 250) {
                    finalOverallMinDraft = 250;
                    // The canal is the limiting factor
                    limitReason = { message: t('canalLimitReason') };
                }


                const finalRoutePoints = intermediatePoints.map(point => {
                    let finalOffset = '-';
                    if (point.forecastLevel !== null && !isNaN(Number(point.forecastLevel)) && finalOverallMinDraft !== Infinity) {
                        const offsetCalc = -point.forecastLevel + finalOverallMinDraft;
                        if (!isNaN(offsetCalc)) {
                            finalOffset = (offsetCalc >= 0 ? '+' : '') + offsetCalc.toFixed(0);
                        }
                    }
                    const isThisCritical = criticalPointInfo && point.name === criticalPointInfo.name && point.km === criticalPointInfo.km;
                     if (isThisCritical && criticalPointInfo) {
                        criticalPointInfo.uncertaintyText = point.draftUncertaintyText;
                        // Also update the critical point's draft if the overall draft was limited by the canal
                        criticalPointInfo.draft = finalOverallMinDraft;
                    }
                    return { ...point, offset: finalOffset, isCritical: isThisCritical };
                });

                let mgdWarning = null;
                const warnings = [];
                const routeContainsRiver = (riverName) => routeGauges.some(g => g.river === riverName);

                if (routeContainsRiver('Waal') && finalOverallMinDraft !== Infinity) {
                    const mgdStaticGauge = allGaugeStaticData.find(g => g.name === 'Spijk - Woudrichem');
                    const mgdApiData = gaugeApiData['Spijk - Woudrichem'];
                    if (mgdStaticGauge && mgdApiData && mgdApiData.currentLevel !== null) {
                        const allowableMgdDraft = calculateDraft(mgdStaticGauge, mgdApiData.currentLevel, 'downstream'); // Assume downstream for MGD
                        if (allowableMgdDraft !== null && finalOverallMinDraft > allowableMgdDraft) {
                            warnings.push(t('mgdWarningText', { calculatedDraft: finalOverallMinDraft.toFixed(0), mgdName: 'Spijk-Woudrichem', mgdDraft: allowableMgdDraft.toFixed(0) }));
                        }
                    }
                }
                 if (routeContainsRiver('IJssel') && finalOverallMinDraft !== Infinity) {
                     const relevantIJsselMgdNames = ['IJsselkop - Twenthekanaal', 'Twenthekanaal - Zwolle-IJsselkanaal'];
                     relevantIJsselMgdNames.forEach(mgdName => {
                         const mgdApiData = gaugeApiData[mgdName];
                         const mgdStaticGauge = allGaugeStaticData.find(g => g.name === mgdName);
                         if (mgdApiData && mgdApiData.currentLevel !== null && mgdStaticGauge) {
                             const allowableMgdDraft = calculateDraft(mgdStaticGauge, mgdApiData.currentLevel, 'downstream');
                             if (allowableMgdDraft !== null && finalOverallMinDraft > allowableMgdDraft) {
                                 warnings.push(t('mgdWarningText', { calculatedDraft: finalOverallMinDraft.toFixed(0), mgdName: mgdName, mgdDraft: allowableMgdDraft.toFixed(0) }));
                             }
                         }
                     });
                 }

                if (warnings.length > 0) {
                    mgdWarning = warnings.join(' ');
                }

                setRoutePlanResult({
                    points: finalRoutePoints,
                    overallMaxDraft: finalOverallMinDraft === Infinity ? null : finalOverallMinDraft,
                    criticalPoint: criticalPointInfo,
                    mgdWarning: mgdWarning,
                    limitReason: limitReason // Pass the reason to the result object
                });
                setRoutePlanStatus('calculated');

            } catch (error) {
                console.error("Error calculating route plan:", error);
                setRoutePlanResult({
                    points: [], overallMaxDraft: null, criticalPoint: null, mgdWarning: null,
                    error: error.message
                });
                setRoutePlanStatus('error');
            }
        }, [plannerSettings, journey, selectedRiver, allGaugeStaticData, gaugeApiData, calculateDraft, showUncertainty, customCorrections, calculateCustomRuleOfThumbDisplay, t]);

        // --- Effect to recalculate plan when uncertainty toggle changes ---
        useEffect(() => {
            if (routePlanStatus === 'calculated' && routePlanResult && !routePlanResult.error) {
                console.log("Re-calculating route plan due to uncertainty toggle change.");
                calculateRoutePlan(); // Recalculate to update uncertainty text in the table
            }
            // Only depends on showUncertainty and the calculate function itself
        }, [showUncertainty, calculateRoutePlan, routePlanStatus, routePlanResult]);


        // --- Render ---
        const giwLabel = selectedRiver === 'Donau' ? 'RNW' : 'GIW';
        const tuGiwLabel = selectedRiver === 'Donau' ? 'TuRNW' : 'TuGIW';

        return (
            <div className="container">
                {/* Fixed Header Container (Conditional) */}
                {activeTab !== 'planner' && (
                    <div className="fixed-header-container" ref={fixedHeaderContainerRef}>
                        <table ref={fixedHeaderTableRef}></table>
                    </div>
                )}

                {/* Header Controls Area */}
                <header className="controls-area">
                    <div className="controls-left">
                        <h1 style={{margin: '0 0 0.5rem 0', fontSize: '1.5rem'}}>{t('appTitle')}</h1>
                        
                        {/* I18N: Language Selector */}
                        <div className="control-group">
                            <label>{t('language')}:</label>
                            <select value={language} onChange={(e) => setLanguage(e.target.value)}>
                                <option value="nl">Nederlands</option>
                                <option value="en">English</option>
                                <option value="de">Deutsch</option>
                                <option value="fr">Français</option>
                                <option value="ru">Русский</option>
                            </select>
                        </div>

                        {/* Auto-refresh checkbox */}
                        <div className="control-group"><label><input type="checkbox" checked={autoRefresh}
                                                                     onChange={(e) => setAutoRefresh(e.target.checked)}/>{t('autoRefresh')}
                            ({REFRESH_INTERVAL_MS / 60000} min)</label> {autoRefresh && nextRefreshTime && <span
                            style={{
                                marginLeft: '8px',
                                fontSize: '0.8em',
                                color: '#aaa'
                            }}>{t('nextRefresh')}: {nextRefreshTime.toLocaleTimeString([], {
                            hour: '2-digit',
                            minute: '2-digit'
                        })}</span>} </div>

                        {/* --- UNIFIED RIVER SELECTOR --- */}
                        <div className="control-group">
                            <label>{t('contextRiver')}:</label>
                            <select value={selectedRiver} onChange={(e) => setSelectedRiver(e.target.value)}>
                                <option value="all">{t('allRivers')}</option>
                                <option value="Rijn/Waal">Rijn/Waal</option>
                                <option value="Donau">Donau</option>
                                <option value="IJssel">IJssel</option>
                            </select>
                        </div>

                        {/* --- MODIFIED: Journey Selection now uses gauge names --- */}
                        <div className="control-group">
                            <label>{t('journey')}:</label>
                            <select value={journey[selectedRiver]?.start ?? ''}
                                    onChange={(e) => handleJourneyChange('start', e.target.value)}>
                                <option value="">{t('selectStart')}</option>
                                {allGaugeStaticData
                                    .filter(g => g.river !== 'MGD' && g.name !== 'Konstanz' && g.name !== 'Ingolstadt')
                                    .filter(g => {
                                        if (selectedRiver === 'Rijn/Waal') return g.isMainRoute;
                                        if (selectedRiver === 'all') return true;
                                        return g.river === selectedRiver;
                                    })
                                    .sort((a, b) => {
                                        if (selectedRiver === 'all') {
                                            const riverOrder = { 'Rijn': 1, 'Pannerdens Kanaal': 2, 'Waal': 3, 'IJssel': 4, 'Donau': 5, 'Nederrijn': 6, 'Lek': 7, 'Unknown': 99 };
                                            const riverA = a.river || 'Unknown';
                                            const riverB = b.river || 'Unknown';
                                            const orderA = riverOrder[riverA] || 99;
                                            const orderB = riverOrder[riverB] || 99;
                                            if (orderA !== orderB) return orderA - orderB;
                                            if (riverA === 'Donau') return b.km - a.km; // Descending for Danube
                                            return a.km - b.km; // Ascending for others
                                        }
                                        if (selectedRiver === 'Donau') return b.km - a.km; // Descending for Danube
                                        return a.km - b.km; // Ascending for others
                                    })
                                    .map(gauge => <option key={`start-${gauge.name}`} value={gauge.name}>
                                        {`${selectedRiver === 'all' ? gauge.river + ': ' : ''}${gauge.name} (${gauge.km})`}
                                    </option>)}
                            </select>
                            <span>{t('to')}</span>
                            <select value={journey[selectedRiver]?.end ?? ''}
                                    onChange={(e) => handleJourneyChange('end', e.target.value)}>
                                <option value="">{t('selectEnd')}</option>
                                {allGaugeStaticData
                                     .filter(g => g.river !== 'MGD' && g.name !== 'Konstanz' && g.name !== 'Ingolstadt')
                                     .filter(g => {
                                        if (selectedRiver === 'Rijn/Waal') return g.isMainRoute;
                                        if (selectedRiver === 'all') return true;
                                        return g.river === selectedRiver;
                                    })
                                    .sort((a, b) => {
                                        if (selectedRiver === 'all') {
                                            const riverOrder = { 'Rijn': 1, 'Pannerdens Kanaal': 2, 'Waal': 3, 'IJssel': 4, 'Donau': 5, 'Nederrijn': 6, 'Lek': 7, 'Unknown': 99 };
                                            const riverA = a.river || 'Unknown';
                                            const riverB = b.river || 'Unknown';
                                            const orderA = riverOrder[riverA] || 99;
                                            const orderB = riverOrder[riverB] || 99;
                                            if (orderA !== orderB) return orderA - orderB;
                                            if (riverA === 'Donau') return b.km - a.km; // Descending for Danube
                                            return a.km - b.km; // Ascending for others
                                        }
                                        if (selectedRiver === 'Donau') return b.km - a.km; // Descending for Danube
                                        return a.km - b.km; // Ascending for others
                                    })
                                    .map(gauge => <option key={`end-${gauge.name}`} value={gauge.name}>
                                        {`${selectedRiver === 'all' ? gauge.river + ': ' : ''}${gauge.name} (${gauge.km})`}
                                    </option>)}
                            </select>
                        </div>

                        {/* Display Mode & Uncertainty Toggle (only for main tabs) */}
                        {(activeTab === 'route' || activeTab === 'all') && (
                            <>
                                <div className="control-group"><label>{t('displayMode')}:</label>
                                    <div className="view-toggle-group"><label className="toggle-label"><input
                                        type="radio" value="draft" checked={displayMode === 'draft'}
                                        onChange={handleDisplayModeChange}/> {t('displayModeDraft')}</label> <label
                                        className="toggle-label"><input type="radio" value="level"
                                                                        checked={displayMode === 'level'}
                                                                        onChange={handleDisplayModeChange}/> {t('displayModeLevel')} </label></div>
                                </div>
                                <div className="control-group"><label className="toggle-label"> <input type="checkbox"
                                                                                                       checked={showUncertainty}
                                                                                                       onChange={handleUncertaintyToggle}/> {t('showUncertainty')} </label></div>
                            </>
                        )}
                        {/* Refresh Button & Data Status */}
                        <div className="control-group">
                            <button className="refresh-btn" onClick={() => handleRefresh(true)} ref={refreshButtonRef}
                                    disabled={dataStatus.status === 'pending'}> {dataStatus.status === 'pending' ? t('loading') : t('reloadData')} </button>
                            <div
                                className={`data-status ${dataStatus.status}`}> {dataStatus.message} {dataStatus.status !== 'pending' && lastUpdated ? `(${t('apiTime')}: ${lastUpdated.toLocaleTimeString(locale, {
                                hour: '2-digit',
                                minute: '2-digit'
                            })})` : ''} </div>
                        </div>
                    </div>

                    {/* Right Side Controls / Highlight Box (Contextual) */}
                    {activeTab === 'route' && (<div className="controls-right highlight-box">
                        <div style={{marginBottom: '6px', fontWeight: 'bold'}}>
                            {t('criticalDraftTitle', { direction: isMixedDirectionRoute ? t('directionMixed') : (travelDirection === 'downstream' ? t('directionDown') : t('directionUp')) })}:
                        </div>
                        <div><span className="label">{t('now')}:</span> <span
                            className="value">{criticalDraftValue !== null ? `${criticalDraftValue.toFixed(0)} cm` : 'N/A'}</span>
                            <span className="gauge">({criticalGaugeName || 'N/A'})</span> <span
                                className="time">({criticalApiDataForHighlight?.currentTime || 'N/A'})</span></div>
                        {forecastBottlenecks.map((forecast) => (
                            <div key={`forecast-bottleneck-${forecast.date}`}>
                                <span
                                    className="label">{new Date(forecast.date + 'T12:00:00Z').toLocaleDateString(locale, {
                                    weekday: 'short',
                                    day: 'numeric'
                                })}:</span>
                                <span
                                    className="value">{forecast.draft !== 'N/A' ? `${forecast.draft} cm` : 'N/A'}</span>
                                {showUncertainty && forecast.uncertainty && (
                                    <span className="forecast-uncertainty">{forecast.uncertainty}</span>
                                )}
                                <span className="gauge">({forecast.gauge || 'N/A'})</span>
                                <span className="time">({forecast.time || 'N/A'})</span>
                            </div>
                        ))}

                        {forecastDates.length > 0 && forecastBottlenecks.every(f => f.gauge === null) && dataStatus.status !== 'pending' &&
                            <div style={{fontSize: '0.85em', color: '#333', marginTop: '4px'}}>{t('noCriticalForecast')}</div>} {forecastDates.length === 0 && dataStatus.status !== 'pending' &&
                        <div style={{fontSize: '0.85em', color: '#333', marginTop: '4px'}}>{t('noForecastsAvailable')}</div>} {dataStatus.status === 'pending' &&
                        <div style={{fontSize: '0.85em', color: '#333', marginTop: '4px'}}>{t('loadingForecasts')}</div>}
                    </div>)}
                    {activeTab === 'all' && (
                        <div className="controls-right"><p style={{fontSize: '0.9em', color: '#aaa'}}>Alle beschikbare
                            peilingen en dieptes.</p></div>)}
                    {activeTab === 'planner' && (
                        <div className="controls-right"><p style={{fontSize: '0.9em', color: '#aaa'}}>Stel de
                            routeplanner in en bereken de maximaal mogelijke diepgang voor de reis.</p></div>)}
                </header>

                {/* Main Content Area */}
                <div className="main-content">
                    {/* Tabs */}
                    <div className="tab-controls">
                        <button className={`tab-button ${activeTab === 'route' ? 'active' : ''}`}
                                onClick={() => handleTabChange('route')}>{t('tabMaxDraft')}
                        </button>
                        <button className={`tab-button ${activeTab === 'planner' ? 'active' : ''}`}
                                onClick={() => handleTabChange('planner')}>{t('tabPlanner')}
                        </button>
                        <button className={`tab-button ${activeTab === 'all' ? 'active' : ''}`}
                                onClick={() => handleTabChange('all')}>{t('tabAllData')}
                            ({displayedGaugeData.length})
                        </button>
                    </div>

                    {/* Content based on Active Tab */}

                    {/* --- Max Draft & All Data Tabs Content --- */}
                    {(activeTab === 'route' || activeTab === 'all') && (
                        <div className="table-area-padding">
                            <div className="header-sentinel" ref={sentinelRef}></div>
                            <div className="table-scroll-wrapper" ref={scrollWrapperRef}>
                                {/* Main data table */}
                                <table className="original-table" ref={originalTableRef}>
                                    <thead ref={originalTheadRef}>
                                    {/* Header rows */}
                                    <tr>
                                        <th rowSpan="2">{t('headerRiver')}</th>
                                        <th rowSpan="2">{t('headerSection')}</th>
                                        <th rowSpan="2">{t('headerName')}</th>
                                        <th rowSpan="2" className="numeric">{giwLabel}<br/><span
                                            style={{fontSize: '0.85em', fontWeight: 'normal'}}>{t('headerUnitCm')}</span></th>
                                        <th rowSpan="2" className="numeric">{tuGiwLabel}<br/><span
                                            style={{fontSize: '0.85em', fontWeight: 'normal'}}>{t('headerUnitCm')}</span></th>
                                        <th rowSpan="2" className="numeric"> {t('headerValue')} <br/> <span
                                            style={{fontSize: '0.85em', fontWeight: 'normal'}}>{t('headerUnitActual')}</span></th>
                                        <th rowSpan="2" className="numeric">{t('headerTrend')}<br/> <span
                                            style={{fontSize: '0.85em', fontWeight: 'normal'}}>(24h)</span></th>
                                        <th rowSpan="2" className="numeric">{t('headerOfficialRule')}<br/><span
                                            style={{fontSize: '0.85em', fontWeight: 'normal'}}>{t('headerUnitCm')}</span></th>
                                        <th colSpan="2" className="center">{t('headerCorrection')}</th>
                                        <th colSpan="2" className="center">{t('headerAdjRule')} <br/> {t('headerUnitCm')}</th>
                                        <th rowSpan="2"
                                            className="numeric"> {displayMode === 'draft' ? t('headerActualDraft') : t('headerActualLevel')} <br/>
                                            <span style={{fontSize: '0.85em', fontWeight: 'normal'}}>{t('headerUnitActual')}</span>
                                        </th>
                                        {/* Forecast Headers */}
                                        {forecastDates.map(dateStr => (
                                            <th key={`forecast-hdr-${dateStr}`} rowSpan="2"
                                                className="numeric forecast-header">
                                                {new Date(dateStr + 'T12:00:00Z').toLocaleDateString(locale, {
                                                    weekday: 'short',
                                                    day: 'numeric'
                                                })} <br/>
                                                <span style={{
                                                    fontSize: '0.85em',
                                                    fontWeight: 'normal'
                                                }}> {t('headerForecastValue', { mode: displayMode === 'draft' ? 'D' : 'S' })} </span>
                                            </th>
                                        ))}
                                        {forecastDates.length === 0 && dataStatus.status !== 'pending' &&
                                            <th rowSpan="2" className="forecast-header">{t('noForecasts')}</th>}
                                    </tr>
                                    <tr>
                                        <th className="numeric">{t('headerUp')}</th>
                                        <th className="numeric">{t('headerDown')}</th>
                                        <th className="numeric">{t('headerUp')}</th>
                                        <th className="numeric">{t('headerDown')}</th>
                                    </tr>
                                    </thead>
                                    <tbody>
                                    {/* Loading/No Data Messages */}
                                    {dataStatus.status === 'pending' && (<tr>
                                        <td colSpan={13 + Math.max(1, forecastDates.length)}
                                            style={{textAlign: 'center', fontStyle: 'italic', padding: '1rem'}}>{t('loading')}
                                        </td>
                                    </tr>)}
                                    {dataStatus.status !== 'pending' && displayedGaugeData.length === 0 && (<tr>
                                        <td colSpan={13 + Math.max(1, forecastDates.length)} style={{
                                            textAlign: 'center',
                                            fontStyle: 'italic',
                                            padding: '1rem'
                                        }}> {activeTab === 'route' ? t('noDataForSelection') : (Object.keys(gaugeApiData).length === 0 ? t('noApiData') : t('noDataForFilter'))} </td>
                                    </tr>)}
                                    {/* Table Body Rows */}
                                    {displayedGaugeData.map(gauge => {
                                        const apiData = gauge.apiData;
                                        // BUG FIX: The line "if (!apiData) return null;" was removed from here.
                                        // Now, rows will render even if their API data is missing.
                                        const isCritical = activeTab === 'route' && gauge.name === criticalGaugeName;
                                        const currentLevel = apiData?.currentLevel;
                                        const currentTime = apiData?.currentTime || 'N/A';
                                        const currentTrend = apiData?.currentTrend ?? '-';
                                        const officialRuleDisplay = calculateOfficialRuleOfThumb(gauge);
                                        const customRuleDisplayUp = calculateCustomRuleOfThumbDisplay(gauge, 'upstream');
                                        const customRuleDisplayDown = calculateCustomRuleOfThumbDisplay(gauge, 'downstream');
                                        const currentActualDraft = currentLevel !== null ? calculateDraft(gauge, currentLevel, gauge.segmentDirection) : null;
                                        const currentLevelDisplay = currentLevel;
                                        let lastColumnClass = "numeric ";
                                        let lastColumnValue = '-';
                                        if (displayMode === 'draft') {
                                            lastColumnClass += 'actual-draft-column';
                                            if (currentActualDraft !== null) {
                                                lastColumnValue = currentActualDraft.toFixed(0);
                                                if (isCritical) lastColumnClass += ' critical-actual-draft';
                                            }
                                        } else { /* actual-level-column class removed */
                                            if (currentLevelDisplay !== null) {
                                                lastColumnValue = currentLevelDisplay.toFixed(0);
                                                if (isCritical) lastColumnClass += ' critical-actual-level';
                                            }
                                        }
                                        let levelColumnClass = 'numeric';
                                        if (currentLevelDisplay !== null && isCritical) levelColumnClass += ' critical-level';

                                        return (
                                            <tr key={`${gauge.name}-${gauge.km ?? gauge.streckenAbschnitt ?? apiData?.apiName}`}
                                                className={isCritical ? 'critical-row' : ''}>
                                                {/* Cols 1-8 */}
                                                <td>{gauge.river || 'N/A'}</td>
                                                <td>{gauge.streckenAbschnitt || 'N/A'}</td>
                                                <td><a href={getGaugeUrl(gauge)} target="_blank"
                                                       rel="noopener noreferrer" className="gauge-link">{gauge.name}</a>
                                                </td>
                                                <td className="numeric">{gauge.giw !== 'N/A' ? gauge.giw : '-'}</td>
                                                <td className="numeric">{gauge.depthAtGiw !== 'N/A' ? gauge.depthAtGiw : '-'}</td>
                                                <td className={levelColumnClass}> {currentLevelDisplay !== null ? currentLevelDisplay.toFixed(0) : (apiData?.status === 'ERROR' ? `Error` : '-')}
                                                    <div
                                                        className="time-display">{currentTime !== 'N/A' ? currentTime : (apiData?.status ? '' : t('loading'))}</div>
                                                </td>
                                                <td className="numeric">{currentTrend}</td>
                                                <td className="numeric">{officialRuleDisplay}</td>
                                                {/* Corrections Inputs (Cols 9-10) */}
                                                <td className="numeric"><input type="number"
                                                                               value={customCorrections.upstream[gauge.name] ?? ''}
                                                                               onChange={(e) => handleCorrectionChange('upstream', gauge.name, e.target.value)}/>
                                                </td>
                                                <td className="numeric"><input type="number"
                                                                               value={customCorrections.downstream[gauge.name] ?? ''}
                                                                               onChange={(e) => handleCorrectionChange('downstream', gauge.name, e.target.value)}/>
                                                </td>
                                                {/* Adjusted Rules (Cols 11-12) */}
                                                <td className="numeric">{customRuleDisplayUp}</td>
                                                <td className="numeric">{customRuleDisplayDown}</td>
                                                {/* Actual Draft/Level (Col 13) */}
                                                <td className={lastColumnClass}> {lastColumnValue} {lastColumnValue !== '-' &&
                                                    <div
                                                        className="time-display">{currentTime !== 'N/A' ? currentTime : ''}</div>} </td>
                                                {/* Forecast Columns (Col 14+) */}
                                                {forecastDates.map(dateStr => {
                                                    let forecastDisplayValue = '-';
                                                    let forecastDisplayTime = '';
                                                    let uncertaintyText = '';
                                                    let valueSource = '';
                                                    let foundWeeklySlot = null;
                                                    const forecastsForDate = apiData?.forecasts?.[dateStr];
                                                    // Daily Forecast Check
                                                    if (forecastsForDate && Object.keys(forecastsForDate).length > 0) {
                                                        const selectedTime = getBestForecastTime(forecastsForDate, currentTime);
                                                        const forecastSlot = selectedTime ? forecastsForDate[selectedTime] : null;
                                                        if (forecastSlot && forecastSlot.value !== undefined && forecastSlot.value !== null) {
                                                            const forecastLevel = forecastSlot.value;
                                                            forecastDisplayTime = selectedTime;
                                                            valueSource = 'daily';
                                                            let calculatedFcValue = (displayMode === 'draft') ? calculateDraft(gauge, forecastLevel, gauge.segmentDirection) : forecastLevel;
                                                            forecastDisplayValue = calculatedFcValue !== null ? calculatedFcValue.toFixed(0) : '-';
                                                            if (showUncertainty && calculatedFcValue !== null) {
                                                                if (forecastSlot.low_80 !== null && forecastSlot.high_80 !== null) {
                                                                    let lowVal = forecastSlot.low_80;
                                                                    let highVal = forecastSlot.high_80;
                                                                    if (displayMode === 'draft') {
                                                                        lowVal = calculateDraft(gauge, forecastSlot.low_80, gauge.segmentDirection);
                                                                        highVal = calculateDraft(gauge, forecastSlot.high_80, gauge.segmentDirection);
                                                                    }
                                                                    if (lowVal !== null && !isNaN(lowVal) && highVal !== null && !isNaN(highVal)) {
                                                                        uncertaintyText = `(${Math.min(lowVal, highVal).toFixed(0)}–${Math.max(lowVal, highVal).toFixed(0)})`;
                                                                    } else uncertaintyText = '(Bereik N/A)';
                                                                    // NEW CODE
                                                                } else {
                                                                    const now = new Date();
                                                                    const uncertaintyCm = calculateForecastUncertainty(gauge, dateStr, now);
                                                                    if (uncertaintyCm !== null) {
                                                                        uncertaintyText = `(±${uncertaintyCm} cm)`;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    // Weekly Forecast Fallback
                                                    if (forecastDisplayValue === '-' && Array.isArray(apiData?.weeklyForecasts) && apiData.weeklyForecasts.length > 0) { /* ... weekly fallback logic ... */
                                                        const targetDate = new Date(dateStr + 'T12:00:00Z');
                                                        for (const weeklyForecast of apiData.weeklyForecasts) {
                                                            if (weeklyForecast.weekRange && weeklyForecast.median !== null) {
                                                                try {
                                                                    const [startStr, endStr] = weeklyForecast.weekRange.split('-');
                                                                    const [startDay, startMonth, startYear] = startStr.split('.');
                                                                    const [endDay, endMonth, endYear] = endStr.split('.');
                                                                    const startDate = new Date(Date.UTC(startYear, startMonth - 1, startDay, 0, 0, 0));
                                                                    const endDate = new Date(Date.UTC(endYear, endMonth - 1, endDay, 23, 59, 59));
                                                                    if (!isNaN(startDate.getTime()) && !isNaN(endDate.getTime()) && targetDate >= startDate && targetDate <= endDate) {
                                                                        const forecastLevel = weeklyForecast.median;
                                                                        let calculatedFcValue = (displayMode === 'draft') ? calculateDraft(gauge, forecastLevel, gauge.segmentDirection) : forecastLevel;
                                                                        if (calculatedFcValue !== null) {
                                                                            forecastDisplayValue = calculatedFcValue.toFixed(0);
                                                                            forecastDisplayTime = "(BfG6W)";
                                                                            valueSource = 'weekly';
                                                                            foundWeeklySlot = weeklyForecast;
                                                                            break;
                                                                        }
                                                                    }
                                                                } catch (e) { /* ... */
                                                                }
                                                            }
                                                        }
                                                    }
                                                    // Weekly Uncertainty
                                                    if (valueSource === 'weekly' && showUncertainty && foundWeeklySlot) { /* ... weekly uncertainty logic ... */
                                                        if (foundWeeklySlot.low_90 !== null && foundWeeklySlot.high_90 !== null) {
                                                            let lowVal = foundWeeklySlot.low_90;
                                                            let highVal = foundWeeklySlot.high_90;
                                                            if (displayMode === 'draft') {
                                                                lowVal = calculateDraft(gauge, foundWeeklySlot.low_90, gauge.segmentDirection);
                                                                highVal = calculateDraft(gauge, foundWeeklySlot.high_90, gauge.segmentDirection);
                                                            }
                                                            if (lowVal !== null && !isNaN(lowVal) && highVal !== null && !isNaN(highVal)) {
                                                                uncertaintyText = `(${Math.min(lowVal, highVal).toFixed(0)}–${Math.max(lowVal, highVal).toFixed(0)})`;
                                                            } else uncertaintyText = '(Bereik N/A)';
                                                        }
                                                    }
                                                    return (<td key={`forecast-${gauge.name}-${dateStr}`}
                                                                className="numeric forecast-cell"> {forecastDisplayValue !== '-' ? (
                                                        <div> {forecastDisplayValue} {showUncertainty && uncertaintyText && (
                                                            <span
                                                                className="uncertainty-display">{uncertaintyText}</span>)} {forecastDisplayTime && (
                                                            <div
                                                                className={`time-display ${valueSource === 'weekly' ? 'weekly' : ''}`}>{forecastDisplayTime}</div>)} </div>) : ('-')} </td>);
                                                })}
                                                {forecastDates.length === 0 && dataStatus.status !== 'pending' &&
                                                    <td className="forecast-cell">-</td>}
                                            </tr>
                                        );
                                    })}
                                    </tbody>
                                </table>
                            </div>
                            {/* End .table-scroll-wrapper */}
                        </div> // End .table-area-padding
                    )}


                    {/* --- Route Planner Tab Content --- */}
                    {activeTab === 'planner' && (
                        <div className="table-area-padding">
                            {/* Planner Settings Form */}
<div className="planner-settings-group">


                                <h3>{t('plannerSettingsTitle')}</h3>


                                {/* Start Date/Time */}
                                <div className="control-group"><label htmlFor="startDate">{t('departureTime')}:</label>
                                    <input type="datetime-local" id="startDate" value={plannerSettings.startDate}
                                           onChange={(e) => handlePlannerSettingChange('startDate', e.target.value)}/>
                                    <button onClick={handleSetNow} className="now-button">{t('now')}</button>
                                </div>

                                {/* Speeds */}
                                <div className="control-group"><label htmlFor="speedDownstream">{t('speedDownstream')}:</label> <input type="number" id="speedDownstream" min="1"
                                                           value={plannerSettings.speedDownstream}
                                                           onChange={(e) => handlePlannerSettingChange('speedDownstream', Number(e.target.value))}/>
                                </div>

                                <div className="control-group"><label htmlFor="speedUpstream">{t('speedUpstream')}:</label> <input type="number" id="speedUpstream" min="1"
                                                           value={plannerSettings.speedUpstream}
                                                           onChange={(e) => handlePlannerSettingChange('speedUpstream', Number(e.target.value))}/>
                                </div>

                                <div className="control-group"><label htmlFor="speedCanal">{t('speedCanal')}:</label>
                                    <input type="number" id="speedCanal" min="1" step="0.1"
                                           style={{width: "70px"}}
                                           value={plannerSettings.speedCanal}
                                           onChange={(e) => handlePlannerSettingChange('speedCanal', Number(e.target.value))}/>
                                    <span style={{fontSize: '0.8em', color: '#aaa', marginLeft: '0.5rem'}}>{t('speedCanalHint')}</span>
                                </div>

                                {/* Operational Mode */}
                                <div className="control-group"><label htmlFor="operationalMode">{t('system')}:</label>
                                    <select id="operationalMode" value={plannerSettings.operationalMode}
                                            onChange={handleOperationalModeChange}>
                                        <option value="A1">{t('systemA1')}</option>
                                        <option value="A2">{t('systemA2')}</option>
                                        <option value="B">{t('systemB')}</option>
                                        <option value="Custom">{t('systemCustom')}</option>
                                    </select> {plannerSettings.operationalMode === 'Custom' && (
                                        <input type="number" min="1" max="24" step="0.5"
                                               style={{width: "60px", marginLeft: "0.5rem"}}
                                               aria-label="Custom operational hours"
                                               value={plannerSettings.customOperationalHours}
                                               onChange={(e) => handlePlannerSettingChange('customOperationalHours', Number(e.target.value))}/>)} {plannerSettings.operationalMode !== 'Custom' && (
                                        <span style={{
                                            fontSize: '0.85em',
                                            color: '#aaa',
                                            marginLeft: '0.5rem'
                                        }}> ({plannerSettings.operationalMode === 'A1' ? 14 : (plannerSettings.operationalMode === 'A2' ? 18 : 24)} {t('hoursPerDay')}) </span>)}
                                </div>
                                {/* Excluded Days */}
                                <div className="control-group"><label>{t('excludedDays')}:</label>
                                    <div className="excluded-days-group"> {weekdays.map((day, index) => (
                                        <label key={day} className="day-label"> <input type="checkbox"
                                                                                       checked={plannerSettings.excludedDays.includes(index)}
                                                                                       onChange={(e) => handleExcludedDayChange(index, e.target.checked)}/> {day}
                                        </label>))} </div>
                                </div>
                                {/* Uncertainty Toggle for Planner */}
                                <div className="control-group"><label htmlFor="showUncertaintyPlanner"
                                                                      className="toggle-label">{t('showUncertaintyPlanner')}:</label> <input type="checkbox" id="showUncertaintyPlanner"
                                                                checked={showUncertainty}
                                                                onChange={handleUncertaintyToggle}/> <span
                                    style={{fontSize: '0.8em', color: '#aaa'}}>{t('ifAvailable')}</span></div>

                                {/* --- NEW Custom Segment Inputs --- */}
                                <div style={{borderTop: '1px solid #444', paddingTop: '1rem', marginTop: '1rem'}}>
                                    <h4>{t('optionalSegment')}</h4>
                                    <div className="control-group">
                                        <label htmlFor="customSegmentKm">{t('extraDistance')}:</label>
                                        <input
                                            type="number"
                                            id="customSegmentKm"
                                            min="0"
                                            step="1"
                                            style={{width: "70px"}}
                                            value={plannerSettings.customSegmentKm}
                                            onChange={(e) => handlePlannerSettingChange('customSegmentKm', Number(e.target.value))}
                                        />
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="customSegmentSpeed">{t('extraSpeed')}:</label>
                                        <input
                                            type="number"
                                            id="customSegmentSpeed"
                                            min="0" // Allow 0, calculation logic handles divide by zero if km > 0
                                            step="0.5"
                                            style={{width: "70px"}}
                                            value={plannerSettings.customSegmentSpeed}
                                            onChange={(e) => handlePlannerSettingChange('customSegmentSpeed', Number(e.target.value))}
                                        />
                                    </div>
                                    <div className="control-group">
                                        <label htmlFor="customSegmentPosition">{t('extraPosition')}:</label>
                                        <select
                                            id="customSegmentPosition"
                                            value={plannerSettings.customSegmentPosition}
                                            onChange={(e) => handlePlannerSettingChange('customSegmentPosition', e.target.value)}
                                        >
                                            <option value="end">{t('posAfter')}</option>
                                            <option value="start">{t('posBefore')}</option>
                                        </select>
                                        <span style={{fontSize: '0.8em', color: '#aaa', marginLeft: '0.5rem'}}>{t('posHint')}</span>
                                    </div>
                                </div>
                                {/* End Custom Segment Inputs */}

                                {/* Calculate Button */}
                                <div className="control-group" style={{marginTop: '1rem'}}>
                                    <button
                                        className="planner-calculate-btn"
                                        onClick={calculateRoutePlan}
                                            // MODIFIED: Check for journey start/end name
                                        disabled={routePlanStatus === 'calculating' || !journey[selectedRiver]?.start || !journey[selectedRiver]?.end}
                                    >
                                        {routePlanStatus === 'calculating' ? t('calculating') : t('calculateMaxDraft')}
                                    </button>
                                </div>
                            </div>
                            {/* End Planner Settings Group */}

                            {/* --- Planner Results Display --- */}
                            {/* Error Message */}
                            {routePlanStatus === 'error' && routePlanResult?.error && (<div style={{
                                color: '#ff6666',
                                marginTop: '1rem',
                                border: '1px solid red',
                                padding: '0.5rem'
                            }}> {t('calculationError', { error: routePlanResult.error })} </div>)}

                            {/* Calculated Results */}
                            {routePlanStatus === 'calculated' && routePlanResult && !routePlanResult.error && (
                                <div className="route-plan-results">
                                    <h4>{t('plannerResultTitle')}</h4>
                                    {/* Summary: Max Draft and Critical Point */}

                                    <div className="route-plan-summary">
                                        {t('maxPossibleDraft')}: <strong>{routePlanResult.overallMaxDraft !== null ? `${routePlanResult.overallMaxDraft.toFixed(0)} cm` : 'N/A'}</strong>
                                        {/* NEW: Prioritize the specific limit reason over the generic critical point */}
                                        {routePlanResult.limitReason ? (
                                            <span style={{ fontSize: '0.9em', color: '#ccc' }}>
                                                 ({t('limitedBy')}: {routePlanResult.limitReason.message})
                                            </span>
                                        ) : routePlanResult.criticalPoint ? (
                                            <span style={{ fontSize: '0.9em', color: '#ccc' }}>
                                                 ({t('limitedBy')}: {routePlanResult.criticalPoint.name} op KM {routePlanResult.criticalPoint.km}
                                                {showUncertainty && routePlanResult.criticalPoint.uncertaintyText ? ` ${routePlanResult.criticalPoint.uncertaintyText}` : ''})
                                            </span>
                                        ) : null}
                                    </div>
                                    {/* MGD Warning */}
                                    {routePlanResult.mgdWarning && (
                                        <div className="mgd-warning"> {routePlanResult.mgdWarning} </div>)}

                                    {/* Route Details Table */}
                                    <h5>{t('routeDetails')}:</h5>
                                    {/* Scroll Wrapper for the table */}
                                    <div className="table-scroll-wrapper">
                                        <table className="original-table">
                                            <thead>
                                            <tr>
                                                {/* Adjusted headers for new column */}
                                                <th>{t('plannerHeaderKm')}</th>
                                                <th>{t('plannerHeaderName')}</th>
                                                <th>{t('plannerHeaderEta')}</th>
                                                <th>{t('plannerHeaderForecastLevel')}</th>
                                                <th>{t('plannerHeaderOffset')}</th>
                                                {/* NEW Header for Corrected Rule */}
                                                <th>{t('plannerHeaderAdjRule')}</th>
                                                <th>{t('plannerHeaderMaxDraft')}</th>
                                                <th>{t('plannerHeaderNotes')}</th>
                                            </tr>
                                            </thead>
                                            <tbody>
                                            {/* Message if no points calculated */}
                                            {routePlanResult.points.length === 0 && (<tr>
                                                <td colSpan="8" style={{textAlign: 'center', fontStyle: 'italic'}}>{t('noRoutePoints')}
                                                </td>
                                            </tr>)}
                                            {/* Iterate through calculated points */}
                                            {routePlanResult.points.map((point, index) => (
                                                <tr key={`${point.name}-${point.km}-${index}`}
                                                    className={point.isCritical ? 'critical-route-point' : ''}>
                                                    {/* Data Cells */}
                                                    <td className="numeric">{point.km}</td>
                                                    <td><a href={getGaugeUrl(point.gaugeRef)} target="_blank"
                                                           rel="noopener noreferrer"
                                                           className="gauge-link">{point.name}</a></td>
                                                    <td className="eta-time">
                                                        {point.eta.toLocaleDateString(locale, {
                                                            weekday: 'short',
                                                            day: 'numeric',
                                                            month: 'short'
                                                        })} {' '}
                                                        {point.eta.toLocaleTimeString(locale, {
                                                            hour: '2-digit',
                                                            minute: '2-digit'
                                                        })}
                                                    </td>
                                                    <td className="numeric">
                                                        {point.forecastLevel !== null ? point.forecastLevel.toFixed(0) : '-'}
                                                        {point.forecastTime && point.forecastTime !== 'N/A' && (
                                                            <div
                                                                className={`time-display ${point.forecastSource === 'weekly' ? 'weekly' : (point.forecastSource === 'current' ? 'current' : '')}`}>{point.forecastTime}</div>
                                                        )}
                                                    </td>
                                                    {/* Offset Value */}
                                                    <td className="offset-value numeric"> {point.offset} </td>
                                                    {/* NEW Data Cell for Corrected Rule */}
                                                    <td className="numeric"> {point.correctedRule !== 'N/A' && !isNaN(Number(point.correctedRule)) ? Number(point.correctedRule).toFixed(0) : (point.correctedRule === 'N/A' ? '-' : point.correctedRule)} </td>
                                                    {/* Max Draft Value */}
                                                    <td className="numeric">
                                                        {point.draftAtEta !== null ? point.draftAtEta.toFixed(0) : '-'}
                                                        {showUncertainty && point.draftUncertaintyText && (
                                                            <span className="uncertainty-display"
                                                                  style={{textAlign: 'right'}}>{point.draftUncertaintyText}</span>)}
                                                    </td>
                                                    {/* Notes */}
                                                    <td>{point.notes}</td>
                                                </tr>
                                            ))}
                                            </tbody>
                                        </table>
                                    </div>
                                    {/* End table-scroll-wrapper for results */}
                                </div> // End route-plan-results
                            )}
                        </div> // End .table-area-padding for planner
                    )}

                </div>
                {/* End .main-content */}

                {/* Footer */}
                <footer>
                    <div>{t('footerApiDate')}: {lastUpdated ? lastUpdated.toLocaleString(locale, {
                        dateStyle: 'short',
                        timeStyle: 'short'
                    }) : t('notLoadedYet')}</div>
                    <div>RDD Calculator &copy; FilipJFZ</div>
                </footer>
            </div> // End .container
        );
    }
    // --- Render the App ---
    // I18N: Wrap the main component in the I18nProvider
    ReactDOM.render(
        <I18nProvider>
            <RhineDraftCalculator/>
        </I18nProvider>, 
        document.getElementById('root')
    );

</script>
</body>
</html>
