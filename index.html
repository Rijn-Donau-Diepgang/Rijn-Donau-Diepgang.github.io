<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rijn diepgang calculator - Compact Auto Width Header</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.21.2/babel.min.js"></script>
<style>
    /* --- Base & Layout (Combined & Adjusted) --- */
    html, body { margin: 0; padding: 0; }
    body {
        margin: 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        color: white;
        background-color: #121212;
        min-height: 150vh; /* Ensure enough scroll height for testing */
    }

    .container {
        display: flex;
        flex-direction: column;
        width: 100%;
        min-height: 100vh;
    }

    /* --- Header Controls Area (from index5) --- */
    header.controls-area {
        background-color: #1e1e1e;
        padding: 1rem;
        border-bottom: 1px solid #333;
        flex-shrink: 0;
        z-index: 20; /* Ensure it's above potential fixed header during transition */
        position: relative; /* Keep stacking context */
        min-height: 100px; /* Approximate height */
         /* Layout from index5 */
         display: flex;
         flex-wrap: wrap;
         justify-content: space-between;
         align-items: flex-start;
         gap: 1rem;
    }
    .controls-left { flex: 2; min-width: 400px; display: flex; flex-direction: column; gap: 0.5rem; }
    .controls-left > div { margin-bottom: 0.5rem; }
    .controls-left > div:last-child { margin-bottom: 0; }
    .controls-right { flex: 1; min-width: 300px; max-width: 500px; align-self: flex-start; }
    .control-group { display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap; }
    .control-group label { display: flex; align-items: center; gap: 0.3rem; }
    select, input, button { background-color: #2a2a2a; color: white; border: 1px solid #444; padding: 0.5rem; border-radius: 4px; font-size: 0.9rem; }
    input[type="number"] { width: 50px; text-align: right; padding: 0.4rem; } /* Slightly smaller */
    input[type="checkbox"], input[type="radio"] { width: auto; margin-right: 0.3rem; accent-color: #4da6ff; }
    button { cursor: pointer; }
    .view-toggle-group label { margin-right: 1rem; cursor: pointer; }
    .view-toggle-group input[type="radio"] { margin-right: 0.3rem; }

    /* --- Main Content Area --- */
    .main-content {
        display: flex;
        flex-direction: column;
        flex-grow: 1;
        padding: 0; /* Padding will be inside */
    }

    /* --- Tab Controls (from index5) --- */
    .tab-controls {
        margin-bottom: 1rem;
        border-bottom: 1px solid #333;
        padding: 1rem 1rem 0.5rem 1rem;
        background-color: #121212; /* Match body */
        flex-shrink: 0;
        position: relative; /* Keep stacking context */
        z-index: 15; /* Below controls, above table */
    }
    .tab-button { background-color: #2a2a2a; border: 1px solid #444; padding: 0.5rem 1rem; margin-right: 0.5rem; border-radius: 4px 4px 0 0; cursor: pointer; }
    .tab-button.active { background-color: #3a3a3a; border-bottom: 1px solid #3a3a3a; font-weight: bold; }
    .tab-button:disabled { background-color: #222; color: #666; cursor: not-allowed; border-color: #333; }

    /* --- Table Area Structures (from index6) --- */
    .table-area-padding { /* Renamed from table-container in index5 */
        padding: 0 1rem 1rem 1rem; /* Apply padding here */
        width: 100%;
        box-sizing: border-box;
        flex-grow: 1; /* Allow it to take space */
        display: flex; /* Use flex to make wrapper fill it */
        flex-direction: column; /* Stack sentinel and wrapper */
    }
    .header-sentinel {
        height: 1px; /* Trigger for IntersectionObserver */
        /* No background or visible height needed */
        flex-shrink: 0;
    }
    .table-scroll-wrapper {
        overflow-x: auto; /* Handle horizontal scroll */
        overflow-y: visible; /* Allow content height to determine wrapper height */
        width: 100%;     /* Take full width of the padding container */
        -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        flex-grow: 1; /* Take remaining space */
        display: block; /* Needed for overflow to work correctly with flex parent */
        flex-shrink: 0; /* Prevent shrinking */
    }

    /* --- Original Table (Combined & Adjusted) --- */
    table.original-table {
        width: 100%; /* Ensure it fills wrapper horizontally */
        border-collapse: collapse;
        border-spacing: 0;
        background-color: #1a1a1a; /* Table background */
        table-layout: fixed; /* KEY CHANGE: Use fixed layout instead of auto */
    }

    /* --- Original Table Header / Visibility (from index6) --- */
    .original-table > thead {
        visibility: visible; /* Default state */
        /* REMOVED position: sticky */
    }
    .original-table > thead.hidden {
        visibility: hidden !important; /* Hide when fixed header is active */
    }

    /* --- Original Header Cells (thead th) - Base Styles & Compactness --- */
    .original-table > thead th {
        background-color: #1e1e1e; /* Header background */
        border-bottom: 1px solid #555;
        padding: 0.5rem 0.4rem; /* <<< REDUCED PADDING */
        text-align: left;
        white-space: nowrap; /* Keep header text on one line */
        overflow: visible; /* Allow content to flow for auto sizing */
        text-overflow: clip;
        border-left: 1px solid #333;
        vertical-align: middle;
        font-size: 0.8rem; /* <<< REDUCED FONT SIZE */
        font-weight: bold;
        line-height: 1.2; /* Adjust line height for smaller font */
        /* REMOVED position: sticky and top */
    }
    .original-table > thead th:first-child { border-left: none; }
    .original-table > thead th.numeric { text-align: right; }
    .original-table > thead th.center { text-align: center; }
    .original-table > thead tr:first-child th { border-top: 1px solid #555; }

    /* --- Define Column Width Variables --- */
:root {
    /* Default width */
    --col-default-width: 60px;

    /* Column-specific widths */
    --col-1-width: 70px;  /* Rivier */
    --col-2-width: 50px; /* Strecke */
    --col-3-width: 80px; /* Naam */
    --col-4-width: 45px;  /* GIW */
    --col-5-width: 45px;  /* TuGIW */
    --col-6-width: 45px;  /* Waarde Actueel */
    --col-7-width: 45px;  /* Tendens */
    --col-8-width: 65px;  /* Off. Vuist */
    --col-9-width: 150px; /* Correctie Op */
    --col-10-width: 100px; /* Correctie Af */
    --col-11-width: 65px; /* Aang. Vuist Op */
    --col-12-width: 45px; /* Aang. Vuist Af */
    --col-13-width: 100px; /* Diepgang/Waarde Actueel */
    --forecast-width: 45px; /* Forecast Columns */
}

/* --- Default Column Settings --- */
.original-table > thead th,
.fixed-header-container th,
.original-table > tbody td {
    min-width: var(--col-default-width);
    width: auto;
}

/* --- Column Width Definitions (Applied to both header and body) --- */
/* Column 1 - Rivier */
.original-table > thead th:nth-child(1),
.fixed-header-container th:nth-child(1),
.original-table > tbody td:nth-child(1) {
    min-width: var(--col-1-width);
    width: var(--col-1-width);
    max-width: var(--col-2-width);
}

/* Column 2 - Strecke */
.original-table > thead th:nth-child(2),
.fixed-header-container th:nth-child(2),
.original-table > tbody td:nth-child(2) {
    min-width: var(--col-2-width);
    width: var(--col-2-width);
    max-width: var(--col-2-width);
}

/* Column 3 - Naam */
.original-table > thead th:nth-child(3),
.fixed-header-container th:nth-child(3),
.original-table > tbody td:nth-child(3) {
    min-width: var(--col-3-width);
    width: var(--col-3-width);
    max-width: var(--col-3-width);
}

/* Column 4 - GIW */
.original-table > thead th:nth-child(4),
.fixed-header-container th:nth-child(4),
.original-table > tbody td:nth-child(4) {
    min-width: var(--col-4-width);
    width: var(--col-4-width);
}

/* Column 5 - TuGIW */
.original-table > thead th:nth-child(5),
.fixed-header-container th:nth-child(5),
.original-table > tbody td:nth-child(5) {
    min-width: var(--col-5-width);
    width: var(--col-5-width);
}

/* Column 6 - Waarde Actueel */
.original-table > thead th:nth-child(6),
.fixed-header-container th:nth-child(6),
.original-table > tbody td:nth-child(6) {
    min-width: var(--col-6-width);
    width: var(--col-6-width);
}

/* Column 7 - Tendens */
.original-table > thead th:nth-child(7),
.fixed-header-container th:nth-child(7),
.original-table > tbody td:nth-child(7) {
    min-width: var(--col-7-width);
    width: var(--col-7-width);
}

/* Column 8 - Off. Vuist */
.original-table > thead th:nth-child(8),
.fixed-header-container th:nth-child(8),
.original-table > tbody td:nth-child(8) {
    min-width: var(--col-8-width);
    width: var(--col-8-width);
    max-width: var(--col-8-width);
}

/* Column 9 - Correctie Op */
.original-table > thead th:nth-child(9),
.fixed-header-container th:nth-child(9),
.original-table > tbody td:nth-child(9) {
    min-width: var(--col-9-width);
    width: var(--col-9-width);
    max-width: var(--col-9-width);
}

/* Column 10 - Correctie Af */
.original-table > thead th:nth-child(10),
.fixed-header-container th:nth-child(10),
.original-table > tbody td:nth-child(10) {
    min-width: var(--col-10-width);
    width: var(--col-10-width);
    max-width: var(--col-10-width);
}

/* Column 11 - Aang. Vuist Op */
.original-table > thead th:nth-child(11),
.fixed-header-container th:nth-child(11),
.original-table > tbody td:nth-child(11) {
    min-width: var(--col-11-width);
    width: var(--col-11-width);
    max-width: var(--col-11-width);
}

/* Column 12 - Aang. Vuist Af */
.original-table > thead th:nth-child(12),
.fixed-header-container th:nth-child(12),
.original-table > tbody td:nth-child(12) {
    min-width: var(--col-12-width);
    width: var(--col-12-width);
    max-width: var(--col-12-width);
}

/* Column 13 - Diepgang/Waarde Actueel */
.original-table > thead th:nth-child(13),
.fixed-header-container th:nth-child(13),
.original-table > tbody td:nth-child(13) {
    min-width: var(--col-13-width);
    width: var(--col-13-width);
    max-width: var(--col-13-width);
}

/* Forecast Columns */
.original-table > thead th.forecast-header,
.fixed-header-container th.forecast-header,
.original-table > tbody td.forecast-cell {
    min-width: var(--forecast-width);
    width: var(--forecast-width);
}

/* Optional: Text handling for certain columns */
.original-table > tbody td:nth-child(11),
.original-table > tbody td:nth-child(12) {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}


    /* --- Body Cells (tbody td) - Base Styles & Compactness --- */
    .original-table > tbody td {
        padding: 0.5rem 0.4rem; /* <<< REDUCED PADDING */
        text-align: left;
        border-bottom: 1px solid #333;
        white-space: normal; /* Allow wrapping */
        border-left: 1px solid #333;
        vertical-align: middle;
        font-size: 0.85rem; /* <<< REDUCED FONT SIZE */
        line-height: 1.3;
    }
    .original-table > tbody td:first-child { border-left: none; }
    .original-table > tbody td.numeric { text-align: right; }
    .original-table > tbody td.center { text-align: center; }
    .original-table > tbody tr:hover td { background-color: #2a2a2a; }



    /* Optional: Text handling for fixed columns */
    .original-table > tbody td:nth-child(11),
    .original-table > tbody td:nth-child(12) {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    /* --- Fixed Header Clone Container (from index6) --- */
    .fixed-header-container {
        position: fixed;
        top: 0; /* Stick to viewport top */
        left: 0; /* Will be adjusted by JS */
        z-index: 100; /* Above everything else */
        overflow: hidden; /* Hide horizontal overflow, scroll handled by JS */
        visibility: hidden; /* Hidden by default */
        background-color: #1e1e1e; /* Match header background */
        box-shadow: 0 2px 5px rgba(0,0,0,0.3); /* Visual separation */
        /* width will be set by JS */
    }
    .fixed-header-container.visible {
        visibility: visible; /* Show when active */
    }
    .fixed-header-container table {
        table-layout: fixed; /* <<< KEY: Match original table */
        border-collapse: collapse;
        border-spacing: 0;
        background-color: transparent; /* Container has background */
        width: 100%; /* Take full width */
    }

    /* --- Cloned Header Cells (thead th) - MIRROR Original Styles & Compactness --- */
    .fixed-header-container th {
        background-color: #1e1e1e;
        border-bottom: 1px solid #555;
        padding: 0.5rem 0.4rem; /* <<< REDUCED PADDING (Mirrored) */
        text-align: left;
        white-space: nowrap;
        overflow: visible;
        text-overflow: clip;
        border-left: 1px solid #333;
        vertical-align: middle;
        font-size: 0.8rem; /* <<< REDUCED FONT SIZE (Mirrored) */
        font-weight: bold;
        line-height: 1.2; /* <<< (Mirrored) */
        border-top: none; /* Fixed header doesn't need top border initially */
    }
    .fixed-header-container th:first-child { border-left: none; }
    .fixed-header-container th.numeric { text-align: right; }
    .fixed-header-container th.center { text-align: center; }
    .fixed-header-container thead tr:first-child th { border-top: 1px solid #555; } /* Add top border like original */



    /* --- Highlights & Cell Content Styling (Adjusted for smaller text) --- */
    .critical-row td { background-color: rgba(255, 0, 0, 0.2) !important; }
    .critical-draft { font-weight: bold; color: #ff6666; }
    .critical-level { font-weight: bold; color: #ffb3b3; }
    .actual-draft-column { font-weight: bold; }
    .actual-level-column { }
    .critical-actual-draft { font-weight: bold; color: #ff4d4d; }
    .critical-actual-level { font-weight: bold; color: #ff9999; }
    .forecast-cell div { line-height: 1.2; } /* Slightly tighter line height */
    .uncertainty-display { font-size: 0.75em; color: #aaa; margin-top: 2px; display: block; } /* Smaller */
    .time-display { font-size: 0.75em; color: #aaa; font-weight: normal; margin-top: 3px; display: block; line-height: 1.1; } /* Smaller */
    .time-display.weekly { font-style: italic; color: #ccc; }
    .gauge-link { color: #4da6ff; text-decoration: none; }
    .gauge-link:hover { text-decoration: underline; }

    /* --- Footer & Misc (Adjusted for smaller text) --- */
    footer {
        background-color: #1e1e1e;
        padding: 0.8rem 1rem; /* Slightly smaller padding */
        font-size: 0.8rem; /* Slightly smaller font */
        display: flex;
        justify-content: space-between;
        border-top: 1px solid #333;
        flex-shrink: 0;
        margin-top: auto; /* Push to bottom */
    }
    /* Highlight box adjustments - minor */
    .highlight-box { background-color: #cc9900; border-radius: 4px; padding: 0.5rem 1rem; color: black; font-weight: bold; border: 1px solid #997300; }
    .highlight-box div { margin-bottom: 3px; line-height: 1.3; } /* Tighter line height */
    .highlight-box span.label { display: inline-block; min-width: 60px; padding-right: 5px; font-size: 0.9em; } /* Slightly smaller */
    .highlight-box span.value { display: inline-block; min-width: 55px; font-size: 0.9em;} /* Slightly smaller */
    .highlight-box span.gauge { font-size: 0.8em; color: #333; margin-left: 4px; }
    .highlight-box span.time { font-size: 0.75em; color: #555; margin-left: 4px; }
    .highlight-box .forecast-uncertainty { font-size: 0.8em; color: #333; font-weight: normal; display: block; margin-left: 65px; margin-top: -2px; margin-bottom: 3px; } /* Adjusted margin */
    /* Data status adjustments */
    .data-status { padding: 0.4rem 0.8rem; background-color: #333; border-radius: 4px; font-size: 0.8rem; border-left: 4px solid #555; display: inline-block; margin-left: 0.5rem; }
    .data-status.pending { background-color: #444; border-left-color: #aaa; }
    .data-status.success { background-color: #004d00; border-left-color: #00cc66; }
    .data-status.warning { background-color: #665200; border-left-color: #ffcc00; }
    .data-status.error { background-color: #660000; border-left-color: #ff6666; }
    .refresh-btn { background-color: #0066cc; padding: 0.4rem 0.8rem; cursor: pointer; font-size: 0.85rem; } /* Smaller */
    .refresh-btn:hover { background-color: #0055aa; }
    .refresh-btn:disabled { background-color: #444; cursor: not-allowed; }
</style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
    const {useState, useEffect, useCallback, useRef, useMemo} = React;

    // --- Constants --- (Copied from index5)
    const API_URL = 'https://rdd-backend.vercel.app/api/data';
    const REFRESH_INTERVAL_MS = 10 * 60 * 1000;
    const DEFAULT_DEPTH_SAFETY_MARGIN = 0;
    const MAX_FORECAST_DAYS = 8;
    const MAIN_ROUTE_RIVERS = ['Rijn', 'Waal'];

    // --- Cookie Utilities --- (Copied from index5)
    function setCookie(name, value, days = 3650) { const date = new Date(); date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000)); const expires = `expires=${date.toUTCString()}`; document.cookie = `${name}=${JSON.stringify(value)};${expires};path=/;SameSite=Lax`; }
    function getCookie(name) { const nameEQ = `${name}=`; const ca = document.cookie.split(';'); for (let i = 0; i < ca.length; i++) { let c = ca[i]; while (c.charAt(0) === ' ') c = c.substring(1, c.length); if (c.indexOf(nameEQ) === 0) { try { return JSON.parse(c.substring(nameEQ.length, c.length)); } catch (e) { console.error("Error parsing cookie:", name, e); return null; } } } return null; }

    // --- API Fetch Function --- (Copied from index5)
    async function fetchConsolidatedData(force = false) {
        const url = `${API_URL}?t=${Date.now()}`;
        console.log(`Fetching data from: ${url}`);
        try {
            const response = await fetch(url); if (!response.ok) { let errorText = `API request failed: ${response.status}`; try { const errorBody = await response.json(); errorText += ` - ${errorBody.error || JSON.stringify(errorBody)}`; } catch (parseError) { try { const textBody = await response.text(); errorText += ` - ${textBody.substring(0, 200)}`; } catch (readError) {} } throw new Error(errorText); } const data = await response.json(); console.log("API Data Received:", Object.keys(data).length, "gauges"); return data; } catch (error) { console.error("Error fetching consolidated data:", error); throw error; } }

    // --- Helper Functions --- (Copied from index5)
    function formatTimeDisplay(timeString) { /* ... same as index5 ... */ if (!timeString || typeof timeString !== 'string') return "N/A"; if (timeString.length === 5 && timeString.includes(':')) return timeString; if (timeString.includes(' ') && timeString.includes(':')) { const timePart = timeString.split(' ')[1]; if (timePart && timePart.length >= 5) return timePart.substring(0,5); } try { const date = new Date(timeString); if (!isNaN(date.getTime())) return date.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' }); } catch(e) {} return timeString || "N/A"; }
    function getBestForecastTime(timesObject, referenceTime = null) { /* ... same as index5 ... */ if (!timesObject || typeof timesObject !== 'object' || Object.keys(timesObject).length === 0) return null; const times = Object.keys(timesObject).filter(t => t.match(/^\d{2}:\d{2}$/)); if (times.length === 0) return null; const sortedTimes = [...times].sort(); if (!referenceTime || !referenceTime.includes(':') || referenceTime === "N/A") return sortedTimes[0]; const refTimeFormatted = formatTimeDisplay(referenceTime); if (refTimeFormatted === "N/A") return sortedTimes[0]; const [refH] = refTimeFormatted.split(':').map(Number); let bestMatch = sortedTimes[0]; let minDiff = Infinity; let exactHourMatch = null; for (const time of sortedTimes) { const [h] = time.split(':').map(Number); if (h === refH) { exactHourMatch = time; break; } } if (exactHourMatch) return exactHourMatch; const refTotalMins = refH * 60 + Number(refTimeFormatted.split(':')[1]); for (const time of sortedTimes) { const [h, m] = time.split(':').map(Number); const totalMins = h * 60 + m; const diff = Math.abs(totalMins - refTotalMins); if (diff < minDiff) { minDiff = diff; bestMatch = time; } } return bestMatch; }
    function getGaugeUrl(gauge) { /* ... same as index5 ... */ if (!gauge) return '#'; const gaugeName = gauge.name; const gaugeRiver = gauge.river; const gaugeRegion = gauge.region || gauge.apiData?.region; if (gaugeRiver === 'Depth' || (gaugeRegion && gaugeRegion.includes('depths'))) return `https://www.vaarweginformatie.nl/frp/main/#/hydro/mgd`; const dutchGaugeUrlCodes = { 'Nijmegen': 'Nijmegen-haven(NIJM)', 'Tiel': 'Tiel-Waal(TIEW)', 'Pannerdense kop': 'Pannerdense-kop(PANN)', 'IJsselkop': 'IJsselkop(IJSS)', 'Doesburg': 'Doesburg-brug(DOES)', 'Deventer': 'Deventer(DEVE)', 'Katerveer': 'Katerveer(KATV)' }; const germanGaugeIds = { 'Konstanz': '00007', 'Iffezheim': '09137', 'Maxau': '09016', 'Speyer': '09017', 'Mannheim': '09001', 'Worms': '09018' }; const rlpGaugeUrls = { 'Mainz': 'https://www.hochwasser.rlp.de/flussgebiet/mittelrhein/mainz', 'Bingen': 'https://www.hochwasser.rlp.de/flussgebiet/mittelrhein/bingen', 'Andernach': 'https://www.hochwasser.rlp.de/flussgebiet/mittelrhein/andernach', 'Bonn': 'https://www.hochwasser.rlp.de/flussgebiet/mittelrhein/bonn', 'Wesel': 'https://www.hochwasser.rlp.de/flussgebiet/niederrhein/wesel' }; if (rlpGaugeUrls[gaugeName]) return rlpGaugeUrls[gaugeName]; if (gaugeName === 'Lobith') return 'https://www.rijkswaterstaat.nl/water/waterdata-en-waterberichtgeving/waterdata/lobith-waterstanden-en-afvoeren'; if (germanGaugeIds[gaugeName]) return `https://www.hvz.baden-wuerttemberg.de/pegel.html?id=${germanGaugeIds[gaugeName]}`; if (dutchGaugeUrlCodes[gaugeName] || (gaugeRegion && gaugeRegion.includes('dutch'))) { const urlCode = dutchGaugeUrlCodes[gaugeName] || encodeURIComponent(gaugeName); return `https://waterinfo.rws.nl/publiek/waterhoogte/${urlCode}/details`; } const elwisNameBase = gauge.apiDataName || gauge.name || ''; const elwisName = elwisNameBase.toUpperCase().replace(/ /g, '_'); if (elwisName) return `https://www.elwis.de/DE/dynamisch/Wasserstaende/Pegelvorhersage:${elwisName}`; return '#'; }
    function diffDays(dateStr1, dateStr2) { /* ... same as index5 ... */ try { const date1 = new Date(Date.UTC(parseInt(dateStr1.substring(0, 4)), parseInt(dateStr1.substring(5, 7)) - 1, parseInt(dateStr1.substring(8, 10)), 12, 0, 0)); const date2 = new Date(Date.UTC(parseInt(dateStr2.substring(0, 4)), parseInt(dateStr2.substring(5, 7)) - 1, parseInt(dateStr2.substring(8, 10)), 12, 0, 0)); if (isNaN(date1.getTime()) || isNaN(date2.getTime())) return NaN; return Math.round((date2 - date1) / (1000 * 60 * 60 * 24)); } catch (e) { console.error("Error calculating date difference:", dateStr1, dateStr2, e); return NaN; } }

    // --- React Component ---
    function RhineDraftCalculator() {
        // State (Copied from index5)
        const [allGaugeStaticData, setAllGaugeStaticData] = useState([]);
        const [gaugeApiData, setGaugeApiData] = useState({});
        const [customCorrections, setCustomCorrections] = useState({ upstream: {}, downstream: {} });
        const [forecastDates, setForecastDates] = useState([]);
        const [dataStatus, setDataStatus] = useState({ status: 'pending', message: 'Initializing...' });
        const [lastUpdated, setLastUpdated] = useState(null);
        const [travelDirection, setTravelDirection] = useState('downstream');
        const [autoRefresh, setAutoRefresh] = useState(true);
        const [nextRefreshTime, setNextRefreshTime] = useState(null);
        const refreshButtonRef = useRef(null);
        const [journey, setJourney] = useState(() => getCookie('rhineDraftJourney') || { start: 914, end: 0 });
        const [activeTab, setActiveTab] = useState('route');
        const [displayMode, setDisplayMode] = useState('draft');
        const [showUncertainty, setShowUncertainty] = useState(false);

        // Refs for Fixed Header (from index6)
        const sentinelRef = useRef(null);
        const scrollWrapperRef = useRef(null);
        const originalTableRef = useRef(null);
        const originalTheadRef = useRef(null);
        const fixedHeaderContainerRef = useRef(null);
        const fixedHeaderTableRef = useRef(null);
        const isHeaderFixedRef = useRef(false);

        // --- Effects ---
        // Static data load effect (Copied from index5)
        useEffect(() => {
            setDataStatus({ status: 'pending', message: 'Loading static gauge definitions...' });
             const combinedStaticList = [ /* ... Static List from index5 ... */
                { name: 'Konstanz', km: 0, river: 'Rijn', streckenAbschnitt: '0-1', giw: 0, depthAtGiw: 0, officialSafetyMargin: 0, correctionOp: 0, correctionAf: 0 },
                { name: 'Iffezheim', km: 334, river: 'Rijn', streckenAbschnitt: '334-384', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 10, correctionAf: 20, customVuistregel: 80 },
                { name: 'Maxau', km: 362, river: 'Rijn', streckenAbschnitt: '335-384', giw: 372, depthAtGiw: 210, officialSafetyMargin: 30, correctionOp: 12, correctionAf: 12 },
                { name: 'Speyer', km: 400, river: 'Rijn', streckenAbschnitt: '384-410.5', giw: 237, depthAtGiw: 210, officialSafetyMargin: 30, correctionOp: 27, correctionAf: 27 },
                { name: 'Mannheim', km: 424, river: 'Rijn', streckenAbschnitt: '410.5-431.5', giw: 155, depthAtGiw: 210, officialSafetyMargin: 30, correctionOp: 30, correctionAf: 30 },
                { name: 'Worms', km: 443, river: 'Rijn', streckenAbschnitt: '431.5-462', giw: 68, depthAtGiw: 210, officialSafetyMargin: 30, correctionOp: 33, correctionAf: 33 },
                { name: 'Mainz', km: 498, river: 'Rijn', streckenAbschnitt: '462-508', giw: 171, depthAtGiw: 210, officialSafetyMargin: 30, correctionOp: 11, correctionAf: 11 },
                { name: 'Oestrich', km: 518, river: 'Rijn', streckenAbschnitt: '508-528', giw: 92, depthAtGiw: 190, officialSafetyMargin: 30, correctionOp: 42, correctionAf: 42 },
                { name: 'Bingen', km: 528, river: 'Rijn', streckenAbschnitt: '528-540', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 0, customVuistregel: 100 },
                { name: 'Kaub', km: 546, river: 'Rijn', streckenAbschnitt: '541-566', giw: 77, depthAtGiw: 190, officialSafetyMargin: 30, correctionOp: 17, correctionAf: 27 },
                { name: 'Koblenz', km: 591, river: 'Rijn', streckenAbschnitt: '566-592', giw: 77, depthAtGiw: 210, officialSafetyMargin: 30, correctionOp: 27, correctionAf: 27 },
                { name: 'Koblenz (Mosel)', apiDataName: 'Koblenz', km: 592, river: 'Rijn', streckenAbschnitt: '592-601', giw: 77, depthAtGiw: 250, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Andernach', km: 613, river: 'Rijn', streckenAbschnitt: '601-624', giw: 91, depthAtGiw: 250, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Bonn', km: 655, river: 'Rijn', streckenAbschnitt: '624-660', giw: 142, depthAtGiw: 250, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Köln', km: 688, river: 'Rijn', streckenAbschnitt: '660-710', giw: 139, depthAtGiw: 250, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 9 },
                { name: 'Düsseldorf', km: 744, river: 'Rijn', streckenAbschnitt: '710-763', giw: 91, depthAtGiw: 250, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Duisburg-Ruhrort', km: 780, river: 'Rijn', streckenAbschnitt: '763-794', giw: 227, depthAtGiw: 280, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Wesel', km: 814, river: 'Rijn', streckenAbschnitt: '794-837', giw: 174, depthAtGiw: 280, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Emmerich', km: 852, river: 'Rijn', streckenAbschnitt: '837-857', giw: 74, depthAtGiw: 280, officialSafetyMargin: 30, correctionOp: 0, correctionAf: 0 },
                { name: 'Lobith', km: 862, river: 'Rijn', streckenAbschnitt: '857-867.5', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 0, customVuistregel: -478 },
                { name: 'Nijmegen', km: 883, river: 'Waal', streckenAbschnitt: '867.5-893', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 0, customVuistregel: -260 },
                { name: 'Tiel', km: 914, river: 'Waal', streckenAbschnitt: '893-930', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 0, customVuistregel: 10 },
                { name: 'Pannerdense kop', km: 867, river: 'Pannerdens Kanaal', streckenAbschnitt: 'PK 867.5-878.6', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 0, customVuistregel: -485 },
                { name: 'IJsselkop', km: 878, river: 'IJssel', streckenAbschnitt: 'IJ 867-903', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 10, correctionAf: 20, customVuistregel: -480 },
                { name: 'Doesburg', km: 903, river: 'IJssel', streckenAbschnitt: 'IJ 903-931', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 10, correctionAf: 20, customVuistregel: -200 },
                { name: 'Deventer', km: 931, river: 'IJssel', streckenAbschnitt: 'IJ 931-981', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 10, customVuistregel: 90 },
                { name: 'Katerveer', km: 981, river: 'IJssel', streckenAbschnitt: 'IJ 981-1005', giw: 'N/A', depthAtGiw: 'N/A', officialSafetyMargin: 'N/A', correctionOp: 0, correctionAf: 10, customVuistregel: 270 },
                { name: 'Spijk - Woudrichem', km: 931, river: 'Depth', streckenAbschnitt: 'Waal km 930-951', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'Millingen tot Maas-Waalkanaal', km: 867, river: 'Depth', streckenAbschnitt: 'Waal (deeltraject)', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'Maas-Waalkanaal tot Amsterdam-Rijnkanaal', km: 895, river: 'Depth', streckenAbschnitt: 'Waal (deeltraject)', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'Amsterdam-Rijnkanaal tot Loevestein', km: 925, river: 'Depth', streckenAbschnitt: 'Waal (deeltraject)', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'Pannerdensche Kop - IJsselkop', km: 878, river: 'Depth', streckenAbschnitt: 'Pannerdensch Kanaal', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'IJsselkop - Driel', km: 884, river: 'Depth', streckenAbschnitt: 'Nederrijn km 878-884', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'Driel - Heteren', km: 888, river: 'Depth', streckenAbschnitt: 'Nederrijn km 884-888', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'Heteren - A\'dam-Rijnkanaal', km: 905, river: 'Depth', streckenAbschnitt: 'Nederrijn km 888-905', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'A\'dam-Rijnkanaal - Hagestein', km: 922, river: 'Depth', streckenAbschnitt: 'Lek km 905-922', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'IJsselkop - Twenthekanaal', km: 921, river: 'Depth', streckenAbschnitt: 'IJssel km 878-921', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'Uitvaartdiepte Oostsluis Weurt', km: 886, river: 'Depth', streckenAbschnitt: 'Oostsluis Weurt', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 },
                { name: 'Uitvaartdiepte Westsluis Weurt', km: 886.1, river: 'Depth', streckenAbschnitt: 'Westsluis Weurt', officialSafetyMargin: DEFAULT_DEPTH_SAFETY_MARGIN, correctionOp: 0, correctionAf: 0 }
             ];
             const processedStaticData = combinedStaticList
                 .map(g => ({ ...g, giw: g.giw ?? 'N/A', depthAtGiw: g.depthAtGiw ?? 'N/A', officialSafetyMargin: g.officialSafetyMargin === undefined ? 'N/A' : g.officialSafetyMargin, isMainRoute: MAIN_ROUTE_RIVERS.includes(g.river) }))
                 .sort((a, b) => { const riverOrder = { 'Rijn': 1, 'Pannerdens Kanaal': 2, 'Waal': 3, 'Nederrijn': 4, 'Lek': 5, 'IJssel': 6, 'Depth': 7, 'Unknown': 99 }; const riverA = a.river || 'Unknown'; const riverB = b.river || 'Unknown'; const orderA = riverOrder[riverA] || 99; const orderB = riverOrder[riverB] || 99; if (orderA !== orderB) return orderA - orderB; const kmA = a.km === undefined || a.km === null ? Infinity : a.km; const kmB = b.km === undefined || b.km === null ? Infinity : b.km; return kmA - kmB; });
             setAllGaugeStaticData(processedStaticData);
             const defaultCorrections = { upstream: {}, downstream: {} };
             processedStaticData.forEach(gauge => { defaultCorrections.upstream[gauge.name] = gauge.correctionOp === undefined ? 0 : gauge.correctionOp; defaultCorrections.downstream[gauge.name] = gauge.correctionAf === undefined ? 0 : gauge.correctionAf; });
             const savedCorrections = getCookie('rhineDraftCorrections');
             const mergedCorrections = { upstream: { ...defaultCorrections.upstream, ...(savedCorrections?.upstream || {}) }, downstream: { ...defaultCorrections.downstream, ...(savedCorrections?.downstream || {}) } };
             setCustomCorrections(mergedCorrections);
             setDataStatus({ status: 'success', message: 'Static data loaded.' });
        }, []);

        // API data load effect (Copied from index5, slight modifications for forecastDates)
        const loadGaugeApiData = useCallback(async (force = false) => {
            setDataStatus({ status: 'pending', message: 'Data ophalen van API...' });
            if (refreshButtonRef.current) refreshButtonRef.current.disabled = true;
            try {
                const apiResponse = await fetchConsolidatedData(force);
                const newApiData = {}; const allDatesInForecast = new Set();
                let successfulUpdates = 0; let apiGaugeCount = 0; let warningMessages = []; let errorMessages = [];
                let overallStatus = 'success'; let latestApiTimestamp = 0;
                const todayDate = new Date();
                const nlYear = todayDate.toLocaleDateString('en-CA', { year: 'numeric', timeZone: 'Europe/Amsterdam' });
                const nlMonth = todayDate.toLocaleDateString('en-CA', { month: '2-digit', timeZone: 'Europe/Amsterdam' });
                const nlDay = todayDate.toLocaleDateString('en-CA', { day: '2-digit', timeZone: 'Europe/Amsterdam' });
                const todayStr = `${nlYear}-${nlMonth}-${nlDay}`;

                apiGaugeCount = Object.keys(apiResponse).length;
                Object.entries(apiResponse).forEach(([apiGaugeName, data]) => {
                     if (data.status === 'OK' || data.status === 'WARNING') successfulUpdates++;
                     else if (data.status?.startsWith('CACHED')) { successfulUpdates++; if (data.status !== 'CACHED' && data.status !== 'CACHED_UNCHANGED') { warningMessages.push(`${apiGaugeName}: ${data.status} (${data.error || 'stale/partial'})`); if (overallStatus !== 'error') overallStatus = 'warning'; } }
                     else { errorMessages.push(`${apiGaugeName}: ${data.error || data.status || 'Unknown error'}`); overallStatus = 'error'; }
                     if (data.error && data.status !== 'ERROR' && !data.status?.startsWith('CACHED')) { warningMessages.push(`${apiGaugeName}: ${data.error}`); if (overallStatus !== 'error') overallStatus = 'warning'; }
                     if (data.lastUpdated) { try { const t = new Date(data.lastUpdated).getTime(); if (!isNaN(t) && t > latestApiTimestamp) latestApiTimestamp = t; } catch (e) {} }
                });

                allGaugeStaticData.forEach(staticGauge => {
                    const apiLookupKey = staticGauge.apiDataName || staticGauge.name;
                    const rawData = apiResponse[apiLookupKey];
                    const displayKey = staticGauge.name;
                    if (rawData) {
                        const processedForecasts = {};
                        if (rawData.forecasts) {
                             Object.entries(rawData.forecasts).forEach(([dateStr, timeEntries]) => {
                                if (dateStr >= todayStr) {
                                    const validTimeEntries = {};
                                    Object.entries(timeEntries).forEach(([timeStr, forecastData]) => {
                                        if (timeStr.match(/^\d{2}:\d{2}$/) && forecastData && forecastData.value !== undefined && forecastData.value !== null) {
                                             validTimeEntries[timeStr] = { value: forecastData.value, low_80: forecastData.low_80 ?? null, high_80: forecastData.high_80 ?? null };
                                        }
                                    });
                                    if (Object.keys(validTimeEntries).length > 0) {
                                        processedForecasts[dateStr] = validTimeEntries;
                                        // We'll generate forecastDates state later based on today
                                    }
                                }
                            });
                        }
                        newApiData[displayKey] = {
                            apiName: apiLookupKey, currentLevel: rawData.currentLevel ?? null, currentTime: formatTimeDisplay(rawData.currentTime || rawData.lastUpdated),
                            currentTrend: rawData.currentTrend ?? null,
                            forecasts: processedForecasts,
                            weeklyForecasts: rawData.weeklyForecasts ?? null,
                            status: rawData.status || 'ERROR', error: rawData.error || null,
                            river: staticGauge.river || rawData.river || 'Unknown', region: staticGauge.region || rawData.region || 'unknown', source: rawData.source || { measurement: null, forecast: null },
                            lastUpdated: rawData.lastUpdated || null, giw: staticGauge.giw, depthAtGiw: staticGauge.depthAtGiw,
                            officialSafetyMargin: staticGauge.officialSafetyMargin, customVuistregel: staticGauge.customVuistregel
                        };
                    }
                });

                setGaugeApiData(newApiData);

                // Generate forecastDates state (consistent with index5 and index6)
                const futureDates = [];
                let currentDate = new Date(todayStr + 'T12:00:00Z'); // Use UTC noon to avoid DST issues
                for (let i = 0; i < MAX_FORECAST_DAYS; i++) {
                     const year = currentDate.getUTCFullYear();
                     const month = String(currentDate.getUTCMonth() + 1).padStart(2, '0');
                     const day = String(currentDate.getUTCDate()).padStart(2, '0');
                     futureDates.push(`${year}-${month}-${day}`);
                     currentDate.setUTCDate(currentDate.getUTCDate() + 1);
                }
                setForecastDates(futureDates); // Update state here

                setLastUpdated(latestApiTimestamp > 0 ? new Date(latestApiTimestamp) : new Date());
                let finalMessage = `Data bijgewerkt (${successfulUpdates}/${apiGaugeCount} API bronnen)`;
                if (overallStatus === 'error') finalMessage = `Fout bij bijwerken (${errorMessages.length} mislukt). ${errorMessages.length > 0 ? `Eerste: ${errorMessages[0]}` : ''}`;
                else if (overallStatus === 'warning') finalMessage = `Deels bijgewerkt (${warningMessages.length} waarschuwingen). ${warningMessages.length > 0 ? `Eerste: ${warningMessages[0]}` : ''}`;
                setDataStatus({ status: overallStatus, message: finalMessage });

            } catch (error) { console.error("Failed to load or process API data:", error); setDataStatus({ status: 'error', message: `Fout bij laden: ${error.message}` }); setLastUpdated(new Date());
            } finally { if (refreshButtonRef.current) refreshButtonRef.current.disabled = false; if (autoRefresh) { const nextTime = new Date(Date.now() + REFRESH_INTERVAL_MS); setNextRefreshTime(nextTime); } else { setNextRefreshTime(null); } }
        }, [allGaugeStaticData, autoRefresh]); // Dependency on allGaugeStaticData is key

        // Initial data load trigger (Copied from index5)
       useEffect(() => { if (allGaugeStaticData.length > 0) loadGaugeApiData(false); }, [allGaugeStaticData, loadGaugeApiData]);

       // Auto-refresh timer (Copied from index5)
       useEffect(() => {
            if (!autoRefresh) { setNextRefreshTime(null); return () => {}; }
            let timerId;
            const setTimer = () => { const nextTime = new Date(Date.now() + REFRESH_INTERVAL_MS); setNextRefreshTime(nextTime); timerId = setTimeout(() => { console.log("Auto-refresh triggered at", new Date().toLocaleTimeString()); if (refreshButtonRef.current && !refreshButtonRef.current.disabled) { refreshHandlerRef.current?.(false); } else { console.log("Auto-refresh skipped, setting timer again."); setTimer(); } }, REFRESH_INTERVAL_MS); };
            setTimer();
            return () => clearTimeout(timerId);
        }, [autoRefresh]); // Removed handleRefresh dependency here


        // Fixed Header Logic Effect (Adapted from index6 - NO CHANGES NEEDED HERE)
        useEffect(() => {
            const sentinel = sentinelRef.current;
            const scrollWrapper = scrollWrapperRef.current;
            const originalTable = originalTableRef.current;
            const originalThead = originalTheadRef.current;
            const fixedHeaderContainer = fixedHeaderContainerRef.current;
            const fixedHeaderTable = fixedHeaderTableRef.current;

            // Ensure all elements are available
            if (!sentinel || !scrollWrapper || !originalTable || !originalThead || !fixedHeaderContainer || !fixedHeaderTable) {
                console.warn("Fixed header refs not ready.");
                return;
            }

            let clonedThead = null; // Store the cloned header node

            const cloneHeader = () => {
                 // Clear previous clone if exists
                while (fixedHeaderTable.firstChild) {
                    fixedHeaderTable.removeChild(fixedHeaderTable.firstChild);
                }
                // Clone the original thead (deep clone includes both <tr>)
                if (originalThead) {
                    clonedThead = originalThead.cloneNode(true);
                    fixedHeaderTable.appendChild(clonedThead);
                    // Apply initial sync if header is already fixed
                    if (isHeaderFixedRef.current) {
                        syncHeaderGeometry();
                        syncHeaderScroll(scrollWrapper.scrollLeft);
                    }
                } else {
                    console.warn("Original thead ref not found for cloning.");
                }
            };

            // Clone the header initially
            cloneHeader();

            const syncHeaderGeometry = () => {
                // Only run if the header is currently fixed and elements exist
                if (!isHeaderFixedRef.current || !scrollWrapper || !originalTable || !fixedHeaderContainer || !fixedHeaderTable) return;

                requestAnimationFrame(() => {
                    // Get dimensions of the scroll wrapper and the full table width
                    const scrollWrapperRect = scrollWrapper.getBoundingClientRect();
                     // Use offsetWidth for visible width, scrollWidth for full content width including overflow
                    const originalTableWidth = Math.max(originalTable.offsetWidth, originalTable.scrollWidth);

                    // Position the fixed container horizontally aligned with the scroll wrapper
                    fixedHeaderContainer.style.left = `${scrollWrapperRect.left}px`;
                    // Set fixed container width to match the visible width of the scroll wrapper
                    fixedHeaderContainer.style.width = `${scrollWrapper.clientWidth}px`;
                     // Set the table *inside* the fixed container to the full width of the original table
                     // This allows the inner table to be scrolled horizontally via the container's scrollLeft
                    fixedHeaderTable.style.width = `${originalTableWidth}px`;

                });
            };

            const syncHeaderScroll = (scrollLeft) => {
                // Only run if the fixed header container exists
                if (!fixedHeaderContainer) return;
                // Use requestAnimationFrame to avoid layout thrashing
                requestAnimationFrame(() => {
                    // Sync the horizontal scroll position of the fixed container
                    fixedHeaderContainer.scrollLeft = scrollLeft;
                });
            };

            // Intersection Observer setup
            const observer = new IntersectionObserver(
                ([entry]) => {
                    // Check if the sentinel element is scrolled above the viewport top
                    // entry.isIntersecting would be false, entry.boundingClientRect.top < 0 indicates it's above
                    const shouldBeFixed = !entry.isIntersecting && entry.boundingClientRect.top < 0;

                    if (shouldBeFixed && !isHeaderFixedRef.current) {
                        // Transition TO fixed state
                        isHeaderFixedRef.current = true;
                        originalThead?.classList.add('hidden'); // Hide original thead
                        syncHeaderGeometry(); // Set correct size/position
                        syncHeaderScroll(scrollWrapper.scrollLeft); // Set correct scroll position
                        fixedHeaderContainer?.classList.add('visible'); // Make fixed header visible
                    } else if (!shouldBeFixed && isHeaderFixedRef.current) {
                        // Transition FROM fixed state
                        isHeaderFixedRef.current = false;
                        originalThead?.classList.remove('hidden'); // Show original thead
                        fixedHeaderContainer?.classList.remove('visible'); // Hide fixed header
                    }
                },
                {
                    threshold: [0], // Trigger exactly when the sentinel top edge crosses the root edge
                    rootMargin: "0px" // No margin adjustment needed
                }
            );

            // Start observing the sentinel element
            observer.observe(sentinel);

            // Event listener for horizontal scrolling within the wrapper
            const handleScroll = () => {
                if (isHeaderFixedRef.current) {
                    // If header is fixed, sync its scroll position
                    syncHeaderScroll(scrollWrapper.scrollLeft);
                }
            };

            // Event listener for window resize or main page scroll (affects geometry)
            const handleResize = () => {
                // When resizing, always re-clone the header to ensure structure matches
                // if min-widths cause columns to appear/disappear or change relative size.
                // Also sync geometry if fixed.
                cloneHeader(); // Re-clone first
                if (isHeaderFixedRef.current) {
                    // If header is fixed, recalculate geometry and sync scroll *after* cloning
                    syncHeaderGeometry();
                    syncHeaderScroll(scrollWrapper.scrollLeft);
                }
            };

            // Attach listeners
            scrollWrapper.addEventListener('scroll', handleScroll, { passive: true });
            window.addEventListener('resize', handleResize);
            window.addEventListener('scroll', handleResize, { passive: true }); // Listen to window scroll too, as it affects `getBoundingClientRect`

            // Initial check in case the page loads scrolled down
            const initialCheckTimeout = setTimeout(() => {
                 // Re-check refs just in case they got unmounted quickly
                if (!sentinelRef.current || !scrollWrapperRef.current) return;

                const sentinelRect = sentinelRef.current.getBoundingClientRect();
                const shouldBeFixedInitially = sentinelRect.top < 0; // Check if sentinel is already above viewport

                if (shouldBeFixedInitially && !isHeaderFixedRef.current) {
                     isHeaderFixedRef.current = true;
                     originalTheadRef.current?.classList.add('hidden');
                     syncHeaderGeometry();
                     syncHeaderScroll(scrollWrapperRef.current.scrollLeft);
                     fixedHeaderContainerRef.current?.classList.add('visible');
                 } else if (!shouldBeFixedInitially && isHeaderFixedRef.current) {
                     // This case is less likely but handles edge scenarios
                     isHeaderFixedRef.current = false;
                     originalTheadRef.current?.classList.remove('hidden');
                     fixedHeaderContainerRef.current?.classList.remove('visible');
                 }
             }, 150); // Small delay to allow layout stabilization

            // Cleanup function
            return () => {
                clearTimeout(initialCheckTimeout);
                observer.disconnect();
                scrollWrapper?.removeEventListener('scroll', handleScroll);
                window.removeEventListener('resize', handleResize);
                window.removeEventListener('scroll', handleResize);
                // Reset state explicitly on unmount
                fixedHeaderContainerRef.current?.classList.remove('visible');
                originalTheadRef.current?.classList.remove('hidden');
                isHeaderFixedRef.current = false;
            };
        // DEPENDENCY: Depend on forecastDates.length. If the number of columns changes,
        // we need to re-run the effect to re-clone the header correctly.
        }, [forecastDates.length]); // Added forecastDates.length dependency


        // --- Event Handlers --- (Copied from index5)
        const handleCorrectionChange = (direction, gaugeName, value) => { const parsedValue = parseInt(value, 10); const newValue = value === '' ? 0 : (isNaN(parsedValue) ? (customCorrections[direction][gaugeName] || 0) : parsedValue); const newCorrections = { ...customCorrections, [direction]: { ...customCorrections[direction], [gaugeName]: newValue } }; setCustomCorrections(newCorrections); setCookie('rhineDraftCorrections', newCorrections); };
        const handleJourneyChange = (type, value) => { const newJourney = { ...journey, [type]: value ? parseInt(value, 10) : null }; setJourney(newJourney); setCookie('rhineDraftJourney', newJourney); };
        const handleRefresh = useCallback((force = true) => { console.log("Manual refresh triggered.", `Force: ${force}`); loadGaugeApiData(force); }, [loadGaugeApiData]); // Keep loadGaugeApiData dependency
        const refreshHandlerRef = useRef();
        useEffect(() => { refreshHandlerRef.current = handleRefresh; }, [handleRefresh]);
        const handleTabChange = (tab) => { setActiveTab(tab); };
        const handleDisplayModeChange = (event) => { setDisplayMode(event.target.value); };
        const handleUncertaintyToggle = (event) => { setShowUncertainty(event.target.checked); };

        // --- Calculations & Derived State --- (Copied from index5)
        useEffect(() => { if (journey.start !== null && journey.end !== null) { setTravelDirection(journey.start < journey.end ? 'downstream' : 'upstream'); } }, [journey]);
        const isInJourneyKmRange = useCallback((gaugeKm) => { /* ... same as index5 ... */ if (journey.start === null || journey.end === null || gaugeKm === null || gaugeKm === undefined) return false; const startKm = Number(journey.start); const endKm = Number(journey.end); if (isNaN(startKm) || isNaN(endKm)) return false; return gaugeKm >= Math.min(startKm, endKm) && gaugeKm <= Math.max(startKm, endKm); }, [journey]);
        const displayedGaugeData = useMemo(() => { /* ... same as index5 ... */ const data = allGaugeStaticData.filter(staticGauge => { const apiData = gaugeApiData[staticGauge.name]; const hasApiData = !!apiData && (apiData.status === 'OK' || apiData.status?.startsWith('CACHED') || apiData.status === 'WARNING'); if (activeTab === 'route') return staticGauge.isMainRoute && isInJourneyKmRange(staticGauge.km) && hasApiData; else return hasApiData; }).map(staticGauge => ({ ...staticGauge, apiData: gaugeApiData[staticGauge.name] })); return data; }, [allGaugeStaticData, gaugeApiData, activeTab, isInJourneyKmRange]);
        const calculateDraft = useCallback((gauge, waterLevel) => { /* ... same as index5 ... */ if (!gauge || waterLevel === null || waterLevel === undefined || isNaN(Number(waterLevel))) return null; if (gauge.name === "Konstanz") return null; const numericLevel = Number(waterLevel); const correction = customCorrections[travelDirection]?.[gauge.name] || 0; if (gauge.river === 'Depth') { const safetyMargin = gauge.officialSafetyMargin !== 'N/A' ? Number(gauge.officialSafetyMargin) : DEFAULT_DEPTH_SAFETY_MARGIN; if (isNaN(safetyMargin)) return null; return (numericLevel - safetyMargin + correction); } else if (gauge.customVuistregel !== undefined && gauge.customVuistregel !== null && !isNaN(Number(gauge.customVuistregel))) return (numericLevel + Number(gauge.customVuistregel) + correction); else if (['Rijn', 'IJssel'].includes(gauge.river) && gauge.giw !== 'N/A' && gauge.depthAtGiw !== 'N/A' && gauge.officialSafetyMargin !== 'N/A') { const giw = Number(gauge.giw); const depth = Number(gauge.depthAtGiw); const safety = Number(gauge.officialSafetyMargin); if (!isNaN(giw) && !isNaN(depth) && !isNaN(safety)) return (numericLevel - giw + depth - safety + correction); else return null; } return null; }, [customCorrections, travelDirection]);
        const calculateOfficialRuleOfThumb = useCallback((gauge) => { /* ... same as index5 ... */ if (gauge.river === 'Depth' || gauge.giw === 'N/A' || gauge.depthAtGiw === 'N/A' || gauge.officialSafetyMargin === 'N/A') return "N/A"; const giw = Number(gauge.giw); const depth = Number(gauge.depthAtGiw); const safety = Number(gauge.officialSafetyMargin); if (isNaN(giw) || isNaN(depth) || isNaN(safety)) return "N/A"; if (["Nijmegen", "Tiel", "Bingen", "Iffezheim", "Konstanz", "Lobith", "Pannerdense kop", "IJsselkop", "Doesburg", "Deventer", "Katerveer"].includes(gauge.name)) return "N/A"; return (depth - safety - giw).toFixed(0); }, []);
        const calculateCustomRuleOfThumbDisplay = useCallback((gauge, direction) => { /* ... same as index5 ... */ if (!gauge || gauge.river === 'Depth' || gauge.name === "Konstanz") return "N/A"; const correction = customCorrections[direction]?.[gauge.name] || 0; let baseRule = null; if (gauge.customVuistregel !== undefined && gauge.customVuistregel !== null && !isNaN(Number(gauge.customVuistregel))) baseRule = Number(gauge.customVuistregel); else { const officialRule = calculateOfficialRuleOfThumb(gauge); if (officialRule !== "N/A") baseRule = Number(officialRule); } if (baseRule !== null) return (baseRule + correction).toFixed(0); return "N/A"; }, [customCorrections, calculateOfficialRuleOfThumb]);
        const findCriticalGauge = useCallback(() => { /* ... same as index5 ... */ if (activeTab !== 'route' || displayedGaugeData.length === 0) return { name: null, draft: null, apiData: null }; let criticalGaugeName = null; let minDraft = Infinity; let criticalApiData = null; displayedGaugeData.forEach(gauge => { const apiData = gauge.apiData; if (apiData && apiData.currentLevel !== null) { const draft = calculateDraft(gauge, apiData.currentLevel); if (draft !== null && !isNaN(Number(draft))) { const numericDraft = Number(draft); if (numericDraft < minDraft) { minDraft = numericDraft; criticalGaugeName = gauge.name; criticalApiData = apiData; } } } }); return { name: criticalGaugeName, draft: minDraft === Infinity ? null : minDraft, apiData: criticalApiData }; }, [activeTab, displayedGaugeData, calculateDraft]);
        const { name: criticalGaugeName, draft: criticalDraftValue, apiData: criticalApiDataForHighlight } = findCriticalGauge();
        const todayStr = useMemo(() => { /* ... same as index5 ... */ const todayDate = new Date(); const nlYear = todayDate.toLocaleDateString('en-CA', { year: 'numeric', timeZone: 'Europe/Amsterdam' }); const nlMonth = todayDate.toLocaleDateString('en-CA', { month: '2-digit', timeZone: 'Europe/Amsterdam' }); const nlDay = todayDate.toLocaleDateString('en-CA', { day: '2-digit', timeZone: 'Europe/Amsterdam' }); return `${nlYear}-${nlMonth}-${nlDay}`; }, []);
        const forecastBottlenecks = useMemo(() => { /* ... same calculation logic as index5 ... */ if (activeTab !== 'route' || forecastDates.length === 0 || displayedGaugeData.length === 0) return []; return forecastDates.map(dateStr => { let criticalGauge = null; let minDraft = Infinity; let forecastTime = null; let forecastLevelForCrit = null; let forecastSlotForCrit = null; let weeklyForecastSlotForCrit = null; let valueSource = null; let uncertaintyText = ''; displayedGaugeData.forEach(gauge => { const apiData = gauge.apiData; let potentialDraft = null; let currentForecastLevel = null; let currentForecastTime = null; let currentForecastSlot = null; let currentWeeklyForecastSlot = null; let currentValueSource = null; const forecastsForDate = apiData?.forecasts?.[dateStr]; if (forecastsForDate && Object.keys(forecastsForDate).length > 0) { const selectedTime = getBestForecastTime(forecastsForDate, apiData?.currentTime); const dailySlot = selectedTime ? forecastsForDate[selectedTime] : null; if (dailySlot && dailySlot.value !== undefined && dailySlot.value !== null) { currentForecastLevel = dailySlot.value; currentForecastTime = selectedTime; currentForecastSlot = dailySlot; currentValueSource = 'daily'; potentialDraft = calculateDraft(gauge, currentForecastLevel); } } if (potentialDraft === null && Array.isArray(apiData?.weeklyForecasts) && apiData.weeklyForecasts.length > 0) { const targetDate = new Date(dateStr + 'T12:00:00Z'); for (const weeklyForecast of apiData.weeklyForecasts) { if (weeklyForecast.weekRange && weeklyForecast.median !== null) { try { const [startStr, endStr] = weeklyForecast.weekRange.split('-'); const [startDay, startMonth, startYear] = startStr.split('.'); const [endDay, endMonth, endYear] = endStr.split('.'); const startDate = new Date(Date.UTC(startYear, startMonth - 1, startDay, 0, 0, 0)); const endDate = new Date(Date.UTC(endYear, endMonth - 1, endDay, 23, 59, 59)); if (!isNaN(startDate.getTime()) && !isNaN(endDate.getTime()) && targetDate >= startDate && targetDate <= endDate) { currentForecastLevel = weeklyForecast.median; currentForecastTime = "(BfG6W)"; currentForecastSlot = null; currentWeeklyForecastSlot = weeklyForecast; currentValueSource = 'weekly'; potentialDraft = calculateDraft(gauge, currentForecastLevel); break; } } catch (e) { console.warn(`Error parsing weekRange in bottleneck calc "${weeklyForecast.weekRange}" for gauge ${gauge.name}:`, e); } } } } if (potentialDraft !== null && !isNaN(Number(potentialDraft))) { const numericDraft = Number(potentialDraft); if (numericDraft < minDraft) { minDraft = numericDraft; criticalGauge = gauge; forecastTime = currentForecastTime; forecastLevelForCrit = currentForecastLevel; forecastSlotForCrit = currentForecastSlot; weeklyForecastSlotForCrit = currentWeeklyForecastSlot; valueSource = currentValueSource; } } }); if (criticalGauge && showUncertainty) { if (valueSource === 'daily' && forecastSlotForCrit) { if (forecastSlotForCrit.low_80 !== null && forecastSlotForCrit.high_80 !== null) { const draftLow = calculateDraft(criticalGauge, forecastSlotForCrit.low_80); const draftHigh = calculateDraft(criticalGauge, forecastSlotForCrit.high_80); if (draftLow !== null && draftHigh !== null && !isNaN(draftLow) && !isNaN(draftHigh)) { uncertaintyText = `(${Math.min(draftLow, draftHigh).toFixed(0)} - ${Math.max(draftLow, draftHigh).toFixed(0)} cm)`; } else { uncertaintyText = '(Bereik N/A)'; } } else if (forecastLevelForCrit !== null) { const daysAhead = diffDays(todayStr, dateStr); if (!isNaN(daysAhead) && daysAhead > 0) { const elwisUncertainty = daysAhead <= 2 ? 10 : 20; const draftLow = calculateDraft(criticalGauge, forecastLevelForCrit - elwisUncertainty); const draftHigh = calculateDraft(criticalGauge, forecastLevelForCrit + elwisUncertainty); if (draftLow !== null && draftHigh !== null && !isNaN(draftLow) && !isNaN(draftHigh)) { uncertaintyText = `(${Math.min(draftLow, draftHigh).toFixed(0)} - ${Math.max(draftLow, draftHigh).toFixed(0)} cm*)`; } else { uncertaintyText = `(±${elwisUncertainty} cm)`; } } } } else if (valueSource === 'weekly' && weeklyForecastSlotForCrit) { if (weeklyForecastSlotForCrit.low_90 !== null && weeklyForecastSlotForCrit.high_90 !== null) { const draftLow = calculateDraft(criticalGauge, weeklyForecastSlotForCrit.low_90); const draftHigh = calculateDraft(criticalGauge, weeklyForecastSlotForCrit.high_90); if (draftLow !== null && draftHigh !== null && !isNaN(draftLow) && !isNaN(draftHigh)) { uncertaintyText = `(${Math.min(draftLow, draftHigh).toFixed(0)} - ${Math.max(draftLow, draftHigh).toFixed(0)} cm)`; } else { uncertaintyText = '(Bereik N/A)'; } } } } return { date: dateStr, gauge: criticalGauge?.name || null, draft: criticalGauge && minDraft !== Infinity ? minDraft.toFixed(0) : 'N/A', time: forecastTime, uncertainty: uncertaintyText }; }); }, [activeTab, forecastDates, displayedGaugeData, calculateDraft, showUncertainty, todayStr, getBestForecastTime, diffDays]); // Added diffDays dependency


        // --- Render ---
        return (
            <div className="container">
                {/* --- Fixed Header Container --- */}
                <div className="fixed-header-container" ref={fixedHeaderContainerRef}>
                    {/* Table structure mirrors original thead, populated by JS */}
                    <table ref={fixedHeaderTableRef}></table>
                </div>

                {/* Header Controls (from index5) */}
                <header className="controls-area">
                    <div className="controls-left">
                         {/* ... Controls content from index5 ... */}
                         <h1 style={{ margin: '0 0 0.5rem 0', fontSize: '1.5rem' }}>Rijn Diepgang Calculator</h1> {/* Adjusted title size */}
                         <div className="control-group"> <label><input type="checkbox" checked={autoRefresh} onChange={(e) => setAutoRefresh(e.target.checked)} />Auto-verversing ({REFRESH_INTERVAL_MS / 60000} min)</label> {autoRefresh && nextRefreshTime && <span style={{ marginLeft: '8px', fontSize: '0.8em', color: '#aaa' }}>Volgende: {nextRefreshTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>} </div>
                         <div className="control-group"> <label>Traject (Rijn/Waal):</label> <select value={journey.start ?? ''} onChange={(e) => handleJourneyChange('start', e.target.value)}> <option value="">Selecteer begin</option> {allGaugeStaticData.filter(g => g.isMainRoute).map(gauge => <option key={`start-${gauge.km}-${gauge.name}`} value={gauge.km}>{gauge.km} ({gauge.name})</option>)} </select> <span>tot</span> <select value={journey.end ?? ''} onChange={(e) => handleJourneyChange('end', e.target.value)}> <option value="">Selecteer einde</option> {allGaugeStaticData.filter(g => g.isMainRoute).map(gauge => <option key={`end-${gauge.km}-${gauge.name}`} value={gauge.km}>{gauge.km} ({gauge.name})</option>)} </select> </div>
                         <div className="control-group"> <label>Weergave Modus:</label> <div className="view-toggle-group"> <label><input type="radio" value="draft" checked={displayMode === 'draft'} onChange={handleDisplayModeChange} /> Diepgang</label> <label><input type="radio" value="level" checked={displayMode === 'level'} onChange={handleDisplayModeChange} /> Waterstand (ruw) </label> </div> </div>
                         <div className="control-group"> <label> <input type="checkbox" checked={showUncertainty} onChange={handleUncertaintyToggle} /> Toon Prognose Onzekerheid (indien beschikbaar) </label> </div>
                         <div className="control-group"> <button className="refresh-btn" onClick={() => handleRefresh(true)} ref={refreshButtonRef} disabled={dataStatus.status === 'pending'}> {dataStatus.status === 'pending' ? 'Laden...' : 'Data opnieuw laden'} </button> <div className={`data-status ${dataStatus.status}`}> {dataStatus.message} {dataStatus.status !== 'pending' && lastUpdated ? `(API tijd: ${lastUpdated.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})})` : ''} </div> </div>
                    </div>
                    {/* Highlight Box (from index5) */}
                    {activeTab === 'route' && (
                        <div className="controls-right highlight-box">
                            {/* ... Highlight box content from index5 ... */}
                            <div style={{ marginBottom: '6px', fontWeight: 'bold' }}>Kritieke diepgang ({travelDirection === 'downstream' ? 'Af' : 'Op'}):</div>
                            <div> <span className="label">Nu:</span> <span className="value">{criticalDraftValue !== null ? `${criticalDraftValue.toFixed(0)} cm` : 'N/A'}</span> <span className="gauge">({criticalGaugeName || 'N/A'})</span> <span className="time">({criticalApiDataForHighlight?.currentTime || 'N/A'})</span> </div>
                            {forecastBottlenecks.map((forecast) => ( <div key={`forecast-bottleneck-${forecast.date}`}> <span className="label">{new Date(forecast.date + 'T12:00:00Z').toLocaleDateString('nl-NL', { weekday: 'short', day: 'numeric' })}:</span> <span className="value"> {forecast.draft !== 'N/A' ? `${forecast.draft} cm` : 'N/A'} {showUncertainty && forecast.uncertainty && ( <span style={{fontSize: '0.85em', color: '#333', fontWeight: 'normal', marginLeft: '4px'}}> {forecast.uncertainty} </span> )} </span> <span className="gauge">({forecast.gauge || 'N/A'})</span> <span className="time">({forecast.time || 'N/A'})</span> </div> ))}
                            {forecastDates.length > 0 && forecastBottlenecks.every(f => f.gauge === null) && dataStatus.status !== 'pending' && <div style={{fontSize: '0.85em', color: '#333', marginTop: '4px'}}>Geen kritieke prognose gevonden</div>}
                            {forecastDates.length === 0 && dataStatus.status !== 'pending' && <div style={{fontSize: '0.85em', color: '#333', marginTop: '4px'}}>Geen prognose data beschikbaar</div>}
                            {dataStatus.status === 'pending' && <div style={{fontSize: '0.85em', color: '#333', marginTop: '4px'}}>Prognoses laden...</div>}
                        </div>
                    )}
                    {activeTab !== 'route' && ( <div className="controls-right"><p style={{fontSize: '0.9em', color: '#aaa'}}>Alle beschikbare peilingen en dieptes.</p></div> )}
                </header>

                {/* Main Content Area */}
                <div className="main-content">
                    {/* Tabs (from index5) */}
                    <div className="tab-controls">
                        <button className={`tab-button ${activeTab === 'route' ? 'active' : ''}`} onClick={() => handleTabChange('route')} >Route Planner (Rijn/Waal)</button>
                        <button className={`tab-button ${activeTab === 'all' ? 'active' : ''}`} onClick={() => handleTabChange('all')}>Alle Peilingen & Dieptes ({displayedGaugeData.length})</button>
                    </div>

                    {/* --- Table Area Layout (using index6 structure) --- */}
                    <div className="table-area-padding">
                        {/* Sentinel element to detect when header should stick */}
                        <div className="header-sentinel" ref={sentinelRef}></div>

                        {/* Wrapper for horizontal scrolling */}
                        <div className="table-scroll-wrapper" ref={scrollWrapperRef}>
                            {/* The actual table */}
                            <table className="original-table" ref={originalTableRef}>
                                {/* Header - Ref is added here */}
                                <thead ref={originalTheadRef}>
                                    {/* Header rows (Structure from index5 - adjusted labels for space) */}
                                    <tr>
                                        <th rowSpan="2">Rivier</th>
                                        <th rowSpan="2">Strecke</th>
                                        <th rowSpan="2">Naam</th>
                                        <th rowSpan="2" className="numeric">GIW<br/><span style={{fontSize: '0.85em', fontWeight: 'normal'}}>(cm)</span></th>
                                        <th rowSpan="2" className="numeric">TuGIW<br/><span style={{fontSize: '0.85em', fontWeight: 'normal'}}>(cm)</span></th>
                                        <th rowSpan="2" className="numeric"> Waarde <br/> <span style={{fontSize: '0.85em', fontWeight: 'normal'}}>(Act., cm)</span></th>
                                        <th rowSpan="2" className="numeric">Tendens<br/> <span style={{fontSize: '0.85em', fontWeight: 'normal'}}>(24h)</span></th>
                                        <th rowSpan="2" className="numeric">Officiële <br/> Vuistregel<br/><span
                                            style={{fontSize: '0.85em', fontWeight: 'normal'}}>(cm)</span></th>
                                        <th colSpan="2" className="center">Correctie (cm)</th>
                                        {/* Aangepaste Vuistregel header - Already correct with colspan=2 */}
                                        <th colSpan="2" className="center">Aangepaste <br/> Vuistregel (cm)</th>
                                        <th rowSpan="2" className="numeric"> {displayMode === 'draft' ? 'Diepgang' : 'Waarde'} <br/> <span style={{fontSize: '0.85em', fontWeight: 'normal'}}>(Act., cm)</span></th>
                                        {/* Add 'forecast-header' class for min-width targeting */}
                                        {forecastDates.map(dateStr => (
                                            <th key={`forecast-hdr-${dateStr}`} rowSpan="2" className="numeric forecast-header">
                                                {new Date(dateStr + 'T12:00:00Z').toLocaleDateString('nl-NL', { weekday: 'short', day: 'numeric' })} <br/>
                                                <span style={{ fontSize: '0.85em', fontWeight: 'normal' }}> ({displayMode === 'draft' ? 'D' : 'S'}, cm) </span>
                                            </th>
                                        ))}
                                        {forecastDates.length === 0 && dataStatus.status !== 'pending' && <th rowSpan="2" className="forecast-header">Geen Prognoses</th>}
                                    </tr>
                                    <tr>
                                        {/* Sub-headers for Correctie */}
                                        <th className="numeric">Op</th>
                                        <th className="numeric">Af</th>
                                         {/* Sub-headers for Aangepaste Vuistregel */}
                                        <th className="numeric">Op</th>
                                        <th className="numeric">Af</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {/* Loading/No Data Messages (from index5) */}
                                    {dataStatus.status === 'pending' && ( <tr><td colSpan={13 + Math.max(1, forecastDates.length)} style={{textAlign: 'center', fontStyle: 'italic', padding: '1rem'}}>Laden...</td></tr> )}
                                    {dataStatus.status !== 'pending' && displayedGaugeData.length === 0 && ( <tr><td colSpan={13 + Math.max(1, forecastDates.length)} style={{textAlign: 'center', fontStyle: 'italic', padding: '1rem'}}> {activeTab === 'route' ? 'Selecteer een geldig Rijn/Waal traject of geen data beschikbaar voor traject.' : (Object.keys(gaugeApiData).length === 0 ? 'Geen API data geladen.' : 'Geen data beschikbaar voor deze weergave.')} </td></tr> )}

                                    {/* Table Body Rows (Logic from index5) */}
                                    {displayedGaugeData.map(gauge => {
                                        const apiData = gauge.apiData; if (!apiData) return null;
                                        const isCritical = activeTab === 'route' && gauge.name === criticalGaugeName;
                                        const currentLevel = apiData.currentLevel; const currentTime = apiData.currentTime || 'N/A'; const currentTrend = apiData.currentTrend ?? '-';
                                        const officialRuleDisplay = calculateOfficialRuleOfThumb(gauge); const customRuleDisplayUp = calculateCustomRuleOfThumbDisplay(gauge, 'upstream'); const customRuleDisplayDown = calculateCustomRuleOfThumbDisplay(gauge, 'downstream');
                                        const currentActualDraft = currentLevel !== null ? calculateDraft(gauge, currentLevel) : null; const currentLevelDisplay = currentLevel;
                                        let lastColumnClass = "numeric "; let lastColumnValue = '-';
                                        if (displayMode === 'draft') { lastColumnClass += 'actual-draft-column'; if (currentActualDraft !== null) { lastColumnValue = currentActualDraft.toFixed(0); if (isCritical) lastColumnClass += ' critical-actual-draft'; } } else { lastColumnClass += 'actual-level-column'; if (currentLevelDisplay !== null) { lastColumnValue = currentLevelDisplay.toFixed(0); if (isCritical) lastColumnClass += ' critical-actual-level'; } }
                                        let levelColumnClass = 'numeric'; if (currentLevelDisplay !== null && isCritical) levelColumnClass += ' critical-level';

                                        return (
                                            <tr key={`${gauge.name}-${gauge.km ?? gauge.streckenAbschnitt ?? apiData?.apiName}`} className={isCritical ? 'critical-row' : ''}>
                                                {/* Cols 1-13 */}
                                                <td>{gauge.river || 'N/A'}</td> <td>{gauge.streckenAbschnitt || 'N/A'}</td>
                                                <td><a href={getGaugeUrl(gauge)} target="_blank" rel="noopener noreferrer" className="gauge-link">{gauge.name}</a></td>
                                                <td className="numeric">{gauge.giw !== 'N/A' ? gauge.giw : '-'}</td> <td className="numeric">{gauge.depthAtGiw !== 'N/A' ? gauge.depthAtGiw : '-'}</td>
                                                <td className={levelColumnClass}> {currentLevelDisplay !== null ? currentLevelDisplay.toFixed(0) : (apiData.status === 'ERROR' ? `Error` : '-')} <div className="time-display">{currentTime !== 'N/A' ? currentTime : (apiData.status ? '' : 'Laden..')}</div> </td>
                                                <td className="numeric">{currentTrend}</td> <td className="numeric">{officialRuleDisplay}</td>
                                                <td className="numeric"><input type="number" value={customCorrections.upstream[gauge.name] ?? ''} onChange={(e) => handleCorrectionChange('upstream', gauge.name, e.target.value)} /></td>
                                                <td className="numeric"><input type="number" value={customCorrections.downstream[gauge.name] ?? ''} onChange={(e) => handleCorrectionChange('downstream', gauge.name, e.target.value)} /></td>
                                                <td className="numeric">{customRuleDisplayUp}</td> <td className="numeric">{customRuleDisplayDown}</td>
                                                <td className={lastColumnClass}> {lastColumnValue} {lastColumnValue !== '-' && <div className="time-display">{currentTime !== 'N/A' ? currentTime : ''}</div>} </td>

                                                {/* Col 14+: Forecasts (Logic from index5) */}
                                                {forecastDates.map(dateStr => {
                                                    let forecastDisplayValue = '-'; let forecastDisplayTime = '';
                                                    let uncertaintyText = ''; let valueSource = ''; let foundWeeklySlot = null;

                                                    const forecastsForDate = apiData.forecasts?.[dateStr];
                                                    if (forecastsForDate && Object.keys(forecastsForDate).length > 0) {
                                                        const selectedTime = getBestForecastTime(forecastsForDate, currentTime); const forecastSlot = selectedTime ? forecastsForDate[selectedTime] : null;
                                                        if (forecastSlot && forecastSlot.value !== undefined && forecastSlot.value !== null) {
                                                            const forecastLevel = forecastSlot.value; forecastDisplayTime = selectedTime; valueSource = 'daily';
                                                            let calculatedFcValue = (displayMode === 'draft') ? calculateDraft(gauge, forecastLevel) : forecastLevel;
                                                            forecastDisplayValue = calculatedFcValue !== null ? calculatedFcValue.toFixed(0) : '-';
                                                            if (showUncertainty && calculatedFcValue !== null) {
                                                                if (forecastSlot.low_80 !== null && forecastSlot.high_80 !== null) { let lowVal = forecastSlot.low_80; let highVal = forecastSlot.high_80; if (displayMode === 'draft') { lowVal = calculateDraft(gauge, forecastSlot.low_80); highVal = calculateDraft(gauge, forecastSlot.high_80); } if (lowVal !== null && !isNaN(lowVal) && highVal !== null && !isNaN(highVal)) { uncertaintyText = `(${Math.min(lowVal, highVal).toFixed(0)}–${Math.max(lowVal, highVal).toFixed(0)})`; } else uncertaintyText = '(Bereik N/A)'; } // Used en-dash
                                                                else { const daysAhead = diffDays(todayStr, dateStr); if (!isNaN(daysAhead) && daysAhead > 0) { const elwisUncertainty = daysAhead <= 2 ? 10 : 20; uncertaintyText = `(±${elwisUncertainty} cm)`; } }
                                                            }
                                                        }
                                                    }

                                                    if (forecastDisplayValue === '-' && Array.isArray(apiData.weeklyForecasts) && apiData.weeklyForecasts.length > 0) {
                                                        const targetDate = new Date(dateStr + 'T12:00:00Z');
                                                        for (const weeklyForecast of apiData.weeklyForecasts) {
                                                            if (weeklyForecast.weekRange && weeklyForecast.median !== null) {
                                                                try { const [startStr, endStr] = weeklyForecast.weekRange.split('-'); const [startDay, startMonth, startYear] = startStr.split('.'); const [endDay, endMonth, endYear] = endStr.split('.'); const startDate = new Date(Date.UTC(startYear, startMonth - 1, startDay, 0, 0, 0)); const endDate = new Date(Date.UTC(endYear, endMonth - 1, endDay, 23, 59, 59)); if (!isNaN(startDate.getTime()) && !isNaN(endDate.getTime()) && targetDate >= startDate && targetDate <= endDate) { const forecastLevel = weeklyForecast.median; let calculatedFcValue = (displayMode === 'draft') ? calculateDraft(gauge, forecastLevel) : forecastLevel; if (calculatedFcValue !== null) { forecastDisplayValue = calculatedFcValue.toFixed(0); forecastDisplayTime = "(BfG6W)"; valueSource = 'weekly'; foundWeeklySlot = weeklyForecast; break; } } }
                                                                catch (e) { console.warn(`Error parsing weekRange "${weeklyForecast.weekRange}" for gauge ${gauge.name}:`, e); }
                                                            }
                                                        }
                                                    }

                                                    if (valueSource === 'weekly' && showUncertainty && foundWeeklySlot) {
                                                        if (foundWeeklySlot.low_90 !== null && foundWeeklySlot.high_90 !== null) { let lowVal = foundWeeklySlot.low_90; let highVal = foundWeeklySlot.high_90; if (displayMode === 'draft') { lowVal = calculateDraft(gauge, foundWeeklySlot.low_90); highVal = calculateDraft(gauge, foundWeeklySlot.high_90); } if (lowVal !== null && !isNaN(lowVal) && highVal !== null && !isNaN(highVal)) { uncertaintyText = `(${Math.min(lowVal, highVal).toFixed(0)}–${Math.max(lowVal, highVal).toFixed(0)})`; } else uncertaintyText = '(Bereik N/A)'; } // Used en-dash
                                                    }

                                                    // Add 'forecast-cell' class for potential body cell styling
                                                    return ( <td key={`forecast-${gauge.name}-${dateStr}`} className="numeric forecast-cell"> {forecastDisplayValue !== '-' ? ( <div> {forecastDisplayValue} {showUncertainty && uncertaintyText && (<span className="uncertainty-display">{uncertaintyText}</span>)} {forecastDisplayTime && (<div className={`time-display ${valueSource === 'weekly' ? 'weekly' : ''}`}>{forecastDisplayTime}</div>)} </div> ) : ('-') } </td> );
                                                })}
                                                {forecastDates.length === 0 && dataStatus.status !== 'pending' && <td className="forecast-cell">-</td>}
                                            </tr>
                                        );
                                    })}
                                </tbody>
                            </table>
                        </div> {/* End .table-scroll-wrapper */}
                    </div> {/* End .table-area-padding */}
                </div> {/* End .main-content */}

                {/* Footer (from index5) */}
                <footer>
                     <div>Data API per: {lastUpdated ? lastUpdated.toLocaleString('nl-NL', { dateStyle: 'short', timeStyle: 'short' }) : 'Nog niet geladen'}</div>
                    <div>RDD Calculator v5.1 - Compact Layout</div> {/* Updated version */}
                </footer>
            </div>
        );
    }

    ReactDOM.render(<RhineDraftCalculator />, document.getElementById('root'));

</script>
</body>
</html>